# --------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
# -------------------------------------------------------------- 
#
# parse.yp
#
# Parsed CIF file structure overview is described at the end of this file.
# --------------------------------------------------------------
# begin of header
# --------------------------------------------------------------
# copy directly to PERL module:
%{
use warnings;

my $SVNID = '$Id$';

# 0 - no debug
# 1 - only YAPP output (type -> value)
# 2 - lex & yapp output
my $debug = 0;
%}
# --------------------------------------------------------------

# --------------------------------------------------------------
# begin of body
# --------------------------------------------------------------

%%
cif_file
	:	opt_wspace #empty
	|	opt_wspace data_block_set opt_wspace
;

opt_wspace
	:	whitespace
	|	#empty
;

data_block_set
	:	data_block_head
	| 	data_block_set whitespace cif_entry
	|	data_block_set whitespace data_block_head
;

data_block_head
	:	DATA_
		{
			{ kind => 'data',
				name => $_[1]
			}
		}
;

cif_entry
	:	TAG whitespace cif_value
		{
			if(defined $_[3]->{precision})
			{
				{ name => $_[1],
					kind => 'TAG',
					value => $_[3]->{value},
					type => $_[3]->{type},
					precision => $_[3]->{precision}
				}
			} else {
				{ name => $_[1],
					kind => 'TAG',
					value => $_[3]->{value},
					type => $_[3]->{type}
				}
			}
		}
;

cif_value
	:	string
		{	print $_[1]->{type} . "\t->\t"
				. $_[1]->{value} . "\n" if $debug >= 1;
			$_[1];
		}
	|	number
		{	print $_[1]->{type} . "\t\t->\t"
				. $_[1]->{value} . " -- "
				. $_[1]->{precision}
				. "\n" if $debug >= 1;
			$_[1];
		}
	|	textfield
		{	print "TFIELD\t\t->\t" .
				$_[1]->{value} . "\n"
				if $debug >= 1;
			$_[1];
		}
;

whitespace
	:	whitespace WSPACE
		{
			if($debug >= 2 && defined $_[2])
			{
				print "WSPACE\t\t->\t" . $_[2] . "\n";
			}
			{ value => $_[2], type => 'WSPACE' };
		}
	|	whitespace TOKENIZED_COMMENT
		{
			if($debug >= 1)
			{
				print "TCOMMENT\t->\t" . $_[2] . "\n";
			}
			{ value => $_[2], type => 'TCOMMENT' };
		}
	|	whitespace COMMENT
		{	print "COMMENT\t\t->\t"
				. $_[1] . "\n" if $debug >= 1;
			$_[1];
		}
	|	WSPACE
		{
			if($debug >= 2 && defined $_[1])
			{
				print "WSPACE\t\t->\t" . $_[1] . "\n";
			}
			{ value => $_[1], type => 'WSPACE' };
		}
	|	TOKENIZED_COMMENT
		{
			if($debug >= 1)
			{
				print "TCOMMENT\t->\t" . $_[1] . "\n";
			}
			{ value => $_[1], type => 'TCOMMENT' };
		}
	|	COMMENT
		{	print "COMMENT\t\t->\t"
				. $_[1] . "\n" if $debug >= 1;
			$_[1];
		}
;

string
	:		SQSTRING	{ { value => $_[1],
			type => 'SQSTRING'} }
	|	DQSTRING	{ { value => $_[1],
			type => 'DQSTRING'} }
	|	UQSTRING	{ { value => $_[1],
			type => 'UQSTRING'} }
	|	TEXT_FIELD	{ { value => $_[1],
			type => 'TEXTFIELD' } }
;

number
	:	FLOAT
		{
			if( $_[1] =~ m/^(.*)( \( ([0-9]+) \) )$/six )
			{
				my $value	= $1;
				my $precision	= $3;
				#parsing float value:
				# - $1 - part before decimal dot
				# - $2 - decimal dot
				# - $3 - mantissa (part after d-dot)
				# - $4 - exponent
				$value =~ m/
						([-+]?[0-9]*)?
						(\.)?
						([0-9]+)?
						(?:e([+-]?[0-9]+))?
					/six;
				if( defined $2 )
				{
					if( defined $4 )
					{
						$precision /= 10**(length($3));
						$precision *= 10**($4);
					} else {
						$precision /= 10**(length($3));
					}
				} else {
					$precision *= 10**($4);
				}
				{	type => 'FLOAT',
					value => $value,
					precision => $precision
				}
			} else {
				{	type => 'FLOAT',
					value => $_[1],
					precision => 'undef'
				}
			}
		}
	|	INT
		{
			if( $_[1] =~ m/^(.*)( \( ([0-9]+) \) )$/sx)
			{
				{	type => 'INT',
					value => $1,
					precision => $3
				}
			} else {
				{	type => 'INT',
					value => $_[1],
					precision => 'undef'
				}
			}
		}
;

%%
# --------------------------------------------------------------
# begin of footer
# --------------------------------------------------------------

sub _Error
{
	exists $_[0]->YYData->{ERRMSG}
	and do {
		print $_[0]->YYData->{ERRMSG};
		delete $_[0]->YYData->{ERRMSG};
		return;
	};
	print "Analyzed symbols line containing bogus data (num. " . 
		$_[0]->YYData->{VARS}{lines} . " pos. " . 
		$_[0]->YYData->{VARS}{token_prev_pos} . ") was:\n" . 
		$_[0]->YYData->{VARS}{current_line} . "\n";
	print " " x $_[0]->YYData->{VARS}{token_prev_pos};
	print "^\n";
}

sub _Lexer
{
	my($parser) = shift;

	if( !defined $parser->YYData->{INPUT} ||
		$parser->YYData->{INPUT} =~ m/^\s*$/ )
	{
		do
		{
			$parser->YYData->{INPUT} = <STDIN>;
			$parser->YYData->{VARS}{lines}++;
		} until ( !defined $parser->YYData->{INPUT} ||
			$parser->YYData->{INPUT} !~ m/^\s*$/ );
		if( defined $parser->YYData->{INPUT} )
		{
			chomp $parser->YYData->{INPUT};
			$parser->YYData->{INPUT}=~s/\t/    /g;
			$parser->YYData->{VARS}{current_line} = 
				$parser->YYData->{INPUT};
			$parser->YYData->{VARS}{token_pos} = 0;
			return('WSPACE', "\n");
		} else {			
			return('',undef);
		}
	}

	if($debug >= 2)
	{
		print ">>> '", $parser->YYData->{INPUT}, "'\n";
	}

#scalars storing regular expressions, common to several matches
my $ORDINARY_CHAR	=	
	qr/[a-zA-Z0-9!%&\(\)\*\+,-\.\/\:<=>\?@\\\^`{\|}~]/is;
my $SPECIAL_CHAR	=	qr/["#\$'_\[\]]/is;
my $NON_BLANK_CHAR	=	qr/(?:$ORDINARY_CHAR|$SPECIAL_CHAR|;)/is;
my $TEXT_LEAD_CHAR	=	qr/(?:$ORDINARY_CHAR|$SPECIAL_CHAR|\s)/s;
my $ANY_PRINT_CHAR	=	qr/(?:$NON_BLANK_CHAR|\s)/is;
my $COMMENT		=	qr/(#${ANY_PRINT_CHAR}*$)/s;
my $INTEGER		=	qr/[-+]?[0-9]+/s;
my $EXPONENT		=	qr/e[-+]?[0-9]+/is;
my $FLOAT11		=	qr/(?: $INTEGER $EXPONENT)/ix;
my $FLOAT21		=	qr/(?: [+-]? [0-9]* \. [0-9]+ $EXPONENT ?)/ix;
my $FLOAT31		=	qr/(?: $INTEGER \. $EXPONENT ?)/ix;
my $FLOAT		=	qr/(?: (?: $FLOAT11 | $FLOAT21 | $FLOAT31))/six;

	for ($parser->YYData->{INPUT})
	{
		#matching floats:
		if( s/^(?: ($FLOAT (?:\([0-9]+\))?) (\s) )/$2/six
			|| s/^($FLOAT (?:\([0-9]+\))?)$//six )
		{
			advance_token($parser);
			return('FLOAT', $1);
		}
		#matching integers:
		if( s/^($INTEGER (?:\([0-9]+\))?)(\s)/$2/sx
			|| s/^($INTEGER (?:\([0-9]+\))?)$//sx )
		{
			advance_token($parser);
			return('INT', $1);
		}
		#matching double quoted strings
		if( s/^("${ANY_PRINT_CHAR}*")(\s)/$2/s
			|| s/^("${ANY_PRINT_CHAR}*")$//s )
		{
			advance_token($parser);
			return('DQSTRING', $1);
		}
		#matching single quoted strings
		if( s/^('${ANY_PRINT_CHAR}*')(\s)/$2/s
			|| s/^('${ANY_PRINT_CHAR}*')//s )
		{
			advance_token($parser);
			return('SQSTRING', $1);
		}
		#matching text field
		if( $parser->YYData->{VARS}{token_pos} == 0 )
		{
			if( s/^;(${ANY_PRINT_CHAR}*)$//s )
			{
				my $eotf = 0;
				my $tfield;	#all textfield
				my $tf_line_begin =
					$parser->YYData->{VARS}{lines};
				$tfield = $1 . "\n";
				while( 1 )
				{
					my $line = <STDIN>;
					if( defined $line )
					{
						chomp $line;
						$line=~s/\t/    /g;
						$parser->YYData->{VARS}{current_line} = 
							$line;
						$parser->YYData->{VARS}{lines}++;
						if( $line =~
							s/^;//s )
						{
							if( defined $line )
							{
							$parser->YYData->{INPUT}
								= $line;
							$parser->YYData->{VARS}{token_pos} = 1;
							}
							last;
						} else {
							$tfield .= $line;
						}
					} else {
						undef $parser->YYData->{INPUT};
						last;
					}
				}
				if( !defined $parser->YYData->{INPUT} )
				{
					$parser->YYData->{ERRMSG} = <<END_M;
ERROR encountered while in text field, which started in line $tf_line_begin.
Possible runaway of closing ';', or unexpected end of file.
END_M
					$parser->YYError();
				}
				chomp $tfield;
				return('TEXT_FIELD', $tfield);
			}
		}
		#matching TAG's
		if( s/^(_${NON_BLANK_CHAR}+)//si )
		{
			advance_token($parser);
			return('TAG', $1);
		}
		#matching DATA_ field
		if( s/^(data_)(${NON_BLANK_CHAR}+)//si )
		{
			advance_token($parser);
			return('DATA_', $2);
		}
		#matching tokenized comments
		if( $parser->YYData->{VARS}{token_pos} > 0
			&& s/^($COMMENT)//s )
		{
			advance_token($parser);
			return('TOKENIZED_COMMENT', $1);
		}
		#matching comments
		if( s/^($COMMENT)//s )
		{
			advance_token($parser);
			return('COMMENT', $1);
		}
		#matching unquoted strings
		if( $parser->YYData->{VARS}{token_pos} == 0 )
		{
			if( s/^(?:
			#UQ string in first pos. of line
				( ( $NON_BLANK_CHAR+ ) )
			)//sx)
			{
				advance_token($parser);
				return('UQSTRING', $1);
			}
		} else {
			if( s/^(?:
			#UQ string in line
				( ($NON_BLANK_CHAR|;)
				$NON_BLANK_CHAR* )
			)//sx )
			{
				advance_token($parser);
				return('UQSTRING', $1);
			}
		}
		#matching white space characters
		if( s/^(\s+)//s )
		{
			advance_token($parser);
			return('WSPACE', $1);
		}
		#matching any still unmatched symbol:
		if( s/^(.)//m )
		{
			advance_token($parser);
			return($1,$1);
		}
	}
}

sub advance_token
{
	my $parser = shift;
	$parser->YYData->{VARS}{token_prev_pos} =
		$parser->YYData->{VARS}{token_pos};
	$parser->YYData->{VARS}{token_pos} += length($1);
}

sub Run
{
	my($self) = shift;
	if( $debug >= 2)
	{
		$self->YYParse( yylex => \&_Lexer,
				yyerror => \&_Error,
				yydebug => 0x05 );
	} else {
		$self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
	}
	if( $self->YYNberr() == 0 )
	{
		print "File syntax is CORRECT!\n";
	} else {
		print "Syntax check failed.\n";
	}

}

my($prog) = new parse;
$prog->Run;

__END__
CIF structure is stored in parser's object YYData VARS hash in this way:
$parser->YYData->{VARS}{[CIF_ARRAY]}

Here CIF_ARRAY is array of elements:
        kind
        [type]
        [name]
        value
        [precision]
*NOTE: square brackets ('[' and ']') denotes optional element.

As far as now, 'kind' is one of:
        DATA_
        SAVE_
        LOOP_
        TAG             - for any tag
        LOOPCOL         - for loop column

'type' is type of value stored:
        FLOAT
        INT
        SQSTRING
        DQSTRING
        UQSTRING
        TEXTFIELD

'name' is TAG's name.

'value' is value for TAG, whose name is 'name'.
It could be a list of values, in case of loop.

'precision' - optional component, which defines precision of numerical
values. It could be a single value, or an array of values - array of the
same size, as array for 'value' field.

All this array is recursive - in a block could reside several sections,
each with different values.

Everything goes to array 'value' in case of recursion.
Example with DATA_ section having a loop_:
$parser->YYDATA->{VARS}{myCIF} =
[
        {
#DATA_compound1
                kind = DATA_,
                name= 'compound1'
                value =
                [
                        {
#_chemical_formula_sum 'C2 H2 Ca O4'
                                kind = 'TAG'
                                name = '_chemical_formula_sum'
                                value = 'C2 H2 Ca O4'
                                type = 'SQSTRING'
                        },
                        {
#loop_
#_atom_site_label,
#_atom_site_fract_x
#Ca1 0.0098(2)
#Ca2 0.0093(2)
                                kind = 'LOOP_'
                                value =
                                [
                                        {
                                                kind = 'LOOPCOL'
                                                name = 
'_atom_site_label'
                                                value =
                                                [
                                                        'Ca1',
                                                        'Ca2'
                                                ]
                                        },
                                        {
                                                kind = 'LOOPCOL'
                                                name = 
'_atom_site_fract_x'
                                                value =
                                                [
                                                        0.0098,
                                                        0.0093
                                                ]
                                                precision =
                                                [
                                                        0.00002,
                                                        0.00002
                                                ]
                                        }
                                ]
                        }
                ]
        }
]


