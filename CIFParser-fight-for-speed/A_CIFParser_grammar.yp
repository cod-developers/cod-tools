# --*-Perl-*----------------------------------------------------
#$Author: saulius $
#$Date: 2008-01-02 17:13:24 +0200 (Wed, 02 Jan 2008) $
#$Revision: 325 $
#$URL: svn+ssh://pitonas.ibt.lt/home/xray/svn-repositories/cif-tools/trunk/CIFParser-fight-for-speed/CIFParser.yp $
# -------------------------------------------------------------- 
#
# parse.yp
#
# Parsed CIF file structure overview is described at the end of this file.
# --------------------------------------------------------------
# begin of header
# --------------------------------------------------------------
# copy directly to PERL module:
%{
use warnings;
use ShowStruct;
use FileHandle;

$CIFParser::version = '1.0';

my $SVNID = '$Id: CIFParser.yp 325 2008-01-02 15:13:24Z saulius $';

# 0 - no debug
# 1 - only YAPP output (type -> value)
# 2 - lex & yapp output
# 3 - generated array dump
$CIFParser::debug = 0;

sub merge_data_lists($$)
{
    return;

    my $list = $_[0];
    my $item = $_[1];

    for my $tag (@{$item->{tags}}) {

	push( @{$list->{tags}}, $tag );

	$list->{values}{$tag} =
	    $item->{values}{$tag};

	$list->{types}{$tag} =
	    $item->{types}{$tag};

	if( exists $item->{precisions}{$tag} ) {
	    $list->{precisions}{$tag} =
		$item->{precisions}{$tag};
	}

    }

    if( exists $item->{loops} ) {
	if( defined $list->{loops} ) {
	    $list->{loops} = [ @{$list->{loops}}, $item->{loops}[0] ];
	} else {
	    $list->{loops} = [ $item->{loops}[0] ];
	}
    }

    if( exists $item->{inloop} ) {
	my $loop_nr = $#{$list->{loops}};
	for my $key (keys %{$item->{inloop}} ) {
	    $list->{inloop}{$key} = $loop_nr;
	}
    }

    if( exists $item->{save_blocks} ) {
	if( defined $list->{save_blocks} ) {
	    $list->{save_blocks} =
		[ @{$list->{save_blocks}}, $item->{save_blocks}[0] ];
	} else {
	    $list->{save_blocks} = [ $item->{save_blocks}[0] ];
	}
    }

    return $list;
}

%}
# --------------------------------------------------------------

# --------------------------------------------------------------
# begin of body
# --------------------------------------------------------------

%%
cif_file
	:	#empty
	|	data_block_list
	|	data_item
	|	cif_value
;

data_block_list
	:	data_block_list data_block
	|	data_block
;

data_block
	:	data_block_head data_item_list
        |       data_block_head # empty data item list
;

data_item_list
	:	data_item_list data_item
	|	data_item
;

data_block_head
	:	DATA_
;

data_item
	:	save_item
	|	save_block
##	|	error
;

save_item_list
	:	save_item_list save_item
	|	save_item
;

save_item
	:	cif_entry
	|	loop
;

cif_entry
	:	TAG cif_value
	|	LOCAL TAG cif_value
;

loop
    :	LOOP_ loop_tags loop_values
;

loop_tags
	:	loop_tags TAG
	|	TAG
;

loop_values
	:	loop_values cif_value
	|	cif_value
;

save_block
	:	SAVE_HEAD save_item_list SAVE_FOOT
;

cif_value
	:	string
	|	number
	|	textfield
;

string
	:	SQSTRING
	|	DQSTRING
	|	UQSTRING
	|	TEXT_FIELD
;

number
	:	FLOAT
	|	INT
;

%%
# --------------------------------------------------------------
# begin of footer
# --------------------------------------------------------------

sub _Error
{
        $_[0]->YYData->{ERRCOUNT}++;
	exists $_[0]->YYData->{ERRMSG}
	and do {
		print STDERR $_[0]->YYData->{ERRMSG};
		delete $_[0]->YYData->{ERRMSG};
		return;
	};
	print STDERR "Analyzed symbols line containing bogus data (num. " . 
		$_[0]->YYData->{VARS}{lines} . " pos. " . 
		$_[0]->YYData->{VARS}{token_prev_pos} . ") was:\n" . 
		$_[0]->YYData->{VARS}{current_line} . "\n";
	print STDERR " " x $_[0]->YYData->{VARS}{token_prev_pos};
	print STDERR "^\n";
}

sub _Lexer
{
	my($parser) = shift;
	my $input = $parser->YYData->{INPUT};

	#trimming tokenized comments
	if( defined $input &&
		$input =~
			s/^(\s*#.*)$//s )
	{
		advance_token($parser);
	}

	if( !defined $input ||
		$input =~ m/^\s*$/ )
	{
		do
		{
			$input = <$CIFParser::FILEIN>;
			$parser->YYData->{VARS}{lines}++;
		} until ( !defined $input ||
			$input !~ m/^(\s*(#.*)?)$/s );
		if( defined $input )
		{
			chomp $input;
			$input=~s/\r$//g;
			$input=~s/\t/    /g;
			$parser->YYData->{VARS}{current_line} = 
				$input;
			$parser->YYData->{VARS}{token_pos} = 0;
		} else {
			$parser->YYData->{INPUT} = $input; return('',undef);
		}
	}

#scalars storing regular expressions, common to several matches
my $ORDINARY_CHAR	=	
	qr/[a-zA-Z0-9!%&\(\)\*\+,-\.\/\:<=>\?@\\\^`{\|}~]/is;
my $SPECIAL_CHAR	=	qr/["#\$'_\[\]]/is;
my $NON_BLANK_CHAR	=	qr/(?:$ORDINARY_CHAR|$SPECIAL_CHAR|;)/is;
my $TEXT_LEAD_CHAR	=	qr/(?:$ORDINARY_CHAR|$SPECIAL_CHAR|\s)/s;
my $ANY_PRINT_CHAR	=	qr/(?:$NON_BLANK_CHAR|\s)/is;
my $INTEGER		=	qr/[-+]?[0-9]+/s;
my $EXPONENT		=	qr/e[-+]?[0-9]+/is;
my $FLOAT11		=	qr/(?: $INTEGER $EXPONENT)/ix;
my $FLOAT21		=	qr/(?: [+-]? [0-9]* \. [0-9]+ $EXPONENT ?)/ix;
my $FLOAT31		=	qr/(?: $INTEGER \. $EXPONENT ?)/ix;
my $FLOAT		=	qr/(?: (?: $FLOAT11 | $FLOAT21 | $FLOAT31))/six;

	#matching white space characters
	if( $input =~ s/(\s*)//s )
	{
		advance_token($parser);
	}
		
	if($CIFParser::debug >= 2 && $CIFParser::debug < 3)
	{
		print ">>> '", $input, "'\n";
	}

	for ($input)
	{
		#matching floats:
                if( s/^(?: ($FLOAT (?:\([0-9]+\))?) (\s) )/$2/six
                        || s/^($FLOAT (?:\([0-9]+\))?)$//six )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('FLOAT', $1);
		}
		#matching integers:
                if( s/^($INTEGER (?:\([0-9]+\))?)(\s)/$2/sx
                        || s/^($INTEGER (?:\([0-9]+\))?)$//sx )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('INT', $1);
		}
		#matching double quoted strings
		if( s/^("${ANY_PRINT_CHAR}*?")(\s)/$2/s
			|| s/^("${ANY_PRINT_CHAR}*?")$//s )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('DQSTRING', $1);
		}
		#matching single quoted strings
		if( s/^('${ANY_PRINT_CHAR}*?')(\s)/$2/s
			|| s/^('${ANY_PRINT_CHAR}*?')$//s )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('SQSTRING', $1);
		}
		#matching text field
		if( $parser->YYData->{VARS}{token_pos} == 0 )
		{
			if( s/^;(${ANY_PRINT_CHAR}*)$//s )
			{
				my $eotf = 0;
				my $tfield;	#all textfield
				my $tf_line_begin =
					$parser->YYData->{VARS}{lines};
				$tfield = $1;
				while( 1 )
				{
					my $line = <$CIFParser::FILEIN>;
					if( defined $line )
					{
						chomp $line;
						$line=~s/\r$//g;
						$line=~s/\t/    /g;
						$parser->YYData->{VARS}{current_line} = 
							$line;
						$parser->YYData->{VARS}{lines}++;
						if( $line =~
							s/^;//s )
						{
							if( defined $line )
							{
							$input
								= $line;
							$parser->YYData->{VARS}{token_pos} = 1;
							}
							last;
						} else {
							$tfield .= "\n" . $line;
						}
					} else {
						undef $input;
						last;
					}
				}
				if( !defined $input )
				{
					$parser->YYData->{ERRMSG} = <<END_M;
ERROR encountered while in text field, which started in line $tf_line_begin.
Possible runaway of closing ';', or unexpected end of file.
END_M
					$parser->YYError();
				}
				$parser->YYData->{INPUT} = $input; return('TEXT_FIELD', $tfield);
			}
		}
		#matching [local] attribute
		if( s/^(\[local\])//si )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('LOCAL', $1);
		}
		#matching GLOBAL_ field
		if( s/^(global_.*)$//si )
		{
			advance_token($parser);
			$parser->YYData->{ERRMSG} = "GLOBAL_ symbol detected" .
				" in line " .
				$parser->YYData->{VARS}{lines} .
				", pos. " .
				$parser->YYData->{VARS}{token_prev_pos} . ":\n--\n" .
				$parser->YYData->{VARS}{current_line} . "\n--\n" .
				"It is not acceptable in this version!\n";
			$parser->YYError();
			$parser->YYData->{INPUT} = $input; return('GLOBAL_', $1);
		}
		#matching SAVE_ head
		if( s/^(save_${NON_BLANK_CHAR}+)//si )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('SAVE_HEAD', $1);
		}
		#matching SAVE_ foot
		if( s/^(save_)//si )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('SAVE_FOOT', $1);
		}
		#matching STOP_ field
		if( s/^(stop_.*)$//si )
		{
			advance_token($parser);
			$parser->YYData->{ERRMSG} = "STOP_ symbol detected" .
				" in line " .
				$parser->YYData->{VARS}{lines} .
				", pos. " .
				$parser->YYData->{VARS}{token_prev_pos} . ":\n--\n" .
				$parser->YYData->{VARS}{current_line} . "\n--\n" .
				"It is not acceptable in this version!\n";
			$parser->YYError();
			$parser->YYData->{INPUT} = $input; return('STOP_', $1);
		}
		#matching DATA_ field
		if( s/^(data_${NON_BLANK_CHAR}+)//si )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('DATA_', $1);
		}
		#matching LOOP_ begining
		if( s/^(loop_)//si )
		{
			advance_token($parser);
			$parser->YYData->{VARS}{loop_begin} =
					$parser->YYData->{VARS}{lines};
			$parser->YYData->{INPUT} = $input; return('LOOP_', $1);
		}
		#matching TAG's
		if( s/^(_${NON_BLANK_CHAR}+)//si )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('TAG', $1);
		}
		#matching unquoted strings
		if( $parser->YYData->{VARS}{token_pos} == 0 )
		{ #UQSTRING at first pos. of line
			if( s/^(?: ( ($ORDINARY_CHAR | \[ )
				($NON_BLANK_CHAR)*) )
				//sx)
			{
				advance_token($parser);
				$parser->YYData->{INPUT} = $input; return('UQSTRING', $1);
			}
		} else { #UQSTRING in line
			if( s/^(?: ( ($ORDINARY_CHAR | ; | \[ )
				($NON_BLANK_CHAR)*) )
				//sx )
			{
				advance_token($parser);
				$parser->YYData->{INPUT} = $input; return('UQSTRING', $1);
			}
		}
		#matching any still unmatched symbol:
		if( s/^(.)//m )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return($1,$1);
		}
	}
}

sub advance_token
{
	my $parser = shift;
	$parser->YYData->{VARS}{token_prev_pos} =
		$parser->YYData->{VARS}{token_pos};
	$parser->YYData->{VARS}{token_pos} += length($1);
}

sub Run
{
	my($self) = shift;
	my($filename) = shift;

	$filename = "-" unless $filename;
	$CIFParser::FILEIN = new FileHandle $filename;
	$| = 1;
	if( $CIFParser::debug >= 2 && $CIFParser::debug < 3)
	{
		$self->YYParse( yylex => \&_Lexer,
				yyerror => \&_Error,
				yydebug => 0x05 );
	} else {
		$self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
	}
	if( $self->YYNberr() == 0 )
	{
		if( $CIFParser::debug >= 1 && $CIFParser::debug < 3)
		{
			print "File syntax is CORRECT!\n";
		}
		undef $CIFParser::FILEIN;
	} else {
		if( $CIFParser::debug >= 1 && $CIFParser::debug < 3)
		{
			print "Syntax check failed.\n";
		}
		undef $CIFParser::FILEIN;
	}
	return $self->{USER}->{CIFfile};
}

return 1;
