# --*-Perl-*----------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
# -------------------------------------------------------------- 
#
# parse.yp
#
# Parsed CIF file structure overview is described at the end of this file.
# --------------------------------------------------------------
# begin of header
# --------------------------------------------------------------
# copy directly to PERL module:
%{
use warnings;
use ShowStruct;
use FileHandle;

$CIFParser::version = '1.0';

my $SVNID = '$Id$';

# 0 - no debug
# 1 - only YAPP output (type -> value)
# 2 - lex & yapp output
# 3 - generated array dump
$CIFParser::debug = 0;

sub merge_data_lists($$)
{
    my $list = $_[0];
    my $item = $_[1];

    for my $tag (@{$item->{tags}}) {

	push( @{$list->{tags}}, $tag );

	$list->{values}{$tag} =
	    $item->{values}{$tag};

	$list->{types}{$tag} =
	    $item->{types}{$tag};

	if( exists $item->{precisions}{$tag} ) {
	    $list->{precisions}{$tag} =
		$item->{precisions}{$tag};
	}

    }

    if( exists $item->{loops} ) {
	if( defined $list->{loops} ) {
	    $list->{loops} = [ @{$list->{loops}}, $item->{loops}[0] ];
	} else {
	    $list->{loops} = [ $item->{loops}[0] ];
	}
    }

    if( exists $item->{inloop} ) {
	my $loop_nr = $#{$list->{loops}};
	for my $key (keys %{$item->{inloop}} ) {
	    $list->{inloop}{$key} = $loop_nr;
	}
    }

    if( exists $item->{save_blocks} ) {
	if( defined $list->{save_blocks} ) {
	    $list->{save_blocks} =
		[ @{$list->{save_blocks}}, $item->{save_blocks}[0] ];
	} else {
	    $list->{save_blocks} = [ $item->{save_blocks}[0] ];
	}
    }

    return $list;
}

%}
# --------------------------------------------------------------

# --------------------------------------------------------------
# begin of body
# --------------------------------------------------------------

%%
cif_file
	:	#empty
                {
			$_[0]->{USER}->{CIFfile} =
                            [ { name => undef, values => {}, tags => [] } ];
		}
	|	data_block_list
		{
			if($CIFParser::debug >= 3)
			{
				showRef($_[1]);
			}
			$_[0]->{USER}->{CIFfile} = $_[1];
		}
	|	data_item
		{
			$_[0]->YYData->{ERRMSG} = "No data block heading (i.e." .
			" data_somecif) found in file!\n";
			$_[0]->{USER}->{CIFfile} = [ { name => "", values => {}, tags => [] } ];
			$_[0]->YYError();
		}
	|	cif_value                     {
			$_[0]->{USER}->{CIFfile} =
                            [ { name => undef, values => {}, tags => [] } ];
		}
           {
			$_[0]->{USER}->{CIFfile} =
                            [ { name => undef, values => {}, tags => [] } ];
		}

		{
			$_[0]->YYData->{ERRMSG} = "No data block heading (i.e." .
			" data_somecif) found in file!\n";
			$_[0]->{USER}->{CIFfile} = [ { name => "", values => {}, tags => [] } ];
			$_[0]->YYError();
		}
;

data_block_list
	:	data_block_list data_block
		{
			my $val = $_[1];
			push( @{$val}, $_[2] );
			return $val;
		}
	|	data_block
		{
			return [ $_[1] ];
		}
;

data_block
	:	data_block_head data_item_list
		{
			## my $val = { name => $_[1] };
			## $val->{content} = $_[2]->{value};
			## $val->{kind} = $_[2]->{kind};
			## $val->{type} = "DATA";
			my $name = $_[1];
		        my $val = $_[2];
			$val->{name} = $name;
			return $val;
		}
        |       data_block_head # empty data item list
                {
			return
                            { name => $_[1], values => {}, tags => [] };
		}
;

data_item_list
	:	data_item_list data_item
		{
		        ## my $val = $_[1];
			## push(@{$val->{value}}, $_[2]);
			## return $val;
                        my $list = $_[1];
                        my $item = $_[2];
                        $list = merge_data_lists( $list, $item );
			return $list;
		}
	|	data_item
		{
			## my $val = { kind => 'DATA' };
			## push(@{$val->{value}}, $_[1]);
		        my $val = $_[1];
			return $val;
		}
;

data_block_head
	:	DATA_
		{
			$_[1] =~ m/^(data_)(.*)/si;
			return $2;
		}
;

data_item
	:	save_item
		{
			return $_[1];
		}
	|	save_block
		{
			return $_[1];
		}
##	|	error
;

save_item_list
	:	save_item_list save_item
		{
			## my $val = $_[1];
			## push( @{$val->{value}}, $_[2] );
			## return $val;
		        my $list = $_[1];
			my $item = $_[2];
                        $list = merge_data_lists( $list, $item );
			return $list;
		}
	|	save_item
		{
			my $val = $_[1];
			return $val;
		}
;

save_item
	:	cif_entry
		{
		    # Here we convert to new structure:
			## return $_[1];
		        my $entry = $_[1];
			my $item = {
			    values => {
				$entry->{name} => [ $entry->{value} ]
			    },
			    types => {
				$entry->{name} => [ $entry->{type} ]
			    },
			    tags => [ $entry->{name} ]
			};
			if( exists $entry->{precision} ) {
			    $item->{precisions} = {
				$entry->{name} => [ $entry->{precision} ]
			    }
			}
			return $item;
		}
	|	loop
		{
		        return $_[1];
		}
;

cif_entry
	:	TAG cif_value
		{
			my $val;
			if(defined $_[2]->{precision})
			{
				$val = { name => $_[1],
					kind => 'TAG',
					value => $_[2]->{value},
					type => $_[2]->{type},
					precision => $_[2]->{precision}
				};
			} else {
				$val = { name => $_[1],
					kind => 'TAG',
					value => $_[2]->{value},
					type => $_[2]->{type}
				};
			}
			if($CIFParser::debug >= 1 && $CIFParser::debug <= 2)
			{
				showRef($val);
			}
			return $val;
		}
	|	LOCAL TAG cif_value
		{
			my $val;
			if(defined $_[3]->{precision})
			{
				$val = { name => $_[2],
					kind => 'LOCAL',
					value => $_[3]->{value},
					type => $_[3]->{type},
					precision => $_[3]->{precision}
				};
			} else {
				$val = { name => $_[2],
					kind => 'LOCAL',
					value => $_[3]->{value},
					type => $_[3]->{type}
				};
			}
			if($CIFParser::debug >= 1 && $CIFParser::debug <= 2)
			{
				showRef($val);
			}
			return $val;
		}
;

loop
    :	LOOP_ loop_tags loop_values
		{
			## my $val = { kind => 'loop' };
			## $val->{name} = $_[2]->{name};
			## $val->{value} = $_[3]->{value};
			## $val->{type} = $_[3]->{type};
			## if( defined $_[3]->{precision} )
			## {
			## 	$val->{precision} = $_[3]->{precision};
			## }
			## if( (scalar @{$val->{value}}) %
			## 		(scalar @{$val->{name}}) == 0 )
			## {
			## 	return $val;
			## } else {
			## 	$_[0]->YYData->{ERRMSG} =
			## 	    "Wrong number of elements in"
			## 	    . " loop block starting in line "
			## 	    . $_[0]->YYData->{VARS}{loop_begin}
			## 	    . "!\n";
			## 	$_[0]->YYError();
			## }

		        my $val = {};
		        my $tags = $_[2];
			my @values = @{$_[3]};

			## push( @{$val->{loops}}, $tags );
                        $val->{loops} = [ [ @{$tags} ] ];
                        $val->{tags} = $tags;

		      VALUES:
			while( int( @values ) > 0 ) {
			    for my $tag (@{$tags}) {
				my $value = shift( @values );
				if( defined $value ) {
				    push( @{$val->{values}{$tag}},
					  $value->{value} );
				    push( @{$val->{types}{$tag}},
					  $value->{type} );
				    if( exists $value->{precision} ) {
					push( @{$val->{precisionss}{$tag}},
					      $value->{precision} );
				    }
				    $val->{inloop}{$tag} = 0;
				} else {
				    $_[0]->YYData->{ERRMSG} =
					"Wrong number of elements in the"
					. " loop block starting in line "
					. $_[0]->YYData->{VARS}{loop_begin}
				    . "!\n";
				    $_[0]->YYError();
				    last VALUES;
				}
			    }
			}
                        return $val;
		}
;

loop_tags
	:	loop_tags TAG
		{
			my $val = $_[1];
			push( @{$val}, $_[2] );
			return $val;
		}
	|	TAG
		{
			my $val = [ $_[1] ];
			return $val;
		}
;

loop_values
	:	loop_values cif_value
		{
			my $arr = $_[1];
			my $val = $_[2];
			## push( @{$val->{value}}, $_[2]->{value} );
			## push( @{$val->{type}}, $_[2]->{type} );
			## if( defined $_[2]->{precision} )
			## {
			## 	push( @{$val->{precision}}, $_[2]->{precision} );
			## }
			return [ @{$arr}, $val ];
		}
	|	cif_value
		{
			my $val = $_[1];
			## { type => [ $_[1]->{type} ] };
			## push( @{$val->{value}}, $_[1]->{value} );
			## if( defined $_[1]->{precision} )
			## {
			## 	push( @{$val->{precision}}, $_[1]->{precision} );
			## }
			return [ $val ];
		}
;

save_block
	:	SAVE_HEAD save_item_list SAVE_FOOT
		{
			## my $value = $_[2]->{value};
			## $_[1] =~ m/^(save_)(.*)$/si;
			## my $val = { kind => 'SAVE',
			## 		name => $2 };
			## $val->{type} = "SAVE";
			## $val->{content} = $value;
			## return $val;
                        my $val = {
			    save_blocks => [
				{
				    name => $_[1],
				    %{$_[2]}
				}
			    ]
                        };
                        return $val;
		}
;

cif_value
	:	string
		{	print $_[1]->{type} . "\t->\t"
				. $_[1]->{value} . "\n" if( $CIFParser::debug >= 1 && $CIFParser::debug <= 2) ;
			$_[1];
		}
	|	number
		{	print $_[1]->{type} . "\t\t->\t"
				. $_[1]->{value} . " -- "
				. $_[1]->{precision}
				. "\n" if( $CIFParser::debug >= 1 && $CIFParser::debug <= 2);
			$_[1];
		}
	|	textfield
		{	print "TFIELD\t\t->\t" .
				$_[1]->{value} . "\n"
				if( $CIFParser::debug >= 1 && $CIFParser::debug <= 2);
			$_[1];
		}
;

string
	:	SQSTRING
		{
			$_[1] =~ m/^(')(.*)(')$/si;
			return { value => $2,
				type => 'SQSTRING'};
		}
	|	DQSTRING
		{
			$_[1] =~ m/^(")(.*)(")$/si;
			return { value => $2,
				type => 'DQSTRING'};
		}
	|	UQSTRING	{ { value => $_[1],
			type => 'UQSTRING'} }
	|	TEXT_FIELD	{ { value => $_[1],
			type => 'TEXTFIELD' };
		}
;

number
	:	FLOAT
		{
			if( $_[1] =~ m/^(.*)( \( ([0-9]+) \) )$/six )
			{
				my $value	= $1;
				my $precision	= $3;
				#parsing float value:
				# - $1 - part before decimal dot
				# - $2 - decimal dot
				# - $3 - mantissa (part after d-dot)
				# - $4 - exponent
				$value =~ m/
						([-+]?[0-9]*)?
						(\.)?
						([0-9]+)?
						(?:e([+-]?[0-9]+))?
					/six;
				if( defined $2 )
				{
					if( defined $4 )
					{
						if(defined($3))
						{
							$precision /=
							10**(length($3));
						}
						$precision *= 10**($4);
					} else {
						if(defined($3))
						{
							$precision /=
							10**(length($3));
						}
					}
				} else {
					$precision *= 10**($4);
				}
				{	type => 'FLOAT',
					value => $_[1],
					precision => $precision
				}
			} else {
				{	type => 'FLOAT',
					value => $_[1],
					precision => 'undef'
				}
			}
		}
	|	INT
		{
			if( $_[1] =~ m/^(.*)( \( ([0-9]+) \) )$/sx)
			{
				{	type => 'INT',
					value => $_[1],
					precision => $3
				}
			} else {
				{	type => 'INT',
					value => $_[1],
					precision => 'undef'
				}
			}
		}
;

%%
# --------------------------------------------------------------
# begin of footer
# --------------------------------------------------------------

sub _Error
{
        $_[0]->YYData->{ERRCOUNT}++;
	exists $_[0]->YYData->{ERRMSG}
	and do {
		print STDERR $_[0]->YYData->{ERRMSG};
		delete $_[0]->YYData->{ERRMSG};
		return;
	};
	print STDERR "Analyzed symbols line containing bogus data (num. " . 
		$_[0]->YYData->{VARS}{lines} . " pos. " . 
		$_[0]->YYData->{VARS}{token_prev_pos} . ") was:\n" . 
		$_[0]->YYData->{VARS}{current_line} . "\n";
	print STDERR " " x $_[0]->YYData->{VARS}{token_prev_pos};
	print STDERR "^\n";
}

sub _Lexer
{
	my($parser) = shift;
	my $input = $parser->YYData->{INPUT};

	#trimming tokenized comments
	if( defined $input &&
		$input =~
			s/^(\s*#.*)$//s )
	{
		advance_token($parser);
	}

	if( !defined $input ||
		$input =~ m/^\s*$/ )
	{
		do
		{
			$input = <$CIFParser::FILEIN>;
			$parser->YYData->{VARS}{lines}++;
		} until ( !defined $input ||
			$input !~ m/^(\s*(#.*)?)$/s );
		if( defined $input )
		{
			chomp $input;
			$input=~s/\r$//g;
			$input=~s/\t/    /g;
			$parser->YYData->{VARS}{current_line} = 
				$input;
			$parser->YYData->{VARS}{token_pos} = 0;
		} else {
			$parser->YYData->{INPUT} = $input; return('',undef);
		}
	}

#scalars storing regular expressions, common to several matches
my $ORDINARY_CHAR	=	
	qr/[a-zA-Z0-9!%&\(\)\*\+,-\.\/\:<=>\?@\\\^`{\|}~]/is;
my $SPECIAL_CHAR	=	qr/["#\$'_\[\]]/is;
my $NON_BLANK_CHAR	=	qr/(?:$ORDINARY_CHAR|$SPECIAL_CHAR|;)/is;
my $TEXT_LEAD_CHAR	=	qr/(?:$ORDINARY_CHAR|$SPECIAL_CHAR|\s)/s;
my $ANY_PRINT_CHAR	=	qr/(?:$NON_BLANK_CHAR|\s)/is;
my $INTEGER		=	qr/[-+]?[0-9]+/s;
my $EXPONENT		=	qr/e[-+]?[0-9]+/is;
my $FLOAT11		=	qr/(?: $INTEGER $EXPONENT)/ix;
my $FLOAT21		=	qr/(?: [+-]? [0-9]* \. [0-9]+ $EXPONENT ?)/ix;
my $FLOAT31		=	qr/(?: $INTEGER \. $EXPONENT ?)/ix;
my $FLOAT		=	qr/(?: (?: $FLOAT11 | $FLOAT21 | $FLOAT31))/six;

	#matching white space characters
	if( $input =~ s/(\s*)//s )
	{
		advance_token($parser);
	}
		
	if($CIFParser::debug >= 2 && $CIFParser::debug < 3)
	{
		print ">>> '", $input, "'\n";
	}

	for ($input)
	{
		#matching floats:
                if( s/^(?: ($FLOAT (?:\([0-9]+\))?) (\s) )/$2/six
                        || s/^($FLOAT (?:\([0-9]+\))?)$//six )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('FLOAT', $1);
		}
		#matching integers:
                if( s/^($INTEGER (?:\([0-9]+\))?)(\s)/$2/sx
                        || s/^($INTEGER (?:\([0-9]+\))?)$//sx )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('INT', $1);
		}
		#matching double quoted strings
		if( s/^("${ANY_PRINT_CHAR}*?")(\s)/$2/s
			|| s/^("${ANY_PRINT_CHAR}*?")$//s )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('DQSTRING', $1);
		}
		#matching single quoted strings
		if( s/^('${ANY_PRINT_CHAR}*?')(\s)/$2/s
			|| s/^('${ANY_PRINT_CHAR}*?')$//s )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('SQSTRING', $1);
		}
		#matching text field
		if( $parser->YYData->{VARS}{token_pos} == 0 )
		{
			if( s/^;(${ANY_PRINT_CHAR}*)$//s )
			{
				my $eotf = 0;
				my $tfield;	#all textfield
				my $tf_line_begin =
					$parser->YYData->{VARS}{lines};
				$tfield = $1;
				while( 1 )
				{
					my $line = <$CIFParser::FILEIN>;
					if( defined $line )
					{
						chomp $line;
						$line=~s/\r$//g;
						$line=~s/\t/    /g;
						$parser->YYData->{VARS}{current_line} = 
							$line;
						$parser->YYData->{VARS}{lines}++;
						if( $line =~
							s/^;//s )
						{
							if( defined $line )
							{
							$input
								= $line;
							$parser->YYData->{VARS}{token_pos} = 1;
							}
							last;
						} else {
							$tfield .= "\n" . $line;
						}
					} else {
						undef $input;
						last;
					}
				}
				if( !defined $input )
				{
					$parser->YYData->{ERRMSG} = <<END_M;
ERROR encountered while in text field, which started in line $tf_line_begin.
Possible runaway of closing ';', or unexpected end of file.
END_M
					$parser->YYError();
				}
				$parser->YYData->{INPUT} = $input; return('TEXT_FIELD', $tfield);
			}
		}
		#matching [local] attribute
		if( s/^(\[local\])//si )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('LOCAL', $1);
		}
		#matching GLOBAL_ field
		if( s/^(global_.*)$//si )
		{
			advance_token($parser);
			$parser->YYData->{ERRMSG} = "GLOBAL_ symbol detected" .
				" in line " .
				$parser->YYData->{VARS}{lines} .
				", pos. " .
				$parser->YYData->{VARS}{token_prev_pos} . ":\n--\n" .
				$parser->YYData->{VARS}{current_line} . "\n--\n" .
				"It is not acceptable in this version!\n";
			$parser->YYError();
			$parser->YYData->{INPUT} = $input; return('GLOBAL_', $1);
		}
		#matching SAVE_ head
		if( s/^(save_${NON_BLANK_CHAR}+)//si )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('SAVE_HEAD', $1);
		}
		#matching SAVE_ foot
		if( s/^(save_)//si )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('SAVE_FOOT', $1);
		}
		#matching STOP_ field
		if( s/^(stop_.*)$//si )
		{
			advance_token($parser);
			$parser->YYData->{ERRMSG} = "STOP_ symbol detected" .
				" in line " .
				$parser->YYData->{VARS}{lines} .
				", pos. " .
				$parser->YYData->{VARS}{token_prev_pos} . ":\n--\n" .
				$parser->YYData->{VARS}{current_line} . "\n--\n" .
				"It is not acceptable in this version!\n";
			$parser->YYError();
			$parser->YYData->{INPUT} = $input; return('STOP_', $1);
		}
		#matching DATA_ field
		if( s/^(data_${NON_BLANK_CHAR}+)//si )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('DATA_', $1);
		}
		#matching LOOP_ begining
		if( s/^(loop_)//si )
		{
			advance_token($parser);
			$parser->YYData->{VARS}{loop_begin} =
					$parser->YYData->{VARS}{lines};
			$parser->YYData->{INPUT} = $input; return('LOOP_', $1);
		}
		#matching TAG's
		if( s/^(_${NON_BLANK_CHAR}+)//si )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return('TAG', $1);
		}
		#matching unquoted strings
		if( $parser->YYData->{VARS}{token_pos} == 0 )
		{ #UQSTRING at first pos. of line
			if( s/^(?: ( ($ORDINARY_CHAR | \[ )
				($NON_BLANK_CHAR)*) )
				//sx)
			{
				advance_token($parser);
				$parser->YYData->{INPUT} = $input; return('UQSTRING', $1);
			}
		} else { #UQSTRING in line
			if( s/^(?: ( ($ORDINARY_CHAR | ; | \[ )
				($NON_BLANK_CHAR)*) )
				//sx )
			{
				advance_token($parser);
				$parser->YYData->{INPUT} = $input; return('UQSTRING', $1);
			}
		}
		#matching any still unmatched symbol:
		if( s/^(.)//m )
		{
			advance_token($parser);
			$parser->YYData->{INPUT} = $input; return($1,$1);
		}
	}
}

sub advance_token
{
	my $parser = shift;
	$parser->YYData->{VARS}{token_prev_pos} =
		$parser->YYData->{VARS}{token_pos};
	$parser->YYData->{VARS}{token_pos} += length($1);
}

sub Run
{
	my($self) = shift;
	my($filename) = shift;

	$filename = "-" unless $filename;
	$CIFParser::FILEIN = new FileHandle $filename;
	$| = 1;
	if( $CIFParser::debug >= 2 && $CIFParser::debug < 3)
	{
		$self->YYParse( yylex => \&_Lexer,
				yyerror => \&_Error,
				yydebug => 0x05 );
	} else {
		$self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
	}
	if( $self->YYNberr() == 0 )
	{
		if( $CIFParser::debug >= 1 && $CIFParser::debug < 3)
		{
			print "File syntax is CORRECT!\n";
		}
		undef $CIFParser::FILEIN;
	} else {
		if( $CIFParser::debug >= 1 && $CIFParser::debug < 3)
		{
			print "Syntax check failed.\n";
		}
		undef $CIFParser::FILEIN;
	}
	return $self->{USER}->{CIFfile};
}

return 1;
