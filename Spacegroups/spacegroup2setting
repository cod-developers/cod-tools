#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl5 -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
# Convert information about different spacegroups in the
# Spacegroups.pm %Spacegroups::space_groups has into the hash
# containing information about each setting separately.
#**

use strict;
use lib ".";
use Spacegroups;
use SymopParse;

for my $key (sort keys %Spacegroups::space_groups) {
    my $sg = $Spacegroups::space_groups{$key};

    if( exists $sg->{settings} ) {
	my ($a, $b, $c) = (0, 0, 0);
	for my $setting (@{$sg->{settings}}) {
	    my $symops = select_symops( $sg, $setting, \$a, \$b, \$c );
	    print_shifted_settings( $setting, $key, $sg, $symops );
	}
    } elsif( exists $sg->{positions} ) {
	print_shifted_settings( $key, $key, $sg, $sg->{positions} );
    }
}

sub symop_add_shift
{
    my ($symop, $shift) = @_;

    return [
	[ $symop->[0][0], $symop->[0][1], $symop->[0][2],
	  $symop->[0][3] + $shift->[0] ],

	[ $symop->[1][0], $symop->[1][1], $symop->[1][2],
	  $symop->[1][3] + $shift->[1] ],

	[ $symop->[2][0], $symop->[2][1], $symop->[2][2],
	  $symop->[2][3] + $shift->[2] ],
    ];
}

sub symop_mul_vector
{
    my ($symop, $vect) = @_;

    return [
	$symop->[0][0] * $vect->[0] +
	$symop->[0][1] * $vect->[1] +
	$symop->[0][2] * $vect->[2],

	$symop->[1][0] * $vect->[0] +
	$symop->[1][1] * $vect->[1] +
	$symop->[1][2] * $vect->[2],

	$symop->[2][0] * $vect->[0] +
	$symop->[2][1] * $vect->[1] +
	$symop->[2][2] * $vect->[2],
    ];
}

sub symop_shift_origin
{
    my ($symop, $origin_shift) = @_;

    my @back_shift = map {-$_} @{$origin_shift};
    my $new_tr = symop_mul_vector( $symop, \@back_shift );

    return SymopParse::symop_translation_modulo_1( [
	[ $symop->[0][0], $symop->[0][1], $symop->[0][2],
	  $symop->[0][3] + $new_tr->[0] + $origin_shift->[0] ],

	[ $symop->[1][0], $symop->[1][1], $symop->[1][2],
	  $symop->[1][3] + $new_tr->[1] + $origin_shift->[1] ],

	[ $symop->[2][0], $symop->[2][1], $symop->[2][2],
	  $symop->[2][3] + $new_tr->[2] + $origin_shift->[2] ],
      ]
    );
}

sub print_shifted_settings
{
    my ($setting, $sg_name, $sg, $symops ) = @_;

    if( exists $sg->{shiftvec} ) {
	my @shift = @{$sg->{shiftvec}};
	my @symops = symop_strings($symops);

	&print_setting( $setting, $sg_name, $sg, $symops, 1 );

	my @symop_matrices = map {SymopParse::symop_from_string($_)} @symops;
	my @shifted_matrices = map {symop_shift_origin($_,\@shift)} @symop_matrices;
	my @shifted_strings = map {SymopParse::string_from_symop( $_ )}
	                      @shifted_matrices;

	print_setting( $setting, $sg_name, $sg, \@shifted_strings, 2 );
    } else {
	&print_setting
    }
}

sub print_setting
{
    my ($setting, $sg_name, $sg, $symops, $origin ) = @_;

    my @ncsymop_strings = ref $symops->[0] eq "ARRAY" ?
	symop_strings($symops) : # non-centering symops
	@{$symops};

    my @symop_strings = @ncsymop_strings;

    my $lattice_type = uc(substr( $sg_name, 0, 1 ));

    if( $lattice_type !~ /P/ ) {
	my @centering_symops = ();
	my $centering_shifts =
	    $Spacegroups::centering_translations{$lattice_type};
	foreach my $symop_str (@symop_strings) {
	    my $symop = SymopParse::symop_from_string( $symop_str );
	    for my $shift (@{$centering_shifts}) {
		my $new_symop = symop_add_shift( $symop, $shift );
		push( @centering_symops, SymopParse::string_from_symop(
			  SymopParse::symop_translation_modulo_1( $new_symop )
		      )
		    );
	    }
	}
	@symop_strings = ( @ncsymop_strings, @centering_symops );
    }

    ## print "'", $setting, "'";
    ## print "'", join(";", sort @symop_strings), "',";
    ## print " => {\n";
    print "{\n";
    print "    spacegroup_name => ", "'".ucfirst($sg_name)."',", "\n";
    print "    setting_name    => ", "'".ucfirst($setting)."',", "\n";
    print "    schoenflies     => ", "'".ucfirst($sg->{schoenflies})."',", "\n";
    print "    new_symbol      => ", "'".ucfirst($sg->{new_symbol})."',", "\n"
	if defined $sg->{new_symbol};
    print "    thirtyfive      => ", "'".ucfirst($sg->{thirtyfive})."',", "\n"
	if defined $sg->{thirtyfive};
    print "    full   => ", "'".$sg->{full}, "',\n"
	if defined $sg->{full};
    print "    number => ", $sg->{number}, ",\n";
    print "    origin => ", $origin, ",\n"
	if defined $origin;
    print "    nsymop => ", int(@symop_strings), ",\n";
    print "    symops => [\n";
    for my $symop (@symop_strings) {
	print "        \"", $symop, "\",\n";
    }
    print "    nncsym => ", int(@ncsymop_strings), ",\n";
    print "    ncsyms => [\n";
    for my $symop (@ncsymop_strings) {
	print "        \"", $symop, "\",\n";
    }
    print "    ]\n";
    print "},\n";
}

sub symop_strings
{
    my ($symops) = @_;

    my @symop_strings;

    for my $symop (@{$symops}) {
	my $n = 0;
	my $symop_string = "";
	for my $component (@{$symop}) {
	    $component =~ s/\$//g;
	    $component = lc($component);
	    $symop_string .= sprintf "%s", $component;
	    if( $n < 2 ) {
		$symop_string .= ",";
	    }
	    $n++;
	}
	push( @symop_strings, $symop_string );
    }

    return @symop_strings;
}

sub unique_axis
{
    my ($setting_name) = @_;

    my @setting_name = split( " ", $setting_name );

    my $n = 0;
    shift(@setting_name);
    for my $component (@setting_name) {
	if( $component ne "1" ) {
	    last;
	} else {
	    $n++;
	}
    }

    return $n;
}

sub select_symops
{
    my ($sg, $setting, $a, $b, $c ) = @_;

    my $symops;
    my $n = unique_axis( $setting );
    for ($n) {
	if(/^0$/) {
	    $symops = $sg->{a_unique};
	    if( !defined $symops ) {
		$$a ++;
		my $key = "a_unique_$$a";
		$symops = $sg->{$key};
	    }
	}
	if(/^1$/) {
	    $symops = $sg->{b_unique};
	    if( !defined $symops ) {
		$$b ++;
		my $key = "b_unique_$$b";
		$symops = $sg->{$key};
	    }
	}
	if(/^2$/) {
	    $symops = $sg->{c_unique};
	    if( !defined $symops ) {
		$$c ++;
		my $key = "c_unique_$$c";
		$symops = $sg->{$key};
	    }
	}
    }

    if( !defined $symops ) {
	$symops = $sg->{positions};
    }

    print ">>> $n, $$a, $$b, $$c \n" and
    die( "Could not find appropriate symops for setting '$setting'" )
	unless defined $symops;

    return $symops;
}
## 
## sub setting_index
## {
##     my ($setting_list, $requested_setting) = @_;
## 
##     my $unique_axis = unique_axis( $requested_setting );
##     my $n = 0;
##     my $found_setting;
## 
##     for my $current_setting (@{$setting_list}) {
## 	if( unique_axis( $current_setting ) == $unique_axis ) {
## 	    $n ++;
## 	}
## 	if( $current_setting eq $requested_setting ) {
## 	    $found_setting = $current_setting;
## 	    last;
## 	}
##     }
## 
##     print ">>> $n\n" and die if $n < 1;
##     die unless defined $found_setting;
## 
##     return $n;
## }
