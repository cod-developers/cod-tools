#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl5 -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
# Convert information about different spacegroups in the
# Spacegroups.pm %Spacegroups::space_groups has into the hash
# containing information about each setting separately.
#**

use strict;
use lib ".";
use Spacegroups;

for my $key (sort keys %Spacegroups::space_groups) {
    my $sg = $Spacegroups::space_groups{$key};

    if( exists $sg->{settings} ) {
	for my $setting (@{$sg->{settings}}) {
	    my $symops = select_symops( $sg, $setting );
	    print_setting( $setting, $key, $sg, $symops );
	}
    } elsif( exists $sg->{positions} ) {
	print_setting( $key, $key, $sg, $sg->{positions} );
    }
}

sub print_setting
{
    my ($setting, $sg_name, $sg, $symops) = @_;

    my @symop_strings = symop_strings($symops);

    ## print "'", $setting, "'";
    print "'", join(";", sort @symop_strings), "',";
    print " => {\n";
    print "    spacegroup_name => ", "'".ucfirst($sg_name)."',", "\n";
    print "    setting_name    => ", "'".ucfirst($setting)."',", "\n";
    print "    schoenflies     => ", "'".ucfirst($sg->{schoenflies})."',", "\n";
    print "    number => ", $sg->{number}, ",\n";
    print "    symops => [\n";
    for my $symop (@symop_strings) {
	print "        \"", $symop, "\",\n";
    }
    print "    ]\n";
    print "},\n";
}

sub symop_strings
{
    my ($symops) = @_;

    my @symop_strings;

    for my $symop (@{$symops}) {
	my $n = 0;
	my $symop_string = "";
	for my $component (@{$symop}) {
	    $component =~ s/\$//g;
	    $component = lc($component);
	    $symop_string .= sprintf "%s", $component;
	    if( $n < 2 ) {
		$symop_string .= ",";
	    }
	    $n++;
	}
	push( @symop_strings, $symop_string );
    }

    return @symop_strings;
}

sub unique_axis
{
    my ($setting_name) = @_;

    my @setting_name = split( " ", $setting_name );

    my $n = 0;
    shift(@setting_name);
    for my $component (@setting_name) {
	if( $component ne "1" ) {
	    last;
	} else {
	    $n++;
	}
    }

    return $n;
}

sub select_symops
{
    my ($sg, $setting) = @_;


    my $index = setting_index( $sg->{settings}, $setting );
    my $symops;
    my $n = unique_axis( $setting );
    for ($n) {
	if(/^0$/) {
	    $symops = $sg->{a_unique};
	    if( !defined $symops ) {
		my $key = "a_unique_$index";
		$symops = $sg->{$key}
	    }
	}
	if(/^1$/) {
	    $symops = $sg->{b_unique};
	    if( !defined $symops ) {
		my $key = "b_unique_$index";
		$symops = $sg->{$key}
	    }
	}
	if(/^2$/) {
	    $symops = $sg->{c_unique};
	    if( !defined $symops ) {
		my $key = "c_unique_$index";
		$symops = $sg->{$key}
	    }
	}
    }

    if( !defined $symops ) {
	$symops = $sg->{positions};
    }

    die( "Could not find appropriate symops for setting '$setting'" )
	unless defined $symops;

    return $symops;
}

sub setting_index
{
    my ($setting_list, $requested_setting) = @_;

    my $unique_axis = unique_axis( $requested_setting );
    my $n = 0;
    my $found_setting;

    for my $current_setting (@{$setting_list}) {
	if( unique_axis( $current_setting ) == $unique_axis ) {
	    $n ++;
	}
	if( $current_setting eq $requested_setting ) {
	    $found_setting = $current_setting;
	    last;
	}
    }

    print ">>> $n\n" and die if $n < 1;
    die unless defined $found_setting;

    return $n;
}
