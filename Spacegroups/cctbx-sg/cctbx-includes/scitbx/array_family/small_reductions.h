/* *****************************************************
   THIS IS AN AUTOMATICALLY GENERATED FILE. DO NOT EDIT.
   *****************************************************

   Generated by:
     scitbx.source_generators.array_family.generate_reductions
 */

#ifndef SCITBX_ARRAY_FAMILY_SMALL_REDUCTIONS_H
#define SCITBX_ARRAY_FAMILY_SMALL_REDUCTIONS_H

#ifndef DOXYGEN_SHOULD_SKIP_THIS

#include <scitbx/array_family/ref_reductions.h>
#include <scitbx/array_family/small_plain.h>

namespace scitbx { namespace af {

  template <typename ElementType1, std::size_t N1,
            typename ElementType2, std::size_t N2>
  int
  inline
  order(
    small_plain<ElementType1, N1> const& a1,
    small_plain<ElementType2, N2> const& a2)
  {
    return order(a1.const_ref(), a2.const_ref());
  }

  template <typename ElementType, std::size_t N>
  inline
  std::size_t
  max_index(small_plain<ElementType, N> const& a)
  {
    return max_index(a.const_ref());
  }

  template <typename ElementType, std::size_t N>
  inline
  std::size_t
  min_index(small_plain<ElementType, N> const& a)
  {
    return min_index(a.const_ref());
  }

  template <typename ElementType, std::size_t N>
  inline
  ElementType
  max(small_plain<ElementType, N> const& a)
  {
    return max(a.const_ref());
  }

  template <typename ElementType, std::size_t N>
  inline
  ElementType
  min(small_plain<ElementType, N> const& a)
  {
    return min(a.const_ref());
  }

  template <typename ElementType, std::size_t N>
  inline
  ElementType
  max_absolute(small_plain<ElementType, N> const& a)
  {
    return max_absolute(a.const_ref());
  }

  template <typename ElementType, std::size_t N>
  inline
  ElementType
  sum(small_plain<ElementType, N> const& a)
  {
    return sum(a.const_ref());
  }

  template <typename ElementType, std::size_t N>
  inline
  ElementType
  sum_sq(small_plain<ElementType, N> const& a)
  {
    return sum_sq(a.const_ref());
  }

  template <typename ElementType, std::size_t N>
  inline
  ElementType
  product(small_plain<ElementType, N> const& a)
  {
    return product(a.const_ref());
  }

  template <typename ElementType, std::size_t N>
  inline
  ElementType
  mean(small_plain<ElementType, N> const& a)
  {
    return mean(a.const_ref());
  }

  template <typename ElementType, std::size_t N>
  inline
  ElementType
  mean_sq(small_plain<ElementType, N> const& a)
  {
    return mean_sq(a.const_ref());
  }

  template <typename ElementTypeValues, std::size_t N1,
            typename ElementTypeWeights, std::size_t N2>
  inline
  ElementTypeValues
  mean_weighted(
    small_plain<ElementTypeValues, N1> const& values,
    small_plain<ElementTypeWeights, N2> const& weights)
  {
    return mean_weighted(values.const_ref(), weights.const_ref());
  }

  template <typename ElementTypeValues, std::size_t N1,
            typename ElementTypeWeights, std::size_t N2>
  inline
  ElementTypeValues
  mean_sq_weighted(
    small_plain<ElementTypeValues, N1> const& values,
    small_plain<ElementTypeWeights, N2> const& weights)
  {
    return mean_sq_weighted(values.const_ref(), weights.const_ref());
  }

  template <typename ElementType, std::size_t N, class PredicateType>
  inline
  boost::optional<std::size_t>
  first_index(small_plain<ElementType, N> const& a,
               PredicateType p)
  {
    return first_index(a.const_ref(), p);
  }

  template <typename ElementType, std::size_t N, class PredicateType>
  inline
  boost::optional<std::size_t>
  last_index(small_plain<ElementType, N> const& a,
               PredicateType p)
  {
    return last_index(a.const_ref(), p);
  }

}} // namespace scitbx::af

#endif // DOXYGEN_SHOULD_SKIP_THIS

#endif // SCITBX_ARRAY_FAMILY_SMALL_REDUCTIONS_H

