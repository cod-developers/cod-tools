Index: lib/src/csymlib.c
===================================================================
--- lib/src/csymlib.c	(revision 2)
+++ lib/src/csymlib.c	(revision 16)
@@ -854,7 +854,7 @@
     *ch1 = ' ';
     *(ch1+1) = ' ';
     ch1 = strstr(name,"R");
-    *ch1 = 'H';
+    if (ch1) *ch1 = 'H';
   }
 
   return;
Index: lib/src/ccp4_errno.h
===================================================================
--- lib/src/ccp4_errno.h	(revision 2)
+++ lib/src/ccp4_errno.h	(revision 16)
@@ -111,7 +111,13 @@
  *    3  Error
  *    4  Fatal
  */
+#ifdef __cplusplus
+extern "C" {
+#endif
 extern int ccp4_errno;
+#ifdef __cplusplus
+}
+#endif
 
 #ifdef __cplusplus
 namespace CCP4 {
Index: lib/src/library_file.c
===================================================================
--- lib/src/library_file.c	(revision 2)
+++ lib/src/library_file.c	(revision 16)
@@ -50,7 +50,7 @@
 #include<string.h>
 #include <limits.h>
 #include <fcntl.h>
-#if defined _MVS
+#if defined _MSC_VER
 #include <io.h>
 #endif
 #include "library_file.h"
@@ -332,7 +332,7 @@
       cfile->iostat = CIO_ReadFail;
       result = 0; }
   } else {
-#if defined _MVS
+#if defined _MSC_VER
     result = _read (cfile->fd, buffer, n_items);
 #else
     result = read (cfile->fd, buffer, n_items);
@@ -371,7 +371,7 @@
     result = fwrite (buffer, (size_t) sizeof(char), n_items,
                     cfile->stream);
   else
-#if defined _MVS
+#if defined _MSC_VER
     result = _write (cfile->fd, buffer, n_items);
 #else
     result = write (cfile->fd, buffer, n_items);
@@ -421,10 +421,10 @@
     if (!(result = (fseek (cfile->stream,offset,whence))))
       result = ftell(cfile->stream);
   } else {
-#if defined _MVS
+#if defined _MSC_VER
      result = _lseek(cfile->fd,offset,whence);
 #else
-     result = lseek(cfile->fd, offset, whence);
+     result = (int) lseek(cfile->fd, offset, whence);
 #endif
   }
 
@@ -541,7 +541,7 @@
       result = fflush(cfile->stream);
   } else {
     if (cfile->own)
-#if defined _MVS
+#if defined _MSC_VER
       result = _close(cfile->fd);
 #else
       result = close (cfile->fd);
@@ -729,7 +729,7 @@
  */
 const char *ccp4_file_name( CCP4File *cfile)
 {
-#if defined _MVS
+#if defined _MSC_VER
   return ( cfile == NULL ? NULL : _strdup(cfile->name));
 #else
   return ( cfile == NULL ? NULL : strdup(cfile->name));
@@ -799,7 +799,7 @@
 CCP4File *ccp4_file_open_file (const FILE *file, const int flag)
 {
   CCP4File *cfile;
-#if defined _MVS
+#if defined _MSC_VER
   struct _stat st;
 #else
   struct stat st;
@@ -821,7 +821,7 @@
   cfile->buffered = 1;
   cfile->open = 1;
 
-#if defined _MVS
+#if defined _MSC_VER
   _fstat(_fileno(cfile->stream), &st);
   if ( !(st.st_mode & S_IFREG) || file == stdin) {
 #else
@@ -853,7 +853,7 @@
 CCP4File *ccp4_file_open_fd (const int fd, const int flag)
 {
   CCP4File * cfile;
-#if defined _MVS
+#if defined _MSC_VER
   struct _stat st;
 #else
   struct stat st;
@@ -869,7 +869,7 @@
   cfile->open = 1;
   cfile->buffered = 0;
 
-#if defined _MVS
+#if defined _MSC_VER
   _fstat(fd, &st);
   if ( !(st.st_mode & S_IFREG) || fd == 0) {
 #else
@@ -882,7 +882,7 @@
   } else {
     cfile->length = st.st_size;
     cfile->direct = 1;
-#if defined _MVS
+#if defined _MSC_VER
     cfile->loc = _lseek(fd, 0L, SEEK_CUR);
 #else
     cfile->loc = lseek(fd, 0L, SEEK_CUR);
@@ -910,7 +910,7 @@
   CCP4File *cfile;
   int openflags = O_RDONLY;
   char fmode[5];
-#if defined _MVS
+#if defined _MSC_VER
   struct _stat st;
 #else
   struct stat st;
@@ -926,13 +926,13 @@
     else if (cfile->write)  openflags = (O_WRONLY | O_CREAT);
     if (cfile->append) openflags |= O_APPEND;
     if (flag & O_TRUNC) openflags |= O_TRUNC;
-#if defined _MVS
+#if defined _MSC_VER
     if (cfile->scratch) openflags |= O_TEMPORARY;
 #endif
-#if defined(__DECC) && defined(VMS) || defined (_MVS)
+#if defined(__DECC) && defined(VMS) || defined (_MSC_VER)
     openflags |= O_BINARY;
 #endif
-#if defined _MVS
+#if defined _MSC_VER
     cfile->fd = _open(filename, openflags);
 #else
     cfile->fd = open(filename, openflags);
@@ -942,7 +942,7 @@
                   "ccp4_file_open1", NULL);
       return NULL;
     } else {
-#if defined _MVS
+#if defined _MSC_VER
       _fstat(cfile->fd, &st); }
 #else
       fstat(cfile->fd, &st); }
@@ -976,7 +976,7 @@
                              "mbc=16",        /* bigger blocksize */
                              "ctx=stm", "mrs=0", "rat=cr", "rfm=stmlf");
 #else
-# ifdef _MVS
+# ifdef _MSC_VER
     if (cfile->scratch)
       cfile->stream = tmpfile();
     else
@@ -998,20 +998,20 @@
 #if defined (__alpha) && defined (vms)
 (void) fflush (cfile->stream);
 #endif
-#if defined _MVS
+#if defined _MSC_VER
   _fstat(_fileno(cfile->stream), &st);
 #else
   fstat(fileno(cfile->stream), &st);
 #endif
   }
-#if defined _MVS
+#if defined _MSC_VER
   cfile->name = _strdup(filename);
 #else
   cfile->name = strdup(filename);
 #endif
   cfile->open = 1;
   cfile->own = 1;
-#if defined _MVS
+#if defined _MSC_VER
   if ( !(st.st_mode & S_IFREG) ) {
 #else
   if ( !S_ISREG(st.st_mode) ) {
@@ -2057,7 +2057,7 @@
  */
 long ccp4_file_length (CCP4File *cfile)
 {
-#if defined _MVS
+#if defined _MSC_VER
   struct _stat st;
 #else
   struct stat st;
@@ -2072,14 +2072,14 @@
 
   if (cfile->buffered && cfile->stream)
       fflush (cfile->stream);
-#if defined _MVS
+#if defined _MSC_VER
     _fstat(cfile->stream ? _fileno(cfile->stream) : cfile->fd, &st);
 #else
     fstat(cfile->stream ? fileno(cfile->stream) : cfile->fd, &st);
 #endif
     cfile->length = st.st_size;
 
-  return (st.st_size);
+  return ((long) st.st_size);
 }
 
 /**
@@ -2104,10 +2104,10 @@
     fflush (cfile->stream);
     result = (long) ftell(cfile->stream);
   } else
-#if defined _MVS
+#if defined _MSC_VER
     result = _lseek(cfile->fd, 0L, SEEK_CUR);
 #else
-    result = lseek(cfile->fd, 0L, SEEK_CUR);
+    result = (long) lseek(cfile->fd, 0L, SEEK_CUR);
 #endif
 
   cfile->loc = result;
@@ -2246,5 +2246,3 @@
 
   return msg_curr;
 }
-
-
Index: lib/src/cmtzlib.c
===================================================================
--- lib/src/cmtzlib.c	(revision 2)
+++ lib/src/cmtzlib.c	(revision 16)
@@ -84,8 +84,13 @@
 #define  CMTZERR_COLUMNIncomplete    21
 #define  CMTZERR_BadBatchHeader    22
 
+MTZ *MtzGetUserCellTolerance(
+  const char *logname, int read_refs, const double cell_tolerance)
+{
+  return MtzGet(logname, read_refs);
+}
+
 MTZ *MtzGet(const char *logname, int read_refs)
-
 { MTZ *mtz;
   CCP4File *filein;
   int istat, newproj, cset_warn=0, length;
@@ -134,6 +139,7 @@
   filein = ccp4_file_open(filename,O_RDONLY);
   if (! filein ) {
     ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_CantOpenFile),"MtzGet",NULL);
+    free(filename);
     return NULL;
   }
 
@@ -151,6 +157,8 @@
   parser = ccp4_parse_start(20);
   if (parser == NULL) {
     ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_ParserFail),"MtzGet",NULL);
+    ccp4_file_close(filein);
+    free(filename);
     return NULL;
   }
   /* Set some convenient pointers to members of the parser array */
@@ -161,8 +169,11 @@
   ccp4_file_setmode(filein,0);
   istat = ccp4_file_readchar(filein, (uint8 *) hdrrec, 4);
   /* We don't test all reads, but this one should trap for e.g. truncated files */
-  if (istat == EOF || strlen(hdrrec) == 0) {
+  if (istat == EOF || hdrrec[0] == '\0') {
     ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_ReadFail),"MtzGet",NULL);
+    ccp4_parse_end(parser);
+    ccp4_file_close(filein);
+    free(filename);
     return NULL;
   }
   hdrrec[4] = '\0';
@@ -170,6 +181,9 @@
 
   if (!ccp4_keymatch(key,"MTZ")) {
     ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_NotMTZ),"MtzGet",NULL);
+    ccp4_parse_end(parser);
+    ccp4_file_close(filein);
+    free(filename);
     return(NULL);
   }
 
@@ -186,6 +200,9 @@
   /* We don't test all seeks, but this one might trap duff files */
   if ( ccp4_file_seek(filein, hdrst-1, SEEK_SET) ) {
     ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_ReadFail),"MtzGet",NULL);
+    ccp4_parse_end(parser);
+    ccp4_file_close(filein);
+    free(filename);
     return NULL;
   }
 
@@ -207,8 +224,11 @@
   if (debug)
     printf(" Read first header record with istat = %d \n",istat);
   /* We don't test all reads, but this one should trap for e.g. truncated files */
-  if (istat == EOF) {
+  if (istat == EOF || hdrrec[0] == '\0') {
     ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_ReadFail),"MtzGet",NULL);
+    ccp4_parse_end(parser);
+    ccp4_file_close(filein);
+    free(filename);
     return NULL;
   }
 
@@ -234,7 +254,12 @@
     else if (ccp4_keymatch(key, "PROJ")) {
       ++iiset;
       if (iiset >= MSETS) {
-        printf("MtzGet: Maximum number of datasets exceeded! \n");
+        if (ccp4_liberr_verbosity(-1)) {
+          printf("MtzGet: Maximum number of datasets exceeded! \n");
+        }
+        ccp4_parse_end(parser);
+        ccp4_file_close(filein);
+        free(filename);
         return NULL;
       }
       strcpy(project,"dummy");
@@ -252,7 +277,12 @@
       if (jxtal == -1) {
         ++nxtal;
         if (nxtal > MXTALS) {
-          printf("MtzGet: Maximum number of crystals exceeded! \n");
+          if (ccp4_liberr_verbosity(-1)) {
+            printf("MtzGet: Maximum number of crystals exceeded! \n");
+          }
+          ccp4_parse_end(parser);
+          ccp4_file_close(filein);
+          free(filename);
           return NULL;
         }
         jxtalin[iiset]=nxtal-1;
@@ -280,7 +310,12 @@
         if (jxtal == -1) {
           ++nxtal;
           if (nxtal > MXTALS) {
-            printf("MtzGet: Maximum number of crystals exceeded! \n");
+            if (ccp4_liberr_verbosity(-1)) {
+              printf("MtzGet: Maximum number of crystals exceeded! \n");
+            }
+            ccp4_parse_end(parser);
+            ccp4_file_close(filein);
+            free(filename);
             return NULL;
           }
           jxtalin[iiset]=nxtal-1;
@@ -296,7 +331,7 @@
        don't increment as we already have it. */
     else if (ccp4_keymatch(key, "DATA")) {
       if ( ntok <= 2 || (ntok > 2 && strcmp(token[2].fullstring,"HKL_base")) )
-        ++nset[nxtal-1];
+        ++nset[jxtalin[iiset]];
     }
 
     /* DCELL line. */
@@ -317,20 +352,25 @@
         }
         ++nxtal;
         if (nxtal > MXTALS) {
-          printf("MtzGet: Maximum number of crystals exceeded! \n");
+          if (ccp4_liberr_verbosity(-1)) {
+            printf("MtzGet: Maximum number of crystals exceeded! \n");
+          }
+          ccp4_parse_end(parser);
+          ccp4_file_close(filein);
+          free(filename);
           return NULL;
         }
-        jxtalin[iiset]=nxtal-1;
         strcpy(projin[nxtal-1],project);
         strcpy(crysin[nxtal-1],crystal);
         /* Try to make crystal name unique */
         sprintf(crysin[nxtal-1]+strlen(crystal),"%d",nxtal);
         /* correct DATASET increment */
-        --nset[nxtal-2];
-        ++nset[nxtal-1];
+        --nset[jxtalin[iiset]];
+        jxtalin[iiset]=nxtal-1;
+        ++nset[jxtalin[iiset]];
       }
       for (i = 0; i < 6; ++i)
-        cellin[nxtal-1][i] = cell[i];
+        cellin[jxtalin[iiset]][i] = cell[i];
     }
 
     istat = ccp4_file_readchar(filein, (uint8 *) hdrrec, MTZRECORDLENGTH);
@@ -348,7 +388,12 @@
     printf(" MtzGet: end of 1st pass \n");
 
   /* Allocate memory for input MTZ file */
-  if (! (mtz = MtzMalloc(nxtal, nset))) return NULL;
+  if (! (mtz = MtzMalloc(nxtal, nset))) {
+    ccp4_parse_end(parser);
+    ccp4_file_close(filein);
+    free(filename);
+    return NULL;
+  }
   if (debug)
     printf(" MtzGet: created mtz \n");
   mtz->filein = filein;
@@ -402,6 +447,9 @@
         if (!mtz->xtal[jxtalin[iiset]]->set[nset[jxtalin[iiset]]]) {
           ccp4_signal(CCP4_ERRLEVEL(3) |
                       CMTZ_ERRNO(CMTZERR_NullDataset),"MtzGet",NULL);
+          ccp4_parse_end(parser);
+          ccp4_file_close(filein);
+          free(filename);
           return NULL;
         }
         mtz->xtal[jxtalin[iiset]]->set[nset[jxtalin[iiset]]]->setid = iset;
@@ -456,6 +504,9 @@
     if (strncmp (mkey, "VERS",4) == 0) {
       if (strncmp (hdrrec+5,"MTZ:V1.1",8) != 0) {
          ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_BadVersion),"MtzGet",NULL);
+         ccp4_parse_end(parser);
+         ccp4_file_close(filein);
+         free(filename);
          return(NULL);
          }
        }
@@ -489,6 +540,9 @@
       if (ntok < 7) {
         ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_SYMINFIncomplete),
                         "MtzGet", NULL);
+        ccp4_parse_end(parser);
+        ccp4_file_close(filein);
+        free(filename);
         return(NULL);
       }
       mtz->mtzsymm.nsym = (int) token[1].value;
@@ -507,11 +561,19 @@
       if (ntok < 5) {
         ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_COLUMNIncomplete),
                         "MtzGet", NULL);
+        ccp4_parse_end(parser);
+        ccp4_file_close(filein);
+        free(filename);
         return(NULL);
       }
       ++icolin;
       if (icolin >= MCOLUMNS) {
-        printf("MtzGet: Maximum number of columns exceeded! \n");
+        if (ccp4_liberr_verbosity(-1)) {
+          printf("MtzGet: Maximum number of columns exceeded! \n");
+        }
+        ccp4_parse_end(parser);
+        ccp4_file_close(filein);
+        free(filename);
         return NULL;
       }
       strcpy(label,token[1].fullstring);
@@ -522,8 +584,10 @@
          Very old MTZ files may not have this value */
       if (ntok < 6) {
         if (!cset_warn) {
-          printf("Dataset id missing from COLUMN records in MTZ header. \n");
-          printf("Making default assignments. \n");
+          if (ccp4_liberr_verbosity(-1)) {
+            printf("Dataset id missing from COLUMN records in MTZ header. \n");
+            printf("Making default assignments. \n");
+          }
           ccp4_signal(CCP4_ERRLEVEL(2) | CMTZ_ERRNO(CMTZERR_DatasetIncomplete),
                         "MtzGet", NULL);
           cset_warn = 1;
@@ -615,6 +679,9 @@
         if (!ccp4_keymatch(key, "BH")) {
           ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_BadBatchHeader),
                         "MtzGet", NULL);
+          ccp4_parse_end(parser);
+          ccp4_file_close(filein);
+          free(filename);
           return(NULL);
         }
 
@@ -1586,7 +1653,9 @@
   }
   printf(" *  Resolution Range :\n\n");
   printf(" %10.5f %10.5f     ( %10.3f - %10.3f A )\n\n",
-       minres,maxres,1.0/sqrt(minres),1.0/sqrt(maxres));
+       minres, maxres,
+       (minres > 0.0 ? 1.0/sqrt(minres) : 0.0),
+       (maxres > 0.0 ? 1.0/sqrt(maxres) : 0.0));
   ccp4_lrsort(mtz, isort);
   printf(" * Sort Order :\n\n  %5d %5d %5d %5d %5d\n\n",isort[0],isort[1],isort[2],
        isort[3],isort[4]);
@@ -1702,7 +1771,7 @@
 int MtzPrintBatchHeader(const MTZBAT *batch) {
 
   int i;
-  char labtype[20],axes[5],string1[40],string2[40];
+  char labtype[26],axes[5],string1[40],string2[40];
 
   switch (batch->ldtype) {
   case 1:
@@ -1827,22 +1896,31 @@
 
 int ccp4_lwtitl(MTZ *mtz, const char *ftitle, int flag) {
 
-  int length;
+  unsigned i;
 
   if (flag == 0) {
 
-    strncpy(mtz->title,ftitle,71);
+    strncpy(mtz->title,ftitle,70);
 
   } else {
 
-    length = (int) strlen(mtz->title);
-    while ((--length >= 0) && mtz->title[length] == ' ');
-    if (length >= 0)
-      mtz->title[++length] = ' ';
-    strncpy(mtz->title+length+1,ftitle,70-length);
-
+    mtz->title[70] = '\0';
+    i = strlen(mtz->title);
+    while (i != 0) {
+      if (mtz->title[--i] != ' ') {
+        i++;
+        break;
+      }
+    }
+    if (i == 0) {
+      strncpy(mtz->title, ftitle, 70);
+    }
+    else if (i < 69) {
+      mtz->title[i++] = ' ';
+      strncpy(mtz->title+i, ftitle, 70-i);
+    }
   }
-
+  mtz->title[70] = '\0';
   return 1;
 }
 
@@ -2471,8 +2549,11 @@
        /* Check that the column type is set
           If it is blank then the COLUMN record will be incomplete */
        if (mtz->xtal[i]->set[j]->col[k]->type[0] == '\0') {
-         printf("From MtzPut: column type for %s is not set, assume type R\n",
-                mtz->xtal[i]->set[j]->col[k]->label);
+         if (ccp4_liberr_verbosity(-1)) {
+           printf(
+             "From MtzPut: column type for %s is not set, assume type R\n",
+             mtz->xtal[i]->set[j]->col[k]->label);
+         }
          strncpy(mtz->xtal[i]->set[j]->col[k]->type,"R",2);
        }
        sprintf(hdrrec+38,"%c %17.4f %17.4f %4d",
@@ -2651,7 +2732,9 @@
  }
  if (!isort) return batch;
 
- printf("\n Note: Sorting batch headers prior to writing to file... \n\n");
+ if (ccp4_liberr_verbosity(-1)) {
+   printf("\n Note: Sorting batch headers prior to writing to file... \n\n");
+ }
 
  /* Sort */
  /* This is Simon Tatham's algorithm, implemented for batches. */
@@ -2753,6 +2836,7 @@
  fileout = ccp4_file_open(filename,O_RDWR | O_TRUNC);
  if (! fileout ) {
    ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_CantOpenFile),"MtzOpenForWrite",NULL);
+   free(filename);
    return NULL;
  }
  if (debug) printf(" MtzOpenForWrite: file opened \n");
@@ -2908,6 +2992,7 @@
     ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_AllocFail),"MtzMalloc",NULL);
     return NULL;
   }
+  memset(mtz, '\0', sizeof(MTZ));
 
   mtz->nxtal=0;
   ccp4array_new_size(mtz->xtal,5);
@@ -2933,12 +3018,20 @@
   mtz->hist = NULL;
   mtz->histlines = 0;
   mtz->nxtal = nxtal;
+  mtz->ncol_read = 0;
   mtz->nref = 0;
+  mtz->nref_filein = 0;
+  mtz->refs_in_memory = 1;
+  mtz->n_orig_bat = 0;
   mtz->resmax_out = 0.0f;
   mtz->resmin_out = 999.0f;
-  mtz->refs_in_memory = 1;
-  mtz->n_orig_bat = 0;
   sprintf(mtz->mnf.amnf,"NAN");
+  mtz->mtzsymm.spcgrp = 0;
+  mtz->mtzsymm.spcgrpname[0] = '\0';
+  mtz->mtzsymm.nsym = 0;
+  mtz->mtzsymm.nsymp = 0;
+  mtz->mtzsymm.symtyp = '\0';
+  mtz->mtzsymm.pgname[0] = '\0';
   mtz->batch = NULL;
   for (i = 0; i < 5; ++i) {
     mtz->order[i] = NULL;
@@ -2979,8 +3072,10 @@
   }
   ccp4array_free(mtz->xtal);
 
-  if (mtz->n_orig_bat > 0)
+  if (mtz->batch) {
     MtzFreeBatch(mtz->batch);
+    mtz->batch = NULL;
+  }
 
   if (mtz->hist != NULL)
     MtzFreeHist(mtz->hist);
@@ -3000,6 +3095,7 @@
     ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_AllocFail),"MtzMallocBatch",NULL);
     return NULL;
   }
+  memset(batch, '\0', sizeof(MTZBAT));
   batch->next = NULL;
 
   return(batch);
@@ -3012,6 +3108,7 @@
 {
   if (batch != NULL) {
     MtzFreeBatch(batch->next);
+    batch->next = NULL;
     free(batch);
   }
   return 1;
@@ -3026,7 +3123,7 @@
     ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_AllocFail),"MtzMallocCol",NULL);
     return NULL;
   }
-
+  memset(col, '\0', sizeof(MTZCOL));
   col->ref = NULL;
   if (mtz->refs_in_memory) {
     ccp4array_new_size(col->ref,nref);
@@ -3077,6 +3174,7 @@
     ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_AllocFail),"MtzAddXtal",NULL);
     return NULL;
   }
+  memset(xtal, '\0', sizeof(MTZXTAL));
   /* fill out the data */
   strncpy( xtal->xname, xname, 64 );
   xtal->xname[64] = '\0';
@@ -3113,17 +3211,25 @@
     ccp4_signal(CCP4_ERRLEVEL(3) | CMTZ_ERRNO(CMTZERR_AllocFail),"MtzAddDataset",NULL);
     return NULL;
   }
+  memset(set, '\0', sizeof(MTZSET));
   /* fill out the data */
   strncpy( set->dname, dname, 64 );
   set->dname[64] = '\0';
   set->wavelength = wavelength;
-  /* new setid is one more than greatest current setid */
-  i = -1;
-  for (x = 0; x < mtz->nxtal; x++)
-    for (s = 0; s < mtz->xtal[x]->nset; s++)
-      if (mtz->xtal[x]->set[s]->setid > i) i = mtz->xtal[x]->set[s]->setid;
-
-  set->setid = ++i;
+  if (strcmp(set->dname, "HKL_base") == 0) {
+    set->setid = 0;
+  }
+  else {
+    i = 0;
+    for (x = 0; x < mtz->nxtal; x++) {
+      for (s = 0; s < mtz->xtal[x]->nset; s++) {
+        if (mtz->xtal[x]->set[s]->setid > i) {
+          i = mtz->xtal[x]->set[s]->setid;
+        }
+      }
+    }
+    set->setid = ++i;
+  }
   set->ncol = 0;
   /* create initial array of 20 pointers to columns */
   ccp4array_new_size(set->col,20);
@@ -3145,7 +3251,9 @@
   MTZCOL *col;
 
   if (set->ncol == MCOLUMNS) {
-    printf("MtzAddColumn: No more columns! \n");
+    if (ccp4_liberr_verbosity(-1)) {
+      printf("MtzAddColumn: No more columns! \n");
+    }
     return NULL;
   }
 
Index: lib/src/ccp4_parser.c
===================================================================
--- lib/src/ccp4_parser.c	(revision 2)
+++ lib/src/ccp4_parser.c	(revision 16)
@@ -1297,6 +1297,15 @@
         is_frc = 1;
 
       } else if (toupper(this_char) == 'E') {
+        char exponent_char;
+        /* E must be followed by [+-]digit */
+        if (ichar+1 >= lstr) return 0;
+        exponent_char = str[ichar+1];
+        if (exponent_char == '+' || exponent_char == '-') {
+          if (ichar+2 >= lstr) return 0;
+          exponent_char = str[ichar+2];
+        }
+        if (!isdigit(exponent_char)) return 0;
         /* Exponent? i.e. e or E
            There can only be one exponent */
         if (exponent > -1) return 0;
Index: lib/src/cmtzlib.h
===================================================================
--- lib/src/cmtzlib.h	(revision 2)
+++ lib/src/cmtzlib.h	(revision 16)
@@ -151,6 +151,10 @@
  */
 MTZ *MtzGet(const char *logname, int read_refs);
 
+/* For compatibility with main CCP4 version. */
+MTZ *MtzGetUserCellTolerance(
+  const char *logname, int read_refs, const double cell_tolerance);
+
 /** Reads reflection data from MTZ file.
  * @param filein pointer to input file
  * @param ncol number of columns to read
@@ -998,7 +1002,7 @@
 /* float PhaseProb(float phase, float hla, float hlb, float hlc, float hld,
                 BOOLEAN centric); */
 /* Returns the probability of `phase` (expressed in radians) as determined by
-   the Hendrickson-Lattmann coefficients `hla`, `hlb`, `hlc` and `hld`. If
+   the Hendrickson-Lattman coefficients `hla`, `hlb`, `hlc` and `hld`. If
    `centric == TRUE`, the coefficients describe a centric distribution. */
 
 #ifdef __cplusplus
Index: lib/src/library_err.c
===================================================================
--- lib/src/library_err.c	(revision 2)
+++ lib/src/library_err.c	(revision 16)
@@ -339,5 +339,3 @@
 
   if (fatal_err) exit(1);
 }
-
-
Index: lib/src/ccp4_utils.h
===================================================================
--- lib/src/ccp4_utils.h	(revision 2)
+++ lib/src/ccp4_utils.h	(revision 16)
@@ -121,7 +121,7 @@
 
 float ccp4_utils_etime (float *);
 
-#if defined (_MVS)
+#if defined (_MSC_VER)
 double ccp4_erfc( double x );
 #endif
 
Index: lib/src/cvecmat.c
===================================================================
--- lib/src/cvecmat.c	(revision 2)
+++ lib/src/cvecmat.c	(revision 16)
@@ -97,7 +97,7 @@
 
   d = a[0][0]*c[0][0] + a[0][1]*c[0][1] + a[0][2]*c[0][2];
 
-  if (d > 1.0e-30) {
+  if (d > 1.0e-30 || d < -1.0e-30) {
     for ( i = 0; i < 3; i++ )
       for ( j = 0; j < 3; j++ )
         ai[i][j] = c[j][i] / d;
Index: lib/src/library_utils.c
===================================================================
--- lib/src/library_utils.c	(revision 2)
+++ lib/src/library_utils.c	(revision 16)
@@ -72,14 +72,14 @@
 #include "ccp4_utils.h"
 #include "ccp4_errno.h"
 
-#if defined (_MVS)
+#if defined (_MSC_VER)
 #include <tchar.h>
 #include <wchar.h>
 #include <direct.h>
 #include <io.h>
 #endif
 
-#if !defined (_MVS)
+#if !defined (_MSC_VER)
 #include <pwd.h>
 #endif
 
@@ -168,7 +168,9 @@
     defined (__osf__) || defined (__FreeBSD__) || defined (linux) || \
     defined (_WIN32)
   /* putenv is the POSIX.1, draft 3 proposed mechanism */
+#if !(defined(__hpux) && defined(__HP_cc))
   int putenv ();
+#endif
   char *param;
 
   if ( (param = (char *) ccp4_utils_malloc( (strlen(str)+1)*sizeof(char) )) == NULL) {
@@ -207,7 +209,7 @@
     defined (__FreeBSD__)
   return setlinebuf(stdout);
 #else
-#if defined (_MVS)
+#if defined (_MSC_VER)
   return setvbuf(stdout, NULL, _IONBF, 80);
 #else
 #  if defined (_AIX)
@@ -233,24 +235,24 @@
 union float_uint_uchar ccp4_nan ()
 
 #if NATIVEFT == DFNTF_BEIEEE || NATIVEFT == DFNTF_LEIEEE
-#  define NAN 0xfffa5a5a
+#  define CCP4_NAN 0xfffa5a5a
 #endif
 /* For \idx{Convex} native mode and \idx{VAX} use a \idx{Rop} value:        */
 /*                                                                          */
 /* <magic numbers>=                                                         */
 #if NATIVEFT == DFNTF_CONVEXNATIVE
-#  define NAN 0x80000000
+#  define CCP4_NAN 0x80000000
 #endif
 #if NATIVEFT == DFNTF_VAX
-#  define NAN 0x00008000
+#  define CCP4_NAN 0x00008000
 #endif
-#ifndef NAN
-#  error "NAN isn't defined (needs NATIVEFT)"
+#ifndef CCP4_NAN
+#  error "CCP4_NAN isn't defined (needs NATIVEFT)"
 #endif
 {
   union float_uint_uchar realnum;
 
-  realnum.i = NAN;
+  realnum.i = CCP4_NAN;
   return (realnum);
 }
 
@@ -283,7 +285,7 @@
 {
   int i;
   for (i=0; i<ncols; i++)
-    if (cols[i].i != NAN)
+    if (cols[i].i != CCP4_NAN)
       if (cols[i].f <= MDFBIG) cols[i].f = 0.0;
 }
 
@@ -295,7 +297,7 @@
 {
   int i;
   for (i=0; i<ncols; i++)
-    if (cols[i].i != NAN)
+    if (cols[i].i != CCP4_NAN)
        if (cols[i].f > MDFBIG) {
          if (cols[i].f < wminmax[2*i]) wminmax[2*i] = cols[i].f;
          if (cols[i].f > wminmax[1+2*i]) wminmax[1+2*i] = cols[i].f; }
@@ -316,12 +318,12 @@
  * @return
  */
 int ccp4_utils_mkdir (const char *path, const char *cmode)
-#if !defined (_MVS) && !defined(_WIN32)
+#if !defined (_MSC_VER) && !defined(_WIN32)
 {
-  mode_t mode = 0;
+  unsigned mode = 0;
   int result;
 #if defined (__APPLE__)
-  static const unsigned short TBM = 0x07;
+  static const unsigned TBM = 0x07;
 
   switch (strlen(cmode)) {
   case 4:
@@ -351,7 +353,7 @@
   Try also S_IRWXU, S_IRWXG, etc. */
   sscanf(cmode,"%o",&mode);
 #endif
-  result = mkdir(path,mode);
+  result = mkdir(path, (mode_t) mode);
 
   if (result == -1) {
     if (errno == EEXIST) {
@@ -381,10 +383,11 @@
  * @return
  */
 int ccp4_utils_chmod (const char *path, const char *cmode)
-#if !defined (_MVS) || !defined(_WIN32)
-{ mode_t mode = 0;
+#if !defined (_MSC_VER) || !defined(_WIN32)
+{
+  unsigned mode = 0;
 #if defined (__APPLE__)
-  static const unsigned short TBM = 0x07;
+  static const unsigned TBM = 0x07;
 
   switch (strlen(cmode)) {
   case 4:
@@ -414,7 +417,7 @@
   Try also S_IRWXU, S_IRWXG, etc. */
   sscanf(cmode,"%o",&mode);
 #endif
-  return (chmod(path,mode));
+  return (chmod(path, (mode_t) mode));
 }
 #else
    {
@@ -481,7 +484,7 @@
  * In these instances use getpwuid instead.
  * @return pointer to character string containing login name.
  */
-#if ! defined (_MVS)
+#if ! defined (_MSC_VER)
 char *ccp4_utils_username(void)
 {
   struct passwd *passwd_struct=NULL;
@@ -668,7 +671,7 @@
  * @param tarray Array containing User and System times.
  * @return Sum of User and System times.
  */
-#if ! defined (_MVS)
+#if ! defined (_MSC_VER)
 float ccp4_utils_etime (float tarray[2])
 {
   static long clk_tck = 0;
@@ -682,7 +685,7 @@
 }
 #endif
 
-#if defined (_MVS)
+#if defined (_MSC_VER)
 double ccp4_erfc( double x )
 {
   double t,z,ans;
@@ -716,7 +719,7 @@
 
 #endif
 
-#  if (defined _MVS)
+#  if (defined _MSC_VER)
 double rint(double x) {
   if (x >= 0.) {
    return (double)(int)(x+.5);
Index: lib/src/ccp4_sysdep.h
===================================================================
--- lib/src/ccp4_sysdep.h	(revision 2)
+++ lib/src/ccp4_sysdep.h	(revision 16)
@@ -99,12 +99,12 @@
 #  define CALL_LIKE_VMS 1
 #endif
 
-#if defined(_MVS) || defined (WIN32)
+#if defined(_MSC_VER) || defined (WIN32)
 #  define CALL_LIKE_MVS 1
 #  define KNOWN_MACHINE
 #endif
 
-#if defined (linux)
+#if defined (linux) || defined (__CYGWIN__)
 #  undef CALL_LIKE_SUN
 #  define KNOWN_MACHINE
 #  define CALL_LIKE_SUN 1
@@ -149,10 +149,10 @@
 #else
 #  include <sys/types.h>
 #  include <sys/stat.h>
-#  if !defined (_WIN32) && !defined (_MVS)
+#  if !defined (_WIN32) && !defined (_MSC_VER)
 #    include <sys/times.h>
 #  endif
-#  ifdef _MVS
+#  ifdef _MSC_VER
 #    define NOUNISTD
 #  endif
 #endif
@@ -164,7 +164,7 @@
 #  include <unistd.h>
 #else
 #  ifndef VMS
-#    ifndef _MVS
+#    ifndef _MSC_VER
 #      include <sys/file.h>     /* ESV, old Concentrix */ /* non-POSIX */
 #    endif
 #  endif
@@ -199,15 +199,15 @@
 
 /* rint() function does not seen to exist for mingw32
    defined in library_utils.c */
-#  if (defined _WIN32) || (defined _MVS)
+#  if (defined _WIN32) || (defined _MSC_VER)
   double rint(double x);
 #endif
 
-#ifdef _MVS
+#ifdef _MSC_VER
 #define  M_PI            3.14159265358979323846
 #endif
 
-#ifdef _MVS
+#ifdef _MSC_VER
 #  define PATH_SEPARATOR '\\'
 #  define EXT_SEPARATOR '.'
 #else
Index: lib/src/ccp4_unitcell.c
===================================================================
--- lib/src/ccp4_unitcell.c	(revision 2)
+++ lib/src/ccp4_unitcell.c	(revision 16)
@@ -157,7 +157,7 @@
 
    /* now calculate rf from ro, determinant gives cell volume */
 
-  return invert3matrix(ro, rf);
+  return invert3matrix((const double (*)[3]) ro, rf);
 
 }
 
@@ -233,8 +233,8 @@
     for ( j = 0; j < 3; j++ )
       rft[i][j] = rf[j][i];
 
-  ccp4_3matmul(temp,uomat,rft);
-  ccp4_3matmul(ufmat,rf,temp);
+  ccp4_3matmul(temp, (const double (*)[3]) uomat, (const double (*)[3]) rft);
+  ccp4_3matmul(ufmat, rf, (const double (*)[3]) temp);
 
   uf[0] = ufmat[0][0]; uf[1] = ufmat[1][1]; uf[2] = ufmat[2][2];
   uf[3] = ufmat[0][1]; uf[4] = ufmat[0][2]; uf[5] = ufmat[1][2];
@@ -254,8 +254,8 @@
     for ( j = 0; j < 3; j++ )
       rot[i][j] = ro[j][i];
 
-  ccp4_3matmul(temp,ufmat,rot);
-  ccp4_3matmul(uomat,ro,temp);
+  ccp4_3matmul(temp, (const double (*)[3]) ufmat, (const double (*)[3]) rot);
+  ccp4_3matmul(uomat, ro, (const double (*)[3]) temp);
 
   uo[0] = uomat[0][0]; uo[1] = uomat[1][1]; uo[2] = uomat[2][2];
   uo[3] = uomat[0][1]; uo[4] = uomat[0][2]; uo[5] = uomat[1][2];
@@ -289,8 +289,10 @@
   /* check cell volumes */
   acheck = fabs(0.5*(vol1 - vol2))/(vol1 + vol2);
   if (acheck > tolerance) {
-    printf("Difference in cell volumes detected.\n");
-    printf("  vol1 = %lf  vol2 = %lf \n",vol1,vol2);
+    if (ccp4_liberr_verbosity(-1)) {
+      printf("Difference in cell volumes detected.\n");
+      printf("  vol1 = %lf  vol2 = %lf \n",vol1,vol2);
+    }
     return 1;
   }
 
@@ -299,18 +301,22 @@
   for ( i = 0; i < 6; i++ )
     acheck += fabs(0.5*(cell2[i]-cell1[i]))/(cell2[i]+cell1[i]);
   if (acheck > 3.0*tolerance) {
-    printf("Large difference in cell parameters detected.\n");
-    printf("  cell1 = %lf %lf %lf %lf %lf %lf \n",
-           cell1[0],cell1[1],cell1[2],cell1[3],cell1[4],cell1[5]);
-    printf("  cell2 = %lf %lf %lf %lf %lf %lf \n",
-           cell2[0],cell2[1],cell2[2],cell2[3],cell2[4],cell2[5]);
+    if (ccp4_liberr_verbosity(-1)) {
+      printf("Large difference in cell parameters detected.\n");
+      printf("  cell1 = %lf %lf %lf %lf %lf %lf \n",
+             cell1[0],cell1[1],cell1[2],cell1[3],cell1[4],cell1[5]);
+      printf("  cell2 = %lf %lf %lf %lf %lf %lf \n",
+             cell2[0],cell2[1],cell2[2],cell2[3],cell2[4],cell2[5]);
+    }
     return 1;
   } else if (acheck > tolerance) {
-    printf("Small difference in cell parameters detected.\n");
-    printf("  cell1 = %lf %lf %lf %lf %lf %lf \n",
-           cell1[0],cell1[1],cell1[2],cell1[3],cell1[4],cell1[5]);
-    printf("  cell2 = %lf %lf %lf %lf %lf %lf \n",
-           cell2[0],cell2[1],cell2[2],cell2[3],cell2[4],cell2[5]);
+    if (ccp4_liberr_verbosity(-1)) {
+      printf("Small difference in cell parameters detected.\n");
+      printf("  cell1 = %lf %lf %lf %lf %lf %lf \n",
+             cell1[0],cell1[1],cell1[2],cell1[3],cell1[4],cell1[5]);
+      printf("  cell2 = %lf %lf %lf %lf %lf %lf \n",
+             cell2[0],cell2[1],cell2[2],cell2[3],cell2[4],cell2[5]);
+    }
     return 1;
   }
   return 0;
Index: lib/src/ccp4_unitcell.h
===================================================================
--- lib/src/ccp4_unitcell.h	(revision 2)
+++ lib/src/ccp4_unitcell.h	(revision 16)
@@ -55,6 +55,7 @@
 extern "C" {
 #endif
 
+#include "ccp4_errno.h"
 #include <math.h>
 
 /** From input cell and orthogonalisation code, find orthogonalisation
