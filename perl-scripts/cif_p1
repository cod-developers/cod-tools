#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Expland atoms in CIF to the P1 spacegroup, preserving molecules
#  (i.e. outputing atoms that are bonded at bond distances from each
#  other).
#**

use strict;
use warnings;

use AtomBricks;
use CIFParser;
use CCIFParser;
use CIFTagCanonicalNames;
use SymopParse;
use SymopLookup;
use CIFTagPrint;
use CIFTagManage;
use SOptions;
use SUsage;
use UserMessage;
use Fractional;
use AtomProperties;

my $Id = '$Id$';

my $use_parser = "c";

# Program flags that can be set from options:

my $continue_on_errors = 0;
my $exclude_zero_occupancies = 1; # Do not use atoms with zero
                                  # occupancies

# A distance between two atoms when they are considered to be
# instances of the same atom on a special position:

my $special_position_cutoff = 0.01;

#* USAGE:
#*     $0 --options input1.cif input*.cif
#* 
#* OPTIONS:
#*    --continue-on-errors
#*        Do not stop if errors such as unrecognised atoms are
#*        encountered; the output may be incorrect and missing
#*        some atoms if this otion is used!
#*   
#*    --dont-continue-on-errors, --no-continue-on-errors
#*        Stop immediately when an error is encountered.
#*                       
#*    --exclude-zero-occupancies
#*        Do not use atoms woth 0 occupancies in calculations
#*        (defalut).
#*                       
#*    --dont-continue-on-errors, --no-continue-on-errors
#*        Stop immediately when an error is encountered.
#*                       
#*    --use-perl-parser  Use development CIF parser written in Perl
#*    --use-c-parser     Use faster C/Yacc CIF parser (default)
#*
#*    --help,--usage         Print a short usage message (this message) and exit.
#**

@ARGV = getOptions( 
    "--continue-on-errors" => sub{ $continue_on_errors = 1 },
    "--no-continue-on-errors" => sub{ $continue_on_errors = 0 },
    "--dont-continue-on-errors" => sub{ $continue_on_errors = 0 },

    "--exclude-zero-occupancies"    => sub { $exclude_zero_occupancies = 1; },
    "--no-exclude-zero-occupancies" => sub { $exclude_zero_occupancies = 0; },
    "--dont-exclude-zero-occupancies" => sub { $exclude_zero_occupancies = 0; },

    "--use-perl-parser"  => sub{ $use_parser = "perl" },
    "--use-c-parser"     => sub{ $use_parser = "c" },

    "--options"          => sub { 
        print "$0: The '--options' option is a placehoder.\n";
        print "$0: It should be replaced by one of the following options:\n";
        ## SUsage::usage;
        open( SCRIPT, $0 ) or die $!;
        while( <SCRIPT> ) {
            if( /^#\*\s+OPTIONS:/../^#\*\*/ ) {
                s/^#\*\s+OPTIONS://;
                s/^#\*\*?\s+//;
                print;
            }
        }
        close( SCRIPT );
        exit
    },
    "--help,--usage"     => sub { SUsage::usage; exit },
);

# The "atom" hash structure used by this script:

if( 0 ) {
    my $atom = {
        site_label    => "C1",
        cell_label    => "C1_2",
        name          => "C1_2_436",
        chemical_type => "C",
        coordinates_fract => [ 1.5, 0.22, 1.0 ], # Fractional atom coordinates
        coordinates_ortho => [ 150., 21.7, 50 ], # Orthogonal coordinates
        f2o        => [
            # Othogonalistion matrix used to convert fractional
            # coordinates to orthogonal (Cartesian) ones:
            [ 100,  0,  0 ],
            [   0, 50,  0 ],
            [   0,  0, 30 ]
        ],
        occupancy => 1.0,
        multiplicity => 8,
        assembly => "A", # "."
        group    => "1", # "."
    }
}

# Function prototypes to be checked:

sub unit_cell_from_cif($$);
sub mat_vect_mul($$);
sub symop_strings_from_cif($$);
sub symops_apply_to_atom_modulo1($$);
sub symops_apply_to_atoms_modulo1($$);

@ARGV = ( "-" ) unless @ARGV;

for my $filename (@ARGV) {

    my( $data, $error_count );

    if( $use_parser eq "perl" ) {
        my $parser = new CIFParser;

        $data = $parser->Run( $filename );

        if( defined $parser->YYData->{ERRCOUNT} ) {
            $error_count = $parser->YYData->{ERRCOUNT};
        }
    } else {
        ( $data, $error_count ) = CCIFParser::parse( $filename );
    }

    if( defined $error_count && $error_count > 0 ) {
        print STDERR "$0: ", $error_count,
        " error(s) encountered while parsing file '${filename}'\n";
        die;
    }

    if( !@$data || !defined $data->[0] || !defined $data->[0]{name} ) {
        warn( "file '$filename' seems to be empty" );
        next;
    }

    for my $datablock (@$data) {
        # Build an atom array from the CIF data structure:
        my $atoms = atom_array_from_cif( $datablock, \%AtomProperties::atoms,
                                         $filename );
        my $symop_strings = symop_strings_from_cif( $datablock, $filename );
        my @symops = map { symop_from_string($_) } @{$symop_strings};

        my @unit_cell_atoms =
            symops_apply_to_atoms_modulo1( \@symops, $atoms );

        use Serialise;
        serialiseRef( \@unit_cell_atoms );
    }
}

# End of main program:
exit 0;

# Subroutines:

sub atom_array_from_cif
{
    my ($datablock, $atom_properties, $filename ) = @_;

    my $values = $datablock->{values};
    my $dataname = $datablock->{name};

    # Get the unit cell information and construct the fract->ortho and
    # ortho->fract conversion matrices:

    my @cell = unit_cell_from_cif( $datablock, $filename );
    my $f2o = symop_ortho_from_fract( @cell );

    # Determine which atom site label tag is present and which can be
    # used for identifying atoms:

    my $atom_site_tag;

    if( exists $values->{"_atom_site_label"} ) {
        $atom_site_tag = "_atom_site_label";
    } elsif( exists $values->{"_atom_site_type_symbol"} ) {
        $atom_site_tag = "_atom_site_type_symbol";

        error( $0, $filename, $dataname,
               "_atom_site_label tag was not found. " .
               "A serial number will be appended " .
               "to _atom_site_type_symbol to make atom labels" );
    } else {
        error( $0, $filename, $dataname,
               "neither _atom_site_type_symbol nor _atom_site_label " .
               "were found" );
	return undef;
    }

    my $atom_labels = $values->{$atom_site_tag};

    my @atom_list;

    for (my $i = 0; $i < @{$atom_labels}; $i++)
    {
        if( $exclude_zero_occupancies &&
            defined $values->{_atom_site_occupancy} ) {
            my $occupancy = $values->{_atom_site_occupancy}[$i];
            $occupancy =~ s/\(\d+\)$//; # remove precission
            if( $occupancy eq "?" || $occupancy eq "." ||
                $occupancy == 0.0 ) {
                next;
            }
        }

	my $label;
        if ( $atom_site_tag eq "_atom_site_type_symbol" ) {
	    $label = $values->{$atom_site_tag}[$i] . $i;
	} else {
	    $label = $values->{$atom_site_tag}[$i];
	}

        my $atom = atom_from_cif_values( $label, $values, $i, $f2o );

        if (exists $atom_properties->{ $atom->{"chemical_type"}}) {
            push( @atom_list, $atom );
        } else {
            my $message = "unknown chemical type '" .
                $atom->{chemical_type} . "'";

            if( $continue_on_errors ) {
                warning( $0, $filename, $dataname, $message );
            } else {
                error( $0, $filename, $dataname, $message );
                exit(1);
            }
        }
    }

    return \@atom_list;
}

#===============================================================#
# Extracts atom information from the CIF file.
#
# Accepts
#     values     - a hash where a data from the CIF file is stored
#     atom_label - atom site label or atom site type symbol from the CIF file
#     number     - a number of the current atom
#
# Returns a reference to %atom as described above.

sub atom_from_cif_values
{
    my($atom_label, $values, $number, $f2o) = @_;

    my %atom;
    my @atom_xyz;

    for my $cif_fract ( "_atom_site_fract_x",
                        "_atom_site_fract_y",
                        "_atom_site_fract_z" ) {
        push(@atom_xyz, $values->{$cif_fract}[$number]);
        $atom_xyz[-1] =~ s/\(\d+\)$//;
    }

    @atom_xyz = map { modulo_1($_) } @atom_xyz;

    $atom{coordinates_fract} = \@atom_xyz;
    $atom{name}       = $atom_label;
    $atom{site_label} = $atom_label;

    $atom{f2o} = $f2o;
    $atom{coordinates_ortho} = mat_vect_mul( $f2o, \@atom_xyz );

    my $atom_type;

    if( exists $values->{_atom_site_type_symbol}  &&
        defined $values->{_atom_site_type_symbol}[$number] &&
        $values->{_atom_site_type_symbol}[$number] ne '?' ) {
        $atom_type = $values->{_atom_site_type_symbol}[$number];
        $atom{atom_site_type_symbol} = $atom_type;
        if( $atom_type =~ m/^([A-Za-z]{1,2})/ ) {
            $atom_type = ucfirst( lc( $1 ));
        }
    } else {
        if( $values->{_atom_site_label}[$number] =~
            m/^([A-Za-z]{1,2})/ ) {
            $atom_type = ucfirst( lc( $1 ));
        } else {
            die( "could not determine atom type for atom " .
                 "'$values->{_atom_site_label}[$number]'" );
        }
    }

    $atom{chemical_type} = $atom_type;

    if( exists $values->{_atom_site_disorder_assembly}[$number]) {
        $atom{assembly} =
	    $values->{_atom_site_disorder_assembly}[$number];
    } else {
        $atom{assembly} = ".";
    }

    if( exists $values->{_atom_site_disorder_group}[$number] ) {
        $atom{group} = $values->{_atom_site_disorder_group}[$number];
    } else {
        $atom{group} = ".";
    }

    if( exists $values->{_atom_site_occupancy} ) {
        $atom{atom_site_occupancy} =
            $values->{_atom_site_occupancy}[$number];
    }

    if( exists $values->{_atom_site_U_iso_or_equiv} ) {
        $atom{atom_site_U_iso_or_equiv} =
            $values->{_atom_site_U_iso_or_equiv}[$number];
    }

    if( exists $values->{_atom_site_symmetry_multiplicity} ) {
        $atom{multiplicity} =
            $values->{_atom_site_symmetry_multiplicity}[$number];
    }

    if( exists $values->{_atom_site_attached_hydrogens} ) {
        $atom{attached_hydrogens} =
            $values->{_atom_site_attached_hydrogens}[$number];
    }

    if( exists $values->{_atom_site_refinement_flags} ) {
        $atom{refinement_flags} =
            $values->{_atom_site_refinement_flags}[$number];
    }

    if( exists $values->{_atom_site_refinement_posn} ) {
        $atom{refinement_flags_position} =
            $values->{_atom_site_refinement_posn}[$number];
    }

    if( exists $values->{_atom_site_refinement_adp} ) {
        $atom{refinement_flags_adp} =
            $values->{_atom_site_refinement_adp}[$number];
    }

    if( exists $values->{_atom_site_refinement_occupancy} ) {
        $atom{refinement_flags_occupancy} =
            $values->{_atom_site_refinement_occupancy}[$number];
    }

    return \%atom;
}

#===============================================================#
# Get unit cell angles and lengths.
#
# Accepts
#     datablock - a hash where parsed data from the CIF file are stored
# Returns
#     cell - an array  with stored information.

sub unit_cell_from_cif($$)
{
    my( $datablock, $filename ) = @_;

    my $dataname = $datablock->{name};
    my $values = $datablock->{values};

    my @cell;

    for my $cif_tag (qw(_cell_length_a
                        _cell_length_b
                        _cell_length_c
                        )) {
        push(@cell, $values->{$cif_tag}[0]);
        $cell[-1] =~ s/\(\d+\)$//;
    }

    for my $cif_tag (qw(_cell_angle_alpha
                        _cell_angle_beta
                        _cell_angle_gamma
                        )) {
        if( exists $values->{$cif_tag} ) {
            push( @cell, $values->{$cif_tag}[0] );
            $cell[-1] =~ s/\(\d+\)$//;
        } else {
            warning( $0, $filename, $dataname,
                     "cell angle '$cif_tag' not present -- " .
                     "taking default value 90 degress." );
            push( @cell, 90 );
        }
    }

    return @cell;
}

#===============================================================#
# Multiplies an ortho matrix with a vector.

# my $matrix = [
#     [ m11 m12 m13 m14 ],
#     [ m21 m22 m23 m24 ],
#     [ m31 m32 m33 m34 ],
#     [ m41 m42 m43 m44 ]
# ]

# Which, as a rule, will have the following layout:

# my $symop_matrix = [
#     [ r11 r12 r13 t1 ],
#     [ r21 r22 r23 t2 ],
#     [ r31 r32 r33 t3 ],
#     [   0   0   0  1 ]
# ]

# Or:

# my $matrix = [
#     [ r11 r12 r13 ],
#     [ r21 r22 r23 ],
#     [ r31 r32 r33 ],
#     [ t1  t2  t3  ]
# ]

sub mat_vect_mul($$)
{
    my($matrix, $vector) = @_;

    my @new_coordinates;

    for(my $i = 0; $i < @{$vector}; $i++) {
        $new_coordinates[$i] = 0;
        for(my $j = 0; $j < @{$vector}; $j++) {
            $new_coordinates[$i] += ${$matrix}[$i][$j] * ${$vector}[$j];
        }
    }

    if( @$vector == 3 && @$matrix == 4 ) {
        $new_coordinates[0] += $matrix->[0][3];
        $new_coordinates[1] += $matrix->[1][3];
        $new_coordinates[2] += $matrix->[2][3];
    }

    return wantarray ? @new_coordinates : \@new_coordinates;
}

#===========================================================================
# Extract symmetry operators from a parsed CIF datablock
#
# Returns a list of symmetry operators as ASCII strings with generap
# position formulae (e.g. -y,-x,z+1/2).

sub symop_strings_from_cif($$)
{
    my ($dataset, $filename) = @_;
    my $values = $dataset->{values};
    my $sym_data;

    if( exists $values->{"_space_group_symop_operation_xyz"} ) {
        $sym_data = $values->{"_space_group_symop_operation_xyz"};
    } elsif( exists $values->{"_symmetry_equiv_pos_as_xyz"} ) {
        $sym_data = $values->{"_symmetry_equiv_pos_as_xyz"};
    }

    if( exists $values->{"_space_group_name_Hall"} &&
        not defined $sym_data ) {
        my $hall = $values->{"_space_group_name_Hall"}[0];
        $sym_data = get_library_symops("hall", $hall);

        if( !defined $sym_data ) {
            error( $0, $filename, $dataset->{name},
                   "incorrect _space_group_name_Hall '$hall'" );
        }
    } elsif( exists $values->{"_symmetry_space_group_name_Hall"} &&
             not defined $sym_data ) {
        my $hall = $values->{"_symmetry_space_group_name_Hall"}[0];
        $sym_data = get_library_symops("hall", $hall);

        if( !defined $sym_data ) {
            error( $0, $filename, $dataset->{name},
                   "incorrect _symmetry_space_group_name_Hall '$hall'" );
        }
    }

    if( exists $values->{"_space_group_name_H-M_alt"} &&
       not defined $sym_data) {
        my $h_m = $values->{"_space_group_name_H-M_alt"}[0];
        $sym_data = get_library_symops("hermann_mauguin", $h_m);

        if( !defined $sym_data ) {
            error( $0, $filename, $dataset->{name},
                   "incorrect _space_group_name_H-M_alt '$h_m'" );
        }
    } elsif( exists $values->{"_symmetry_space_group_name_H-M"} &&
            not defined $sym_data) {
        my $h_m = $values->{"_symmetry_space_group_name_H-M"}[0];
        $sym_data = get_library_symops("hermann_mauguin", $h_m);

        if( !defined $sym_data ) {
            error( $0, $filename, $dataset->{name},
                   "incorrect _symmetry_space_group_name_H-M '$h_m'" );
        }
    }

    return $sym_data;
}

#===============================================================#
# Gets symmetry operators if they are not directly represented in the CIF file.

# Accepts
#     option - an option, for example, "hall"
#     param  - according to an option a value given in the CIF file

# Uses @SymopLookup::table =
# (
# {
#     number          => 1,
#     hall            => ' P 1',
#     schoenflies     => 'C1^1',
#     hermann_mauguin => 'P 1',
#     universal_h_m   => 'P 1',
#     symops => [
#         'x,y,z',
#     ],
#     ncsym => [
#         'x,y,z',
#     ]
# },
# );

# Return a reference to symmetry operators.

sub get_library_symops
{
    my ($option, $param) = @_;

    $param =~ s/ //g;
    $param =~ s/_//g;

    foreach my $hash (@SymopLookup::table) {
        my $value = $hash->{$option};
        $value =~ s/ //g;
        $value =~ s/_//g;

        if($value eq $param) {
            return $hash->{symops};
        }
    }
    return undef;
}

#===============================================================#
# Generate symmetry equivalents of an atom, evaluate atom's
# multiplicity and multiplicity ratio

sub symops_apply_modulo1
{
    my ( $atom, $sym_operators ) = @_;

    my @sym_atoms;
    my @symops_mapping_to_self;
    my $gp_multiplicity = int(@$sym_operators);

    my $multiplicity_ratio = 1;

    do {
        use Serialise;
        serialiseRef( $sym_operators );
    } if 0;

    my $n = 1;

    for my $symop ( @{$sym_operators} ) {
        my $new_atom = symop_apply_modulo1( $atom, $symop, $n++ );
        if( !symop_is_unity( $symop ) &&
            atoms_coincide( $atom, $new_atom, $atom->{f2o} )) {
            push( @symops_mapping_to_self, $symop );
            $multiplicity_ratio ++;
        } else {
            push( @sym_atoms, $new_atom );
        }
    }

    ## print ">>> $gp_multiplicity / $multiplicity_ratio\n";

    if( $gp_multiplicity % $multiplicity_ratio ) {
        die( "Multiplicity ratio $multiplicity_ratio does not divide " .
             "multiplicity of a general position $gp_multiplicity" .
             "-- this can not be." );
    }

    my $multiplicity = $gp_multiplicity / $multiplicity_ratio;

    for my $atom (@sym_atoms) {
        $atom->{multiplicity} = $multiplicity;
        $atom->{multiplicity_ratio} = $multiplicity_ratio;
        $atom->{site_symops} = \@symops_mapping_to_self;
    }

    return ( \@sym_atoms, $multiplicity, $multiplicity_ratio );
}

#===============================================================#
# Applies symmetry operator to a given atom.

# The symop_apply_modulo1 subroutine accepts a reference to a hash
# $atom_info -- as above, and a refernce to an array - symmetry
# operator:

# my $symop = [
#     [ r11 r12 r13 t1 ]
#     [ r21 r22 r23 t2 ]
#     [ r31 r32 r33 t3 ]
#     [   0   0   0  1 ]
# ],

# Returns an above-mentioned hash.

sub symop_apply_modulo1
{
    my($atom, $symop, $symop_id) = @_;

    my $new_atom = copy_atom( $atom );

    my $atom_xyz = $atom->{coordinates_fract};

    my @new_atom_xyz =
        map { modulo_1($_) }
        mat_vect_mul( $symop, $atom_xyz );

    $new_atom->{coordinates_fract} = \@new_atom_xyz;
    $new_atom->{coordinates_ortho} = mat_vect_mul( $atom->{f2o}, \@new_atom_xyz );

    return symop_register_applied_symop( $new_atom, $symop, $symop_id );
}

sub symop_register_applied_symop
{
    my($new_atom_info, $symop, $symop_id) = @_;

    $new_atom_info->{symop} = $symop;
    $new_atom_info->{symop_id} = $symop_id;
    $new_atom_info->{unity_matrix_applied} = symop_is_unity($symop);

    my $atom_xyz = $new_atom_info->{coordinates_fract};
    my @translation = (
        int($atom_xyz->[0] - modulo_1($atom_xyz->[0])),
        int($atom_xyz->[1] - modulo_1($atom_xyz->[1])),
        int($atom_xyz->[2] - modulo_1($atom_xyz->[2])),
    );
    $new_atom_info->{translation} =
        \@translation;
    $new_atom_info->{translation_id} =
        (5+$translation[0]) . (5+$translation[1]) . (5+$translation[2]);

    if( $new_atom_info->{unity_matrix_applied} &&
        $new_atom_info->{translation_id} eq "555" ) {
        $new_atom_info->{name} = $new_atom_info->{site_label};
    } else {
        $new_atom_info->{name} =
            $new_atom_info->{site_label} . "_" .
            $new_atom_info->{symop_id} . "_" .
            $new_atom_info->{translation_id};
    }

    do {
        use Serialise;
        serialiseRef( { atom => $new_atom_info, symop => $symop } );
    } if 0;

    return $new_atom_info;
}

#===============================================================#
# Generate symmetry equivalents of an atom, exclude duplicates
# on special positions

sub symops_apply_to_atom_modulo1($$)
{
    my ( $atom, $sym_operators ) = @_;

    my( $sym_atoms, $multiplicity, $multiplicity_ratio ) =
        symops_apply_modulo1( $atom, $sym_operators, $atom->{f2o} );

    if( $multiplicity_ratio == 1 ) {
        return @$sym_atoms;
    } else {
        my @unique_atoms;
        my %to_be_deleted;
        for my $i (0..$#$sym_atoms-1) {
            for my $j ($i+1..$#$sym_atoms) {
                if( distance( $sym_atoms->[$i]{coordinates_fract},
                              $sym_atoms->[$j]{coordinates_fract}) < 0.0001 ) {
                    $to_be_deleted{$sym_atoms->[$j]{name}} = 1;
                }
            }
        }
        for my $atom (@$sym_atoms) {
            if( !defined $to_be_deleted{$atom->{name}} ) {
                push( @unique_atoms, $atom );
            }
        }
        return @unique_atoms;
    }
}

#===============================================================#
# Generate symmetry equivalents of all atoms from a list, exclude
# duplicates on special positions

sub symops_apply_to_atoms_modulo1($$)
{
    my ( $sym_operators, $atoms ) = @_;

    my @sym_atoms = ();

    for my $atom (@{$atoms}) {
        push( @sym_atoms,
              symops_apply_to_atom_modulo1( $atom, $sym_operators ));
    }

    return \@sym_atoms;
}

#===============================================================#
# Copies atom and returns the same instance of it (different object, same props)

sub copy_atom
{
    my($old_atom) = @_;

    if( ref $old_atom ne "HASH" ) {
        use Carp;
        croak;
    }

    return copy_struct_deep($old_atom);
}

# Performs deep copying of structure passed via reference

sub copy_struct_deep
{
    my($struct) = @_;
    return $struct if !ref $struct;
    return [ map( copy_struct_deep($_), @$struct ) ] if ref $struct eq "ARRAY";
    return { map{ $_ => copy_struct_deep( $struct->{$_} ) } keys %$struct }
        if ref $struct eq "HASH";
    die( "deep copy failed: 'copy_struct_deep' does not know how to " .
         "copy object '" . ref( $struct ) . "'" );
}

#===============================================================#
# Tests if a symmetry operator is   (1, 0, 0)
#                                   (0, 1, 0)
#                                   (0, 0, 1)

sub symop_is_unity
{
    my($symop) = @_;
    my $eps = 1e-10;

    for(my $i = 0; $i < @{$symop}; $i++) {
        for(my $j = 0; $j < @{$symop}; $j++) {
            if($i == $j) {
                if(abs(${$symop}[$i][$j] - 1) > $eps) {
                    return 0;
                }
            } else {
                if(abs(${$symop}[$i][$j] - 0) > $eps) {
                    return 0;
                }
            }
        }
    }
    return 1;
}

#===============================================================#
# Checks whether atoms are in the same point in space:

sub atoms_coincide($$$)
{
    my ( $old_atom, $new_atom, $f2o ) = @_;

    my $old_coord = [ map { modulo_1($_) } @{$old_atom->{coordinates_fract}} ];
    my $old_xyz = mat_vect_mul( $f2o, $old_coord );

    my $new_coord = [ map { modulo_1($_) } @{$new_atom->{coordinates_fract}} ];

    for my $dx (-1, 0, 1) {
    for my $dy (-1, 0, 1) {
    for my $dz (-1, 0, 1) {
        my $shifted_coord = [
            $new_coord->[0] + $dx,
            $new_coord->[1] + $dy,
            $new_coord->[2] + $dz,
        ];
        my $new_xyz = mat_vect_mul( $f2o, $shifted_coord );
        if( distance( $new_xyz, $old_xyz ) < $special_position_cutoff ) {
            ## local $, = ", ";
            ## print ">>> mapped to self: @{$new_xyz} / @{$old_xyz}\n";
            return 1;
        }
    }}}

    return 0;
}

#===============================================================#
# Calculates distance between two given vectors.

# Accepts two arrays of vectors coordinates_fract.

# Returns a distance.

sub distance
{
    my($vector1, $vector2) = @_;
    my $dist = 0;

    for(my $k = 0; $k < @{$vector1}; $k++) {
        $dist += (${$vector1}[$k] - ${$vector2}[$k])**2;
    }
    return sqrt($dist);
}
