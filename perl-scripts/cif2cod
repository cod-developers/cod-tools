#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Parse a CIF file, prepare a COD database table entry from it.
#**

use strict;
use lib "./lib/perl5";
use lib "./CIFParser";
use CIFParser;
use Spacegroups::SpacegroupNames;
use CIFData::CIFCellContents;
use CIFData::CIF2COD;
use Unicode2CIF;
use SOptions;
use SUsage;

my $print_header = 0;
    # Indicates whether to print out a header with column names
my $print_keywords = 0;

my %options;

#* Usage:
#*     cif2cod-new [options] input.cif [input2.cif ...]
#*
#* Options:
#*     -C, --cod-number 1000000
#*         Use the specified number, 1000000 in this example, as
#*         a COD number for this structure; do not take the number
#*         from the datablock name.
#*
#*     -c, --continue-on-errors
#*         Continue processing and return successful return status
#*         even if errors are diagnosed.
#*
#*     -c-, --dont-continue-on-errors, --no-continue-on-errors
#*         Stop and return error status if errors are diagnosed.
#*
#*     -h, --print-header
#*         Print header with data column names at the first line
#*         With this option cif2cod-new loads CIF data to the new
#*         sql talble data fields
#*
#*     -h-, --dont-print-header, --no-print header
#*         Do not print column names on the first (header) line (default).
#*
#*     -k, --keywords
#*         Print values in separate lines prefixed with keywords.
#*
#*     --help  print a short usage message (this message) and exit.
#**

@ARGV = getOptions(

    "-C,--cod-number" => \$options{cod_number},

    "-c,--continue-on-errors"     => sub { $options{continue_on_errors} = 1 },
    "-c-,--no-continue-on-errors" => sub { $options{continue_on_errors} = 0 },
    "--dont-continue-on-errors"   => sub { $options{continue_on_errors} = 0 },
    "--exit-on-errors"            => sub { $options{continue_on_errors} = 0 },

    "-h,--print-header"       => sub { $print_header = 1 },
    "-h-,--dont-print-header" => sub { $print_header = 0 },
    "--no-print-header"       => sub { $print_header = 0 },

    "-k,--keywords"   => sub { $print_keywords = 1 },

    "--reformat-space-group" =>
            sub { $options{reformat_spacegroup} = 1; },
    "--dont-reformat-space-group" =>
            sub { $options{reformat_spacegroup} = 0; },
    "--leave-space-space-group" =>
            sub { $options{reformat_spacegroup} = 0; },

    "--use-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 1 },
    "--use-all-datablocks"
        => sub{ $options{use_datablocks_without_coord} = 1 },

    "--do-not-use-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 0 },
    "--dont-use-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 0 },
    "--no-use-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 0 },
    "--skip-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 0 },

    "--help,--usage"  => sub { SUsage::usage; exit },
);

sub error
{
    my ( $message, $filename, $dataset, $explanation ) = @_;

    print STDERR $0, ": ";
    print STDERR $filename
        if $filename;
    print STDERR " ",  $dataset->{name}
        if $dataset && exists $dataset->{name};
    print STDERR ": "
        if $filename || $dataset;
    print STDERR $message
        if defined $message;
    print STDERR "\n", $explanation
        if defined $explanation;
    print STDERR "\n";

    die unless $options{continue_on_errors};
}

binmode( STDOUT, ":utf8" );

if( $print_header ) {
    local $\ = "\n";
    if( $print_keywords ) {
        local $, = " ";
        print @CIF2COD::new_data_fields;
    } else {
        local $, = ";";
        print @CIF2COD::new_data_fields;
    }
}

@ARGV = ( "-" ) unless @ARGV;

for my $filename (@ARGV) {

    my $parser = new CIFParser;
    my $data = $parser->Run($filename);

    if( defined $parser->YYData->{ERRCOUNT} &&
        $parser->YYData->{ERRCOUNT} > 0 ) {
        error( $parser->YYData->{ERRCOUNT} .
               " error(s) encountered while parsing" );
    }

    my $extracted = CIF2COD::cif2cod( $data, $filename, \%options );

    for my $data (@$extracted) {
        my %data = %$data;

        # Print out the collected data fields:
        
        my @data_fields = @CIF2COD::default_data_fields;
        if( $print_header ) {
            @data_fields = @CIF2COD::new_data_fields;
        }
        if( $print_keywords ) {
            my $separator = " ";
            for my $key (@data_fields) {
                my $value = $data{$key};
                if( defined $value ) {
                    # remove trailing dot from numbers:
                    $value =~ s/^\s*(\d+)\.\s*$/$1/;
                    print $key . $separator . $value . "\n";
                }
            }
        } else {
            my $separator = "";
            for my $key (@data_fields) {
                my $value = $data{$key};
                if( defined $value ) {
                    # remove trailing dot from numbers:
                    $value =~ s/^\s*(\d+)\.\s*$/$1/;
                    if( $key ne "text" ) {
                        $value =~ s/\\/\\\\/g;
                        $value =~ s/"/\\"/g;
                    }
                    $value = "\"" . $value . "\"";
                } else {
                    $value = "NULL";
                }
                print $separator, $value;
                $separator = ";";
            }
            print "\n";
        }
    }
}
