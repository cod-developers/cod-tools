#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Marks disorder in CIF files judging by distance and occupancy.
#**

use strict;
use warnings;
use AtomBricks;
use AtomProperties;
use CIFParser;
use CCIFParser;
use CIFTagCanonicalNames;
use CIFTagManage;
use CIFTagPrint;
use Fractional;
use UserMessage;
use SOptions;

sub initial_atoms($$$$$$);
sub mat_vect_mul($$);
sub get_unit_cell($$$);
sub uniquify_atom_names($$$$);

my $same_site_distance_sensivity = 0.000001;
my $same_site_occupancy_sensivity = 0.01;
my $brick_size = 1;
my $cif_header_file;
my $use_parser = "c";
my $uniquify_atoms = 1;
my $exclude_zero_occupancies = 1;
my $continue_on_errors = 0;
my $report_marked_disorders = 1;

@ARGV = getOptions
(
    "-h,--add-cif-header" => \$cif_header_file,

    "--report-marked-disorders" => sub { $report_marked_disorders = 1 },
    "--no-report-marked-disorders" =>
        sub { $report_marked_disorders = 0 },
    "--dont-report-marked-disorders" =>
        sub { $report_marked_disorders = 0 },
);

my $cif_header;

if( $cif_header_file ) {
    open( HDR, "$cif_header_file" ) or
        die( "$0: could not open header file '$cif_header_file' " .
             "for input - $!" );

    $cif_header = "";
    while( <HDR> ) {
        last unless /^#/;
        $cif_header .= $_;
    }

    close( HDR ) or
        die( "$0: error reading header file '$cif_header_file' - $!" );
}

@ARGV = ("-") unless @ARGV;

for my $filename (@ARGV) {
    my $data;
    if( $use_parser eq "perl" ) {
        my $parser = new CIFParser;
        $data = $parser->Run($filename);
    } else {
        $data = CCIFParser::parse($filename);
    }

    canonicalize_all_names( $data );

    print $cif_header if $cif_header;
    for my $dataset (@$data) {
        # extracts atom site label or atom site type symbol
        my $values = $dataset->{values};
        my $dataname = $dataset->{name};
        
        # Get cell angles(alpha, beta, gama) and lengths(a, b, c)
        my @cell = get_unit_cell( $values, $filename, $dataname );

        # Make a matric to convert from fractional coordinates to
        # orthogonal:
        my $f2o = symop_ortho_from_fract(@cell);

        # Extract atoms fract coordinates
        my $atom_list = initial_atoms( \%AtomProperties::atoms,
                                       $dataset,
                                       $filename,
                                       $dataname,
                                       $f2o,
                                       $uniquify_atoms );

        my $bricks = AtomBricks::build_bricks( $atom_list,
                                               $brick_size );

        my $alternatives = get_alternatives( $atom_list,
                                             $bricks,
                                             $filename,
                                             $dataname,
                                             $f2o );

        my $last_assembly;
        my $assembly_count = 1;
        my $rename_dot_assembly = 0;
        if( exists $values->{_atom_site_disorder_assembly} ) {
            my %assemblies =
                map  {$_->{assembly} => 1}
                grep {$_->{group} ne '.' || $_->{assembly} ne '.'}
                     @$atom_list;
            $assembly_count = scalar keys %assemblies;
            $rename_dot_assembly =
                (exists $assemblies{'.'} && $assembly_count > 1) ? 1 : 0;
            my @assemblies = sort keys %assemblies;
            $last_assembly = $assemblies[-1];
        }
        if( defined $last_assembly && $rename_dot_assembly ) {
            $last_assembly = chr( ord( $last_assembly ) + 1 );
        }
        my $first_assembly;
        if( defined $last_assembly ) {
            $first_assembly = chr( ord( $last_assembly ) + 1 );
        } else {
            $first_assembly = 'A';
        }

        if( $rename_dot_assembly ) {
            note( $0, $filename, $dataname,
                  "disorder assembly '.' was renamed to 'A'" );
        }

        my @assemblies;
        my @groups;
        for my $atom (@$atom_list) {
            my $name = $atom->{name};
            if( exists $alternatives->{$name} ) {
                push( @assemblies,
                      chr( ord( $first_assembly ) +
                                $alternatives->{$name}[0] ) );
                push( @groups, $alternatives->{$name}[1] );
            } elsif( exists $atom->{assembly} &&
                     exists $atom->{group} &&
                     $atom->{assembly} ne '.' ) {
                if( $rename_dot_assembly ) {
                    push( @assemblies,
                          chr( ord( $atom->{assembly} ) + 1 ) );
                } else {
                    push( @assemblies, $atom->{assembly} );
                }
                push( @groups, $atom->{group} );
            } elsif( $rename_dot_assembly &&
                     exists $atom->{assembly} &&
                     exists $atom->{group} &&
                     $atom->{assembly} eq '.' &&
                     $atom->{group} ne '.' ) {
                push( @assemblies, 'A' );
                push( @groups, $atom->{group} );
            } else {
                push( @assemblies, '.' );
                push( @groups, '.' );
            }
        }

        my $assembly_count_now = scalar keys { map { $_ => 1 } @assemblies };
        my $assembly_count_diff = $assembly_count_now - $assembly_count;
        if( $assembly_count_diff > 0 ) {
            note( $0, $filename, $dataname,
                  "$assembly_count_diff site(s) were marked " .
                  "as disorder assemblies" );
        }

        my $atom_site_tag;

        if( exists $values->{"_atom_site_label"} ) {
            $atom_site_tag = "_atom_site_label";
        } else {
            $atom_site_tag = "_atom_site_type_symbol";
        }

        set_loop_tag( $dataset,
                      '_atom_site_disorder_assembly',
                      $atom_site_tag,
                      \@assemblies );
        set_loop_tag( $dataset,
                      '_atom_site_disorder_group',
                      $atom_site_tag,
                      \@groups );

        print_cif( $dataset,
                   {
                        preserve_loop_order => 1,
                        keep_tag_order => 1
                   }
                 );
    }
}

sub get_alternatives
{
    my( $atom_list, $bricks, $filename, $dataname, $f2o ) = @_;
    my %alternatives;
    my $count = 0;

    for my $current_atom (@$atom_list) {
        my $atom_in_unit_cell_coords_ortho =
            mat_vect_mul( $f2o, $current_atom->{coordinates_fract} );

        my ($i, $j, $k) =
            AtomBricks::get_atom_index( $bricks,
                                @{$atom_in_unit_cell_coords_ortho});

        my( $min_i, $max_i, $min_j, $max_j, $min_k, $max_k ) =
                AtomBricks::get_search_span( $bricks, $i, $j, $k );

        my $name1 = $current_atom->{name};
        my $index1 = $current_atom->{index};

        for $i ($min_i .. $max_i) {
        for $j ($min_j .. $max_j) {
        for $k ($min_k .. $max_k) {
            for my $atom ( @{$bricks->{atoms}[$i][$j][$k]} ) {
                my $atom_coords_ortho = $atom->{coordinates_ortho};
                my $name2 = $atom->{name};

                next if $name1 ge $name2;

                my $dist = distance( $atom_in_unit_cell_coords_ortho,
                                     $atom_coords_ortho );
                next if $dist > $same_site_distance_sensivity;

                # Skipping atom pairs whose occupancies do not sum
                # to approx. 1:
                if( exists $current_atom->{atom_site_occupancy} &&
                    exists $atom->{atom_site_occupancy} &&
                    abs( $current_atom->{atom_site_occupancy} +
                         $atom->{atom_site_occupancy} - 1 ) >
                    $same_site_occupancy_sensivity ) {

                    my $occupancy_sum =
                        $current_atom->{atom_site_occupancy} +
                        $atom->{atom_site_occupancy};
                    warning( $0, $filename, $dataname,
                             "atoms '$name1' and '$name2' share " .
                             "same site, but the sum of their " .
                             "occupancies is $occupancy_sum" );
                    next;
                }

                # Skipping already marked disordered atoms:
                if( exists $current_atom->{assembly} &&
                    exists $atom->{assembly} &&
                    $current_atom->{assembly} eq $atom->{assembly} &&
                    exists $current_atom->{group} &&
                    exists $atom->{group} &&
                    $current_atom->{group} ne $atom->{group} ) {
                    next;
                }

                if( exists $alternatives{$name1} ||
                    exists $alternatives{$name2} ) {
                    error( $0, $filename, $dataname,
                           "atoms '$name1' and '$name2' share " .
                           "same site, but one of both of them " .
                           "are already assigned to other " .
                           "disorder assembly (assemblies) -- " .
                           "site contains more than two " .
                           "alternatives?" );
                    next;
                }

                if( $report_marked_disorders ) {
                    note( $0, $filename, $dataname,
                          "atoms '$name1' and '$name2' were marked " .
                          "as alternatives" );
                }

                my $index2 = $atom->{index};
                $alternatives{$name1} = [ $count,
                                          (($index1 <=> $index2) + 1) / 2 + 1 ];
                $alternatives{$name2} = [ $count,
                                          (($index2 <=> $index1) + 1) / 2 + 1 ];
                $count++;
            }
        }}}
    }

    return \%alternatives;
}

# ============================================================================ #
# Gets atom descriptions, as used in this program, from a CIF datablock.
#
# Returns an array of
#
#   $atom_info = {
#                   site_label=>"C1",
#                   name=>"C1_2",
#                   chemical_type=>"C",
#                   atom_site_type_symbol = "C",
#                   coordinates_fract=>[1.0, 1.0, 1.0],
#                   unity_matrix_applied=>1,
#                   assembly=>"A", # "."
#                   group=>"1", # "."
#                   multiplicity=>"1",
#                   multiplicity_ratio=>"1",
#              }
#
sub initial_atoms($$$$$$)
{
    my ($atom_properties, $dataset, $filename, $dataname, $f2o,
    	$uniquify_atoms ) = @_;
    my $values = $dataset->{values};

    my $atom_site_tag;

    if( exists $values->{"_atom_site_label"} ) {
        $atom_site_tag = "_atom_site_label";
    } elsif( exists $values->{"_atom_site_type_symbol"} ) {
        $atom_site_tag = "_atom_site_type_symbol";

        error( $0, $filename, $dataset->{name},
               "_atom_site_label tag was not found. " .
               "A serial number will be appended " .
               "to _atom_site_type_symbol to make atom labels" );
    } else {
        die( "neither _atom_site_type_symbol nor _atom_site_label " .
             "were found" );
    	return undef;
    }

    my $atom_labels = $values->{$atom_site_tag};

    my @atom_list;

    for (my $i = 0; $i < @{$atom_labels}; $i++)
    {
        if( $exclude_zero_occupancies &&
            defined $values->{_atom_site_occupancy} ) {
            my $occupancy = $values->{_atom_site_occupancy}[$i];
            $occupancy =~ s/\(\d+\)$//; # remove precission
            if( $occupancy eq "?" || $occupancy eq "." ||
                $occupancy == 0.0 ) {
                next;
            }
        }

	    my $label;
        if ( $atom_site_tag eq "_atom_site_type_symbol" ) {
	        $label = $values->{$atom_site_tag}[$i] . $i;
	    } else {
	        $label = $values->{$atom_site_tag}[$i];
	    }

        my $atom_info = extract_atom( $label, $values, $i, $f2o );

        if (exists $atom_properties->{ $atom_info->{"chemical_type"}}) {
            push( @atom_list, $atom_info );
        } else {
            my $message = "unknown chemical type '" .
                $atom_info->{chemical_type} . "'";

            if( $continue_on_errors ) {
                warning( $0, $filename, $dataname, $message );
            } else {
                error( $0, $filename, $dataname, $message );
                exit(1);
            }
        }
    }

    return uniquify_atom_names( \@atom_list, $uniquify_atoms,
				$filename, $dataname);
}

#===============================================================#
# Extracts atom information from the CIF file.
#
# Accepts
#     values     - a hash where a data from the CIF file is stored
#     atom_label - atom site label or atom site type symbol from the CIF file
#     number     - a number of the current atom
#
# Returns a hash $atom:{
#                       label=>"C1",
#                       site_label=>"C1";
#                       chemical_type=>"C",
#                       atom_site_type_symbol = "C",
#                       coordinates_fract=>[1.0, 1.0, 1.0],
#                       unity_matrix_applied=>1,
#                       transform_matrices=>[ [
#                           [ 1, 0, 0, 0 ],
#                           [ 0, 1, 0, 0 ],
#                           [ 0, 0, 1, 0 ],
#                           [ 0, 0, 0, 1 ] ] ],
#                       assembly=>"A", # "."
#                       group=>"1", # "."
#                       }

sub extract_atom
{
    my($atom_label, $values, $number, $f2o) = @_;

    my %atom_info;
    my @atom_xyz;

    for my $cif_fract ( "_atom_site_fract_x",
                        "_atom_site_fract_y",
                        "_atom_site_fract_z",)
    {
        push(@atom_xyz, $values->{$cif_fract}[$number]);
        $atom_xyz[-1] =~ s/\(\d+\)$//;
    }

    $atom_info{"index"}                 = $number;
    $atom_info{"coordinates_fract"}     = \@atom_xyz;
    $atom_info{"name"}                  = $atom_label;
    $atom_info{"site_label"}            = $atom_label;

    $atom_info{coordinates_ortho} =
        mat_vect_mul( $f2o, \@atom_xyz );

    my $atom_type;

    if( exists $values->{_atom_site_type_symbol}  &&
        defined $values->{_atom_site_type_symbol}[$number] &&
        $values->{_atom_site_type_symbol}[$number] ne '?' ) {
        $atom_type = $values->{_atom_site_type_symbol}[$number];
        $atom_info{atom_site_type_symbol} = $atom_type;
        if( $atom_type =~ m/^([A-Za-z]{1,2})/ ) {
            $atom_type = ucfirst( lc( $1 ));
        }
    } else {
        if( $values->{_atom_site_label}[$number] =~
            m/^([A-Za-z]{1,2})/ ) {
            $atom_type = ucfirst( lc( $1 ));
        } else {
            die( "could not determine atom type for atom " .
                 "'$values->{_atom_site_label}[$number]'" );
        }
    }

    $atom_info{chemical_type} = $atom_type;

    if( exists $values->{_atom_site_disorder_assembly} ) {
        $atom_info{assembly} =
	    $values->{_atom_site_disorder_assembly}[$number];
    } else {
        $atom_info{assembly} = ".";
    }

    if( exists $values->{_atom_site_disorder_group} ) {
        $atom_info{group} = $values->{_atom_site_disorder_group}[$number];
    } else {
        $atom_info{group} = ".";
    }

    if( exists $values->{_atom_site_occupancy} ) {
        $atom_info{atom_site_occupancy} =
            $values->{_atom_site_occupancy}[$number];
    }

    return \%atom_info;
}

#===============================================================#
# Extract unit cell angles and lengths.
#
# Accepts
#     values - a hash where a data from the CIF file is stored
# Returns
#     cell - an array  with stored information.

sub get_unit_cell($$$)
{
    my( $values, $filename, $dataname ) = @_;

    my @cell;

    for my $cif_tag (qw(_cell_length_a
                        _cell_length_b
                        _cell_length_c
                        ))
    {
        push(@cell, $values->{$cif_tag}[0]);
        $cell[-1] =~ s/\(\d+\)$//;
    }

    for my $cif_tag (qw(_cell_angle_alpha
                        _cell_angle_beta
                        _cell_angle_gamma
                        ))
    {
        if( exists $values->{$cif_tag} ) {
            push( @cell, $values->{$cif_tag}[0] );
            $cell[-1] =~ s/\(\d+\)$//;
        } else {
            warning( $0, $filename, $dataname,
                     "cell angle '$cif_tag' not present -- " .
                     "taking default value 90 degress." );
            push( @cell, 90 );
        }
    }

    return @cell;
}

# ============================================================================ #
# Accepts an array of
#
#   $atom_info = {
#                   site_label=>"C1",
#                   name=>"C1_2",
#                   chemical_type=>"C",
#                   coordinates_fract=>[1.0, 1.0, 1.0],
#                   unity_matrix_applied=>1,
#                   assembly=>"A", # "."
#                   group=>"1", # "."
#              }
#
sub uniquify_atom_names($$$$)
{
    my ($init_atoms, $uniquify_atoms, $filename, $dataset_name) = @_;

    my $max_label_suffix = 30000; # Maximum number to be appened to labels 
                                  # when trying to produce unique names.

    my @checked_initial_atoms;

    my %used_labels;
    my @labels_to_be_renamed;

    foreach my $atom (@{$init_atoms})
    {
        my $atom_copy = copy_atom( $atom );
        my $label = $atom->{name};

        push( @checked_initial_atoms, $atom_copy );

        if( ! exists $used_labels{$label} ) {
            $used_labels{$label}{atoms} = [ $atom_copy ];
        } else {
            push( @{$used_labels{$label}{atoms}}, $atom_copy );
            warning( $0, $filename, $dataset_name,
                     "atom label '$label' is not unique" );
            push( @labels_to_be_renamed, $label );
        }
        $used_labels{$label}{count} ++;
    }

    if( $uniquify_atoms )
    {
        foreach my $label (@labels_to_be_renamed)
        {
            foreach my $renamed_atom (@{$used_labels{$label}{atoms}}) {
                my $id = 0;
                while( exists $used_labels{$label . "_" .$id} &&
                       $id <= $max_label_suffix ) {
                    $id ++;
                }
                if( $id > $max_label_suffix ) {
                    error( $0, $filename, $dataset_name,
                           "could not generate unique atom name for ".
                           "atom '$label', even after $id iterations" );
                }
                my $new_label = $label . "_" . $id;
                warning( $0, $filename, $dataset_name,
                         "renaming atom '$label' " .
                         "to '" . $new_label . "'" );
                $renamed_atom->{name}       = $new_label;
                $renamed_atom->{site_label} = $new_label;
                $used_labels{$new_label}{count} ++;
            }
        }
    }

    return \@checked_initial_atoms;
}

#===============================================================#
# Copies atom and returns the same instance of it (different object, same props)

# Accepts a hash $atom_info = {
#                       name=>"C1_2",
#                       site_label=>"C1",
#                       chemical_type=>"C",
#                       coordinates_fract=>[1.0, 1.0, 1.0],
#                       coordinates_ortho=>[5.0, -1.3, 1.7],
#                       transform_matrices=>[ [
#                           [ 1, 0, 0, 0 ],
#                           [ 0, 1, 0, 0 ],
#                           [ 0, 0, 1, 0 ],
#                           [ 0, 0, 0, 1 ] ] ],
#                       unity_matrix_applied=>1,
#                       symop_id=>1
#                       assembly=>"A", # "."
#                       group=>"1", # "."
#                       }

# Returns a hash $new_atom_info = {
#                       name=>"C1_2",
#                       site_label=>"C1",
#                       chemical_type=>"C",
#                       coordinates_fract=>[1.0, 1.0, 1.0],
#                       coordinates_ortho=>[5.0, -1.3, 1.7],
#                       transform_matrices=>[ [
#                           [ 1, 0, 0, 0 ],
#                           [ 0, 1, 0, 0 ],
#                           [ 0, 0, 1, 0 ],
#                           [ 0, 0, 0, 1 ] ] ],
#                       unity_matrix_applied=>1,
#                       symop_id=>1,
#                       assembly=>"A", # "."
#                       group=>"1", # "."
#                       }

sub copy_atom
{
    my($old_atom) = @_;

    if( ref $old_atom ne "HASH" ) {
        use Carp;
        croak;
    }

    return copy_struct_deep($old_atom);
}

# Performs deep copying of structure passed via reference

sub copy_struct_deep
{
    my($struct) = @_;
    return $struct if !ref $struct;
    return [ map( copy_struct_deep($_), @$struct ) ] if ref $struct eq "ARRAY";
    return { map{ $_ => copy_struct_deep( $struct->{$_} ) } keys %$struct }
        if ref $struct eq "HASH";
    die( "deep copy failed: 'copy_struct_deep' does not know how to " .
         "copy object '" . ref( $struct ) . "'" );
}

# Wrapper for UserMessage::print_message()

sub note
{
    my( $program, $filename, $datablock, $message ) = @_;
    print_message( $program, $filename, $datablock, "NOTE", $message );
}

#===============================================================#
# Calculates distance between two given vectors.

# Accepts two arrays of vectors coordinates_fract.

# Returns a distance.

sub distance
{
    my($vector1, $vector2) = @_;
    my $dist = 0;

    for(my $k = 0; $k < @{$vector1}; $k++)
    {
        $dist += (${$vector1}[$k] - ${$vector2}[$k])**2;
    }
    return sqrt($dist);
}

#===============================================================#
# Multiplies an ortho matrix with a vector.

# my $ortho = [
#     [ o11 o12 o13 ]
#     [ 0   o22 o23 ]
#     [ 0   0   o33 ]
# ]
#

sub mat_vect_mul($$)
{
    my($matrix, $vector) = @_;

    my @new_coordinates;

    for(my $i = 0; $i < @{$vector}; $i++)
    {
        $new_coordinates[$i] = 0;
        for(my $j = 0; $j < @{$vector}; $j++)
        {
            $new_coordinates[$i] += ${$matrix}[$i][$j] * ${$vector}[$j];
        }
    }

    if( @$vector == 3 && @$matrix == 4 ) {
        $new_coordinates[0] += $matrix->[0][3];
        $new_coordinates[1] += $matrix->[1][3];
        $new_coordinates[2] += $matrix->[2][3];
    }

    return wantarray ? @new_coordinates : \@new_coordinates;
}
