#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Marks disorder in CIF files judging by distance and occupancy.
#**

use strict;
use warnings;
use AtomBricks;
use AtomProperties;
use CIFParser;
use CCIFParser;
use CIFTagCanonicalNames;
use CIFTagManage;
use CIFTagPrint;
use Fractional;
use UserMessage;
use SOptions;
use SUsage;

sub initial_atoms($$$$$);
sub mat_vect_mul($$);
sub get_unit_cell($$$);

my $same_site_distance_sensivity = 0.000001;
my $same_site_occupancy_sensivity = 0.01;
my $brick_size = 1;
my $cif_header_file;
my $use_parser = "c";
my $exclude_zero_occupancies = 1;
my $report_marked_disorders = 1;
my $ignore_occupancies = 0;

#* USAGE:
#*     $0 [options] input1.cif [input2.cif ...]
#* 
#* OPTIONS:
#*     -d, --distance-sensivity  0.000001
#*
#*     --occupancy-sensivity  0.01
#*
#*     -h, --add-cif-header
#*
#*     --exclude-zero-occupancies
#*     --no-exclude-zero-occupancies
#*     --dont-exclude-zero-occupancies
#*
#*     --ignore-occupancies
#*     --no-ignore-occupancies
#*     --dont-ignore-occupancies
#*
#*     --report-marked-disorders
#*     --no-report-marked-disorders
#*     --dont-report-marked-disorders
#*
#*     --brick-size  1
#*
#*     --use-perl-parser
#*
#*     --use-c-parser
#*
#*     --help,--usage
#*        Print short usage message (this message) and exit.
#**

@ARGV = getOptions
(
    "-d,--distance-sensivity" => \$same_site_distance_sensivity,
    "--occupancy-sensivity" => \$same_site_occupancy_sensivity,

    "-h,--add-cif-header" => \$cif_header_file,

    "--exclude-zero-occupancies"    => sub { $exclude_zero_occupancies = 1; },
    "--no-exclude-zero-occupancies" => sub { $exclude_zero_occupancies = 0; },
    "--dont-exclude-zero-occupancies" => sub { $exclude_zero_occupancies = 0; },

    "--ignore-occupancies" => sub { $ignore_occupancies = 1 },
    "--no-ignore-occupancies" => sub { $ignore_occupancies = 0 },
    "--dont-ignore-occupancies" => sub { $ignore_occupancies = 0 },

    "--report-marked-disorders" => sub { $report_marked_disorders = 1 },
    "--no-report-marked-disorders" =>
        sub { $report_marked_disorders = 0 },
    "--dont-report-marked-disorders" =>
        sub { $report_marked_disorders = 0 },

    "--brick-size" => \$brick_size,

    "--use-perl-parser" => sub{ $use_parser = "perl" },
    "--use-c-parser"    => sub{ $use_parser = "c" },

    "--help,--usage" => sub { SUsage::usage; exit },
);

my $cif_header;

if( $cif_header_file ) {
    open( HDR, "$cif_header_file" ) or
        die( "$0: could not open header file '$cif_header_file' " .
             "for input - $!" );

    $cif_header = "";
    while( <HDR> ) {
        last unless /^#/;
        $cif_header .= $_;
    }

    close( HDR ) or
        die( "$0: error reading header file '$cif_header_file' - $!" );
}

@ARGV = ("-") unless @ARGV;

for my $filename (@ARGV) {
    my $data;
    if( $use_parser eq "perl" ) {
        my $parser = new CIFParser;
        $data = $parser->Run($filename);
    } else {
        $data = CCIFParser::parse($filename);
    }

    canonicalize_all_names( $data );

    print $cif_header if $cif_header;
    for my $dataset (@$data) {
        # extracts atom site label or atom site type symbol
        my $values = $dataset->{values};
        my $dataname = $dataset->{name};
        
        # Get cell angles(alpha, beta, gama) and lengths(a, b, c)
        my @cell = get_unit_cell( $values, $filename, $dataname );

        # Make a matric to convert from fractional coordinates to
        # orthogonal:
        my $f2o = symop_ortho_from_fract(@cell);

        # Extract atoms fract coordinates
        my $atom_list = initial_atoms( \%AtomProperties::atoms,
                                       $dataset,
                                       $filename,
                                       $dataname,
                                       $f2o );

        my $bricks = AtomBricks::build_bricks( $atom_list,
                                               $brick_size );

        my $alternatives = get_alternatives( $atom_list,
                                             $bricks,
                                             $filename,
                                             $dataname,
                                             $f2o );

        my %assemblies = map{ $_->{assembly} => 1 }
                         grep{ $_->{assembly} ne '.' ||
                               $_->{group} ne '.' }
                         @$atom_list;

        my $has_dot_assembly = exists $assemblies{'.'};

        my $assembly_count = scalar keys %assemblies;
        my @all_assemblies = sort keys %assemblies;
        my $last_assembly = $all_assemblies[-1];

        my $rename_dot_assembly_with;
        if( $has_dot_assembly && ($assembly_count > 1 ||
                                   scalar( keys %$alternatives ) > 0) ) {
            if( $last_assembly eq '.' ) {
                $rename_dot_assembly_with = 'A';
            } else {
                $rename_dot_assembly_with =
                    chr( ord( $last_assembly ) + 1 );
            }
            $last_assembly = $rename_dot_assembly_with;
        }

        my $first_assembly;
        if( defined $last_assembly ) {
            $first_assembly = chr( ord( $last_assembly ) + 1 );
        } else {
            $first_assembly = 'A';
        }

        if( defined $rename_dot_assembly_with ) {
            note( $0, $filename, $dataname,
                  "disorder assembly '.' was renamed to " .
                  "'$rename_dot_assembly_with'" );
        }

        my @assemblies;
        my @groups;
        for my $atom (@$atom_list) {
            my $name = $atom->{name};
            my $index = $atom->{index};
            if( exists $alternatives->{$index} ) {
                push( @assemblies,
                      chr( ord( $first_assembly ) +
                                $alternatives->{$index}[0] ) );
                push( @groups, $alternatives->{$index}[1] );
            } elsif( exists $atom->{assembly} &&
                     exists $atom->{group} &&
                     $atom->{assembly} ne '.' ) {
                push( @assemblies, $atom->{assembly} );
                push( @groups, $atom->{group} );
            } elsif( defined $rename_dot_assembly_with &&
                     exists $atom->{assembly} &&
                     exists $atom->{group} &&
                     $atom->{assembly} eq '.' &&
                     $atom->{group} ne '.' ) {
                push( @assemblies,
                      $rename_dot_assembly_with );
                push( @groups, $atom->{group} );
            } else {
                push( @assemblies, '.' );
                push( @groups, '.' );
            }
        }

        my $assembly_count_now = scalar keys { map { $_ => 1 }
                                               grep { $_ ne '.' }
                                               @assemblies };
        my $assembly_count_diff = $assembly_count_now - $assembly_count;
        if( $assembly_count_diff > 0 ||
            defined $rename_dot_assembly_with ) {
            if( $assembly_count_diff > 0 ) {
                note( $0, $filename, $dataname,
                      "$assembly_count_diff site(s) were marked " .
                      "as disorder assemblies" );
            }

            my $atom_site_tag;

            if( exists $values->{"_atom_site_label"} ) {
                $atom_site_tag = "_atom_site_label";
            } else {
                $atom_site_tag = "_atom_site_type_symbol";
            }

            set_loop_tag( $dataset,
                          '_atom_site_disorder_assembly',
                          $atom_site_tag,
                          \@assemblies );
            set_loop_tag( $dataset,
                          '_atom_site_disorder_group',
                          $atom_site_tag,
                          \@groups );
        }

        print_cif( $dataset,
                   {
                        preserve_loop_order => 1,
                        keep_tag_order => 1
                   }
                 );
    }
}

sub get_alternatives
{
    my( $atom_list, $bricks, $filename, $dataname, $f2o ) = @_;
    my @assemblies;
    my %in_assembly;

    for my $current_atom (@$atom_list) {
        my $atom_in_unit_cell_coords_ortho =
            mat_vect_mul( $f2o, $current_atom->{coordinates_fract} );

        my ($i, $j, $k) =
            AtomBricks::get_atom_index( $bricks,
                                @{$atom_in_unit_cell_coords_ortho});

        my( $min_i, $max_i, $min_j, $max_j, $min_k, $max_k ) =
                AtomBricks::get_search_span( $bricks, $i, $j, $k );

        my $name1 = $current_atom->{name};
        my $index1 = $current_atom->{index};

        for $i ($min_i .. $max_i) {
        for $j ($min_j .. $max_j) {
        for $k ($min_k .. $max_k) {
            for my $atom ( @{$bricks->{atoms}[$i][$j][$k]} ) {
                my $atom_coords_ortho = $atom->{coordinates_ortho};
                my $name2 = $atom->{name};
                my $index2 = $atom->{index};

                next if $index1 ge $index2;

                my $dist = distance( $atom_in_unit_cell_coords_ortho,
                                     $atom_coords_ortho );
                next if $dist > $same_site_distance_sensivity;

                # Skipping initially marked disordered atoms:
                if( exists $current_atom->{assembly} &&
                    exists $atom->{assembly} &&
                    $current_atom->{assembly} eq $atom->{assembly} &&
                    exists $current_atom->{group} &&
                    exists $atom->{group} &&
                    $current_atom->{group} ne $atom->{group} ) {
                    next;
                }

                if( !exists $in_assembly{$index1} &&
                    !exists $in_assembly{$index2} ) {
                    # Creating new assembly
                    $in_assembly{$index1} = scalar @assemblies;
                    $in_assembly{$index2} = scalar @assemblies;
                    push( @assemblies, [ $index1, $index2 ] );
                } elsif( exists $in_assembly{$index1} &&
                         exists $in_assembly{$index2} ) {
                    my $assembly1 = $in_assembly{$index1};
                    my $assembly2 = $in_assembly{$index2};
                    next if $assembly1 == $assembly2;

                    # Merging two assemblies
                    my @new_assembly;
                    foreach( @{$assemblies[$assembly1]} ) {
                        $in_assembly{$_} = scalar @assemblies;                        
                        push( @new_assembly, $_ );
                    }
                    $assemblies[$assembly1] = [];
                    foreach( @{$assemblies[$assembly2]} ) {
                        $in_assembly{$_} = scalar @assemblies;
                        push( @new_assembly, $_ );
                    }
                    $assemblies[$assembly2] = [];
                    push( @assemblies, \@new_assembly );
                } else {
                    # Joining one atom to the assembly
                    if( exists $in_assembly{$index1} ) {
                        push( @{$assemblies[$in_assembly{$index1}]},
                              $index2 );
                        $in_assembly{$index2} = $in_assembly{$index1};
                    } else {
                        push( @{$assemblies[$in_assembly{$index2}]},
                              $index1 );
                        $in_assembly{$index1} = $in_assembly{$index2};
                    }
                }
            }
        }}}
    }

    my $count = 0;
    my %assemblies_now;

    for my $assembly (@assemblies) {
        next if @$assembly == 0;
        my $occupancy_sum =
            sum( map( $atom_list->[$_]{atom_site_occupancy},
                      @$assembly ) );
        if( abs( $occupancy_sum - 1 ) > $same_site_occupancy_sensivity &&
            !$ignore_occupancies ) {
            my @names = sort map( $atom_list->[$_]{name},
                                  @$assembly );
            warning( $0, $filename, $dataname,
                     "atoms " . join( ", ", map( "'$_'", @names ) ) .
                     " share the same site, but the sum of their " .
                     "occupancies is $occupancy_sum" );
            next;
        }
        if( $report_marked_disorders ) {
            note( $0, $filename, $dataname,
                  "atoms " . join( ", ",
                                   sort map( "'" .
                                             $atom_list->[$_]{name} .
                                             "'",
                                             @$assembly ) ) .
                  " were marked as alternatives" );
        }
        my $group_nr = 1;
        foreach( sort @$assembly ) {
            $assemblies_now{$_} = [ $count, $group_nr ];
            $group_nr++;
        }
        $count++;
    }

    return \%assemblies_now;
}

# ============================================================================ #
# Gets atom descriptions, as used in this program, from a CIF datablock.
#
# Returns an array of
#
#   $atom_info = {
#                   site_label=>"C1",
#                   name=>"C1_2",
#                   chemical_type=>"C",
#                   atom_site_type_symbol = "C",
#                   coordinates_fract=>[1.0, 1.0, 1.0],
#                   unity_matrix_applied=>1,
#                   assembly=>"A", # "."
#                   group=>"1", # "."
#                   multiplicity=>"1",
#                   multiplicity_ratio=>"1",
#              }
#
sub initial_atoms($$$$$)
{
    my ($atom_properties, $dataset, $filename, $dataname, $f2o ) = @_;
    my $values = $dataset->{values};

    my $atom_site_tag;

    if( exists $values->{"_atom_site_label"} ) {
        $atom_site_tag = "_atom_site_label";
    } elsif( exists $values->{"_atom_site_type_symbol"} ) {
        $atom_site_tag = "_atom_site_type_symbol";

        error( $0, $filename, $dataset->{name},
               "_atom_site_label tag was not found. " .
               "A serial number will be appended " .
               "to _atom_site_type_symbol to make atom labels" );
    } else {
        die( "neither _atom_site_type_symbol nor _atom_site_label " .
             "were found" );
    	return undef;
    }

    my $atom_labels = $values->{$atom_site_tag};

    my @atom_list;

    for (my $i = 0; $i < @{$atom_labels}; $i++)
    {
        if( $exclude_zero_occupancies &&
            defined $values->{_atom_site_occupancy} ) {
            my $occupancy = $values->{_atom_site_occupancy}[$i];
            $occupancy =~ s/\(\d+\)$//; # remove precission
            if( $occupancy eq "?" || $occupancy eq "." ||
                $occupancy == 0.0 ) {
                next;
            }
        }

	    my $label;
        if ( $atom_site_tag eq "_atom_site_type_symbol" ) {
	        $label = $values->{$atom_site_tag}[$i] . $i;
	    } else {
	        $label = $values->{$atom_site_tag}[$i];
	    }

        my $atom_info = extract_atom( $label, $values, $i, $f2o );
        push( @atom_list, $atom_info );
    }

    return \@atom_list;
}

#===============================================================#
# Extracts atom information from the CIF file.
#
# Accepts
#     values     - a hash where a data from the CIF file is stored
#     atom_label - atom site label or atom site type symbol from the CIF file
#     number     - a number of the current atom
#
# Returns a hash $atom:{
#                       label=>"C1",
#                       site_label=>"C1";
#                       chemical_type=>"C",
#                       atom_site_type_symbol = "C",
#                       coordinates_fract=>[1.0, 1.0, 1.0],
#                       unity_matrix_applied=>1,
#                       transform_matrices=>[ [
#                           [ 1, 0, 0, 0 ],
#                           [ 0, 1, 0, 0 ],
#                           [ 0, 0, 1, 0 ],
#                           [ 0, 0, 0, 1 ] ] ],
#                       assembly=>"A", # "."
#                       group=>"1", # "."
#                       }

sub extract_atom
{
    my($atom_label, $values, $number, $f2o) = @_;

    my %atom_info;
    my @atom_xyz;

    for my $cif_fract ( "_atom_site_fract_x",
                        "_atom_site_fract_y",
                        "_atom_site_fract_z",)
    {
        push(@atom_xyz, $values->{$cif_fract}[$number]);
        $atom_xyz[-1] =~ s/\(\d+\)$//;
    }

    $atom_info{"index"}                 = $number;
    $atom_info{"coordinates_fract"}     = \@atom_xyz;
    $atom_info{"name"}                  = $atom_label;
    $atom_info{"site_label"}            = $atom_label;

    $atom_info{coordinates_ortho} =
        mat_vect_mul( $f2o, \@atom_xyz );

    my $atom_type;

    if( exists $values->{_atom_site_type_symbol}  &&
        defined $values->{_atom_site_type_symbol}[$number] &&
        $values->{_atom_site_type_symbol}[$number] ne '?' ) {
        $atom_type = $values->{_atom_site_type_symbol}[$number];
        $atom_info{atom_site_type_symbol} = $atom_type;
        if( $atom_type =~ m/^([A-Za-z]{1,2})/ ) {
            $atom_type = ucfirst( lc( $1 ));
        }
    } else {
        if( $values->{_atom_site_label}[$number] =~
            m/^([A-Za-z]{1,2})/ ) {
            $atom_type = ucfirst( lc( $1 ));
        } else {
            die( "could not determine atom type for atom " .
                 "'$values->{_atom_site_label}[$number]'" );
        }
    }

    $atom_info{chemical_type} = $atom_type;

    if( exists $values->{_atom_site_disorder_assembly} ) {
        $atom_info{assembly} =
	    $values->{_atom_site_disorder_assembly}[$number];
    } else {
        $atom_info{assembly} = ".";
    }

    if( exists $values->{_atom_site_disorder_group} ) {
        $atom_info{group} = $values->{_atom_site_disorder_group}[$number];
    } else {
        $atom_info{group} = ".";
    }

    if( exists $values->{_atom_site_occupancy} ) {
        $atom_info{atom_site_occupancy} =
            $values->{_atom_site_occupancy}[$number];
    } else {
        # Assuming full occupancies if '_atom_site_occupancy' tag is
        # missing in CIF file:
        $atom_info{atom_site_occupancy} = 1;
    }

    return \%atom_info;
}

#===============================================================#
# Extract unit cell angles and lengths.
#
# Accepts
#     values - a hash where a data from the CIF file is stored
# Returns
#     cell - an array  with stored information.

sub get_unit_cell($$$)
{
    my( $values, $filename, $dataname ) = @_;

    my @cell;

    for my $cif_tag (qw(_cell_length_a
                        _cell_length_b
                        _cell_length_c
                        ))
    {
        push(@cell, $values->{$cif_tag}[0]);
        $cell[-1] =~ s/\(\d+\)$//;
    }

    for my $cif_tag (qw(_cell_angle_alpha
                        _cell_angle_beta
                        _cell_angle_gamma
                        ))
    {
        if( exists $values->{$cif_tag} ) {
            push( @cell, $values->{$cif_tag}[0] );
            $cell[-1] =~ s/\(\d+\)$//;
        } else {
            warning( $0, $filename, $dataname,
                     "cell angle '$cif_tag' not present -- " .
                     "taking default value 90 degress." );
            push( @cell, 90 );
        }
    }

    return @cell;
}

#===============================================================#
# Copies atom and returns the same instance of it (different object, same props)

# Accepts a hash $atom_info = {
#                       name=>"C1_2",
#                       site_label=>"C1",
#                       chemical_type=>"C",
#                       coordinates_fract=>[1.0, 1.0, 1.0],
#                       coordinates_ortho=>[5.0, -1.3, 1.7],
#                       transform_matrices=>[ [
#                           [ 1, 0, 0, 0 ],
#                           [ 0, 1, 0, 0 ],
#                           [ 0, 0, 1, 0 ],
#                           [ 0, 0, 0, 1 ] ] ],
#                       unity_matrix_applied=>1,
#                       symop_id=>1
#                       assembly=>"A", # "."
#                       group=>"1", # "."
#                       }

# Returns a hash $new_atom_info = {
#                       name=>"C1_2",
#                       site_label=>"C1",
#                       chemical_type=>"C",
#                       coordinates_fract=>[1.0, 1.0, 1.0],
#                       coordinates_ortho=>[5.0, -1.3, 1.7],
#                       transform_matrices=>[ [
#                           [ 1, 0, 0, 0 ],
#                           [ 0, 1, 0, 0 ],
#                           [ 0, 0, 1, 0 ],
#                           [ 0, 0, 0, 1 ] ] ],
#                       unity_matrix_applied=>1,
#                       symop_id=>1,
#                       assembly=>"A", # "."
#                       group=>"1", # "."
#                       }

sub copy_atom
{
    my($old_atom) = @_;

    if( ref $old_atom ne "HASH" ) {
        use Carp;
        croak;
    }

    return copy_struct_deep($old_atom);
}

# Performs deep copying of structure passed via reference

sub copy_struct_deep
{
    my($struct) = @_;
    return $struct if !ref $struct;
    return [ map( copy_struct_deep($_), @$struct ) ] if ref $struct eq "ARRAY";
    return { map{ $_ => copy_struct_deep( $struct->{$_} ) } keys %$struct }
        if ref $struct eq "HASH";
    die( "deep copy failed: 'copy_struct_deep' does not know how to " .
         "copy object '" . ref( $struct ) . "'" );
}

# Wrapper for UserMessage::print_message()

sub note
{
    my( $program, $filename, $datablock, $message ) = @_;
    print_message( $program, $filename, $datablock, "NOTE", $message );
}

#===============================================================#
# Calculates distance between two given vectors.

# Accepts two arrays of vectors coordinates_fract.

# Returns a distance.

sub distance
{
    my($vector1, $vector2) = @_;
    my $dist = 0;

    for(my $k = 0; $k < @{$vector1}; $k++)
    {
        $dist += (${$vector1}[$k] - ${$vector2}[$k])**2;
    }
    return sqrt($dist);
}

#===============================================================#
# Multiplies an ortho matrix with a vector.

# my $ortho = [
#     [ o11 o12 o13 ]
#     [ 0   o22 o23 ]
#     [ 0   0   o33 ]
# ]
#

sub mat_vect_mul($$)
{
    my($matrix, $vector) = @_;

    my @new_coordinates;

    for(my $i = 0; $i < @{$vector}; $i++)
    {
        $new_coordinates[$i] = 0;
        for(my $j = 0; $j < @{$vector}; $j++)
        {
            $new_coordinates[$i] += ${$matrix}[$i][$j] * ${$vector}[$j];
        }
    }

    if( @$vector == 3 && @$matrix == 4 ) {
        $new_coordinates[0] += $matrix->[0][3];
        $new_coordinates[1] += $matrix->[1][3];
        $new_coordinates[2] += $matrix->[2][3];
    }

    return wantarray ? @new_coordinates : \@new_coordinates;
}

sub sum
{
    my $sum = 0.0;
    foreach( @_ ) { $sum += $_; }
    return $sum;
}
