#!/bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------
#*
# Convert a COD XRF (eXtended ReFerence) format into a CIF file.
#**

use strict;
use lib "./lib/perl5";
use Unicode2CIF;
use SOptions;
use SUsage;

my $user_biblio = 0;
my $leave_biblio = 0;

my $title;
my $journal;
my $volume;
my $issue;
my $start_page;
my $end_page;
my $year;
my $authors;

@ARGV = getOptions( 
    "-j,--journal"   => sub{ $user_biblio = 1; $journal = get_value() },
    "-v,--volume"    => sub{ $user_biblio = 1; $volume = get_value() },
    "-p,--page"      => sub{ $user_biblio = 1; $start_page = get_value() },
    "--start-page"   => sub{ $user_biblio = 1; $start_page = get_value() },
    "-e,--end-page"  => sub{ $user_biblio = 1; $end_page = get_value() },
    "-y,--year"      => sub{ $user_biblio = 1; $year = get_value() },
    "--leave-bibliography"   => sub{ $leave_biblio = 1 },
    "--discard-bibliography" => sub{ $leave_biblio = 0 },
    "--help,--usage" => sub { SUsage::usage; exit },
);

my @inherited_tags = (
    #
    # Bibliographic information
    #
    "_publ_author_name",
    "_publ_section_title",
    "_journal_name_full",
    "_journal_year",
    "_journal_volume",
    "_journal_issue",
    "_journal_page_first",
    "_journal_page_last",
    #
    # Chemical data
    #
    "_chemical_formula_moiety",
    "_chemical_formula_sum",
    "_chemical_name_systematic",
    "_chemical_name_common",
    "_chemical_formula_weight",
    #
    # Spacegroup and symmetry
    #
    "_symmetry_space_group_name_H-M",
    "_symmetry_space_group_name_Hall",
    "_symmetry_equiv_pos_as_xyz",
    #
    # Atomic parameters
    #
    "_atom_site_type_symbol",
    "_atom_site_B_iso_or_equiv",
    "_atom_site_calc_flag",
    "_atom_site_refinement_flags",
    "_atom_site_disorder_assembly",
    "_atom_site_disorder_group",
    #
    # Experiment details
    #
    "_exptl_crystal_description",
    "_exptl_crystal_colour",
    "_exptl_crystal_size_max",
    "_exptl_crystal_size_mid",
    "_exptl_crystal_size_min",
    "_exptl_crystal_density_meas",
    "_exptl_crystal_density_diffrn",
    "_exptl_crystal_density_method",
    "_exptl_crystal_F_000",
    "_exptl_absorpt_coefficient_mu",
    "_exptl_absorpt_correction_type",
    "_exptl_absorpt_correction_T_min",
    "_exptl_absorpt_correction_T_max",
    "_exptl_absorpt_process_details",
    #
    # Data collection parameters:
    #
    "_diffrn_ambient_temperature",
    "_diffrn_radiation_wavelength",
    "_diffrn_radiation_type",
    "_diffrn_radiation_source",
    "_diffrn_radiation_monochromator",
    "_diffrn_measurement_device_type",
    "_diffrn_measurement_method",
    "_diffrn_detector_area_resol_mean",
    "_diffrn_standards_number",
    "_diffrn_standards_interval_count",
    "_diffrn_standards_interval_time",
    "_diffrn_standards_decay_%",
    "_diffrn_reflns_number",
    "_diffrn_reflns_av_R_equivalents",
    "_diffrn_reflns_av_sigmaI/netI",
    "_diffrn_reflns_limit_h_min",
    "_diffrn_reflns_limit_h_max",
    "_diffrn_reflns_limit_k_min",
    "_diffrn_reflns_limit_k_max",
    "_diffrn_reflns_limit_l_min",
    "_diffrn_reflns_limit_l_max",
    "_diffrn_reflns_theta_min",
    "_diffrn_reflns_theta_max",
    #
    # Reflection statistics:
    #
    "_reflns_number_total",
    "_reflns_number_gt",
    "_reflns_threshold_expression",
    #
    # Refinement statistics:
    #
    "_refine_ls_structure_factor_coef",
    "_refine_ls_matrix_type",
    "_refine_ls_weighting_scheme",
    "_refine_ls_weighting_details",
    "_atom_sites_solution_primary",
    "_atom_sites_solution_secondary",
    "_atom_sites_solution_hydrogens",
    "_refine_ls_hydrogen_treatment",
    "_refine_ls_extinction_method",
    "_refine_ls_extinction_coef",
    "_refine_ls_number_reflns",
    "_refine_ls_number_parameters",
    "_refine_ls_number_restraints",
    "_refine_ls_goodness_of_fit_ref",
    "_refine_ls_restrained_S_all",
    "_refine_ls_shift/su_max",
    "_refine_ls_shift/su_mean",
    "_refine_ls_R_factor_all",
    "_refine_ls_R_factor_gt",
    "_refine_ls_wR_factor_ref",
    "_refine_ls_wR_factor_gt",
    #
    # Computer systems and used software
    #
    "_computing_data_collection",
    "_computing_cell_refinement",
    "_computing_data_reduction",
    "_computing_structure_solution",
    "_computing_structure_refinement",
    "_computing_molecular_graphics",
    "_computing_publication_material",
    #
    # Unit cell parameters
    #
    "_cell_length_a",
    "_cell_length_b",
    "_cell_length_c",
    "_cell_angle_alpha",
    "_cell_angle_beta",
    "_cell_angle_gamma",
    "_cell_volume",
    "_cell_formula_units_Z",
    "_cell_measurement_temperature",
    "_cell_measurement_reflns_used",
    "_cell_measurement_theta_min",
    "_cell_measurement_theta_max",
);

my @generated_tags = (
    "_atom_site_B_iso_or_equiv",
    "_atom_site_U_iso_or_equiv",
    "_atom_site_Wyckoff_symbol",
    "_atom_site_adp_type",
    "_atom_site_aniso_U_11",
    "_atom_site_aniso_U_12",
    "_atom_site_aniso_U_13",
    "_atom_site_aniso_U_22",
    "_atom_site_aniso_U_23",
    "_atom_site_aniso_U_33",
    "_atom_site_aniso_label",
    "_atom_site_calc_flag",
    "_atom_site_disorder_assembly",
    "_atom_site_disorder_group",
    "_atom_site_fract_x",
    "_atom_site_fract_y",
    "_atom_site_fract_z",
    "_atom_site_label",
    "_atom_site_occupancy",
    "_atom_site_refinement_flags",
    "_atom_site_symmetry_multiplicity",
    "_atom_site_type_symbol",
    "_cell_angle_alpha",
    "_cell_angle_beta",
    "_cell_angle_gamma",
    "_cell_length_a",
    "_cell_length_b",
    "_cell_length_c",
    "_cell_volume",
    "_chemical_formula_sum",
    "_geom_bond_atom_site_label_1",
    "_geom_bond_atom_site_label_2",
    "_geom_bond_distance",
    "_publ_section_title",
    "_symmetry_equiv_pos_as_xyz",
    "_symmetry_space_group_name_H-M",
);

my %generated_tags = map { ($_,1) } @generated_tags;

@inherited_tags = map { defined $generated_tags{$_} ? () : $_ } @inherited_tags;

my %tags = ();
my @record = ();
my @anisou = ();
my %anisou = ();
my @bonds = ();

my $n = 0;
my $compound = 1;

use open ":utf8";
binmode( STDIN, ":utf8" );

my $nrecords = 0;

while(<>) {
    chomp;

    if( /^\#/ ) {
	my $idx;
	my ( $key, $value ) = split( /[\s]/, $_, 2 );
	$key =~ s/^\#//;
	if( $key =~ /^(.*)\[(.*)\]$/ ) {
	    $key = $1;
	    $idx = $2;
	}
	if( defined $idx ) {
	    if( !defined $tags{$key}[$idx] ) {
		$tags{$key}[$idx] = $value;
	    } else {
		$tags{$key}[$idx] .= "\n" . $value;
	    }
	} else {
	    if( !defined $tags{$key} ) {
		$tags{$key} = $value;
	    } else {
		$tags{$key} .= "\n" . $value;
	    }
	}
    } elsif( /^ANISOU\s/ ) {
	my @atom = split( " ",$_ );
	my $atom_name = $atom[1];
	push( @anisou, [ @atom ] );
	$anisou{$atom_name} ++;
    } elsif( /^BOND\s/ ) {
	my @bond = split( " ",$_ );
	push( @bonds, [ @bond ] );
    } elsif( !/^\s*$/ ) {
	if( $n < 4 && $n != 2 ) {
	    push( @record, [$_] );
	} else {
	    push( @record, [ split( " ", $_ ) ] );
	}
	$n++;
    }
    
    if( /^\s*$/ || eof ) {
	if( $user_biblio ) {
	    if( !$leave_biblio ) {
		for my $key ( grep /_journal_|_publ_section_title|_author_/,
			      keys %tags ) {
		    delete $tags{$key};
		}
	    }
	    $tags{_publ_section_title} = $title if defined $title;
	    $tags{_journal_name_full} = $journal if defined $journal;
	    $tags{_journal_year} = $year if defined $year;
	    $tags{_journal_volume} = $volume if defined $volume;
	    $tags{_journal_issue} = $issue if defined $issue;
	    $tags{_journal_page_first} = $start_page if defined $start_page;
	    $tags{_journal_page_last} = $end_page if defined $end_page;
	}
	print "\n" if $nrecords++ > 0;
	print_record( \@record, \%tags, \@anisou, \%anisou, \@bonds );
	@record = ();
	%tags = ();
	@anisou = ();
	%anisou = ();
	@bonds = ();
	$n = 0;
    }
}

sub print_tag
{
    my ($key, $tags) = @_;

    if( exists $tags->{$key} ) {
	my $val = $tags->{$key};
	if( ref $val eq "ARRAY" ) {
	    print "loop_\n";
	    print "$key\n";
	    for my $value (@$val) {
		print_value( $value );
	    }
	} else {
	    my $key_len = length($key) > 30 ? length($key) : 30;
	    my $val_len = length($val);

	    if( $val =~ /\s/ ) {
		$val_len += 2;
	    }
	    if( $key_len + $val_len + 1 > 80 && $val !~ /\n/ ) {
		printf "%s\n", $key;
	    } else {
		printf "%-30s", $key;
	    }
	    print_value( $val );
	}
    }
}

sub print_value
{
    my $val = $_[0];

    if( $val =~ /\n/ ) {
	$val = "\n;" . $val . "\n;\n";
    } elsif( $val !~ /\s/) {
	$val = " " . $val . "\n";
    } else {
	$val = " '" . $val . "'\n";
    }
    print $val;
}

sub print_record
{
    my ($records, $tags, $anisou, $anisou_atoms, $bonds) = @_;

    printf "data_%d\n", 7000000 + $compound++;

    ## do { local $, = ",\n"; print keys %{$tags}, "\n"; };

    if( $records && int(@{$records}) > 0 ) {
	my $bibliography = shift( @{$records} );
	my $composition =  shift( @{$records} );
	my $cell =  shift( @{$records} );
	my $spacegroup = shift( @{$records} );

	if( defined $tags->{_publ_section_title} ) {
	    $bibliography = [ $tags->{_publ_section_title} ];
	    $bibliography->[0] =~ s/\n/ /g;
	}

	print "_publ_section_title \n";
	print ";\n";
	do {
	    local $, = "\n";
	    local $\ = "\n";
	    $bibliography->[0] = unicode2cif( $bibliography->[0] );
	    print map { " " . $_ } fold( 71, " +", " ", ($bibliography->[0]) );
	};
	print ";\n";
	print "_chemical_formula_sum '$composition->[0]'\n";

	if( $tags ) {
	    for my $key (@inherited_tags) {
		print_tag( $key, $tags );
	    }
	}

	my $have_Wyckoff_symbol = 0;
	for my $atom (@{$records}) {
	    if( defined $atom->[2] && $atom->[2] ne '?' && $atom->[2] ne '.' ) {
		$have_Wyckoff_symbol = 1;
		last;
	    }
	}

	print "_cell_length_a       $cell->[0]\n";
	print "_cell_length_b       $cell->[1]\n";
	print "_cell_length_c       $cell->[2]\n";
	print "_cell_angle_alpha    $cell->[3]\n";
	print "_cell_angle_beta     $cell->[4]\n";
	print "_cell_angle_gamma    $cell->[5]\n";
	if( defined $tags{_cell_volume} ) {
	    printf "_cell_volume         %s\n", $tags{_cell_volume};
	} else {
	    printf "_cell_volume         %8.2f\n", cell_volume( @{$cell} );
	}
	print "_symmetry_space_group_name_H-M   ";
	print_value( $spacegroup->[0] );
	print_tag( "_symmetry_equiv_pos_as_xyz", $tags );
	if( int(@{$records}) > 0 ) {
	    print "loop_\n";
	    print "_atom_site_label\n";
	    if( defined $tags{_atom_site_type_symbol} ) {
		print "_atom_site_type_symbol\n";
	    }
	    print "_atom_site_symmetry_multiplicity\n";
	    print "_atom_site_Wyckoff_symbol\n" if $have_Wyckoff_symbol;
	    print "_atom_site_fract_x\n";
	    print "_atom_site_fract_y\n";
	    print "_atom_site_fract_z\n";
	    print "_atom_site_occupancy\n";
	    if( !defined $tags{_atom_site_B_iso_or_equiv} ) {
		print "_atom_site_U_iso_or_equiv\n";
	    } else {
		print "_atom_site_B_iso_or_equiv\n";
	    }
	    print "_atom_site_adp_type\n";

	    for my $atom_site_tag ( "_atom_site_calc_flag",
				    "_atom_site_disorder_assembly",
				    "_atom_site_disorder_group" ) {
		if( defined $tags{$atom_site_tag} ) {
		    my $has_value = 0;
		    for my $val ( @{$tags{$atom_site_tag}} ) {
			if( defined $val && $val ne '.' && $val ne '?' ) {
			    $has_value = 1;
			    last;
			}
		    }
		    if( !$has_value ) {
			delete $tags{$atom_site_tag};
		    }
		}
	    }

	    for my $atom_site_tag ( "_atom_site_calc_flag",
				    "_atom_site_refinement_flags",
				    "_atom_site_disorder_assembly",
				    "_atom_site_disorder_group" ) {
		if( defined $tags{$atom_site_tag} ) {
		    print $atom_site_tag, "\n";
		}
	    }

	    local $, = " ";
	    local $\ = "";
	    my $i = 0;

	    my $UisoBiso_val;
	    my $use_Biso_tag;

	    if( defined $tags{_atom_site_B_iso_or_equiv} ) {
		$UisoBiso_val = "Biso";
		$use_Biso_tag = 1;
	    } else {
		$UisoBiso_val = "Uiso";
		$use_Biso_tag = 0;
	    }

	    for my $atom (@{$records}) {
		my $atom_name = $atom->[0];
		my @atom = @{$atom};
		splice( @atom, 2, 1 ) if !$have_Wyckoff_symbol;
		if( defined $tags{_atom_site_type_symbol} ) {
		    splice( @atom, 1, 0,
			    $tags{_atom_site_type_symbol}[$i] );
		}
		print @atom[0..$#atom-1],
		    $use_Biso_tag ?
			$tags{_atom_site_B_iso_or_equiv}[$i] :
			$atom[-1],
		    defined $anisou_atoms->{$atom_name} ?
		        "Uani" : $UisoBiso_val;
		for my $atom_site_tag ( "_atom_site_calc_flag",
					"_atom_site_refinement_flags",
					"_atom_site_disorder_assembly",
					"_atom_site_disorder_group" ) {
		    if( defined $tags{$atom_site_tag} ) {
			print " " . $tags{$atom_site_tag}[$i];
		    }
		}
		print "\n";
		$i ++;
	    }
	}
    }

    if( $anisou && int(@{$anisou}) > 0 ) {
	print "loop_\n";
	print "_atom_site_aniso_label\n";
	print "_atom_site_aniso_U_11\n";
	print "_atom_site_aniso_U_22\n";
	print "_atom_site_aniso_U_33\n";
	print "_atom_site_aniso_U_23\n";
	print "_atom_site_aniso_U_13\n";
	print "_atom_site_aniso_U_12\n";
	local $, = " ";
	local $\ = "\n";
	for my $atom (@{$anisou}) {
	    print @{$atom}[1..$#{$atom}];
	}
    }

    if( $bonds and int(@{$bonds}) > 0 ) {
	print "loop_\n";
	print "_geom_bond_atom_site_label_1\n";
	print "_geom_bond_atom_site_label_2\n";
	print "_geom_bond_distance\n";
	local $, = " ";
	local $\ = "\n";
	for my $bond (@{$bonds}) {
	    print @{$bond}[1..$#{$bond}];
	}
    }
}

sub fold
{
    my $length = shift;
    my $separator = shift;
    my $ors = shift;
    my $string = shift;
    my @lines = ();
    my $line = "";

    my $word;
    for $word (split( $separator, $string )) {
	$word =~ s/^\s*|\s*$//g;
	if( !$line ) {
	    $line = $word;
	} else {
	    my $new_line = "$line$ors$word";
	    if( length($new_line) < $length ) {
		$line = $new_line;
	    } else {
		push( @lines, $line );
		$line = $word;
	    }
	}
    }
    push( @lines, $line );
    return @lines;
}

sub cell_volume
{
    my @cell = map { s/\(.*\)//g; $_ } @_;

    my $Pi = 3.14159265358979;

    my ($a, $b, $c) = @cell[0..2];
    my ($alpha, $beta, $gamma) = map {$Pi * $_ / 180} @cell[3..5];
    my ($ca, $cb, $cg) = map {cos} ($alpha, $beta, $gamma);
    my $sg = sin($gamma);
    
    my $V = $a * $b * $c * sqrt( $sg**2 - $ca**2 - $cb**2 + 2*$ca*$cb*$cg );

    return $V;
}
