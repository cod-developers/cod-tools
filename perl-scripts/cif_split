#!/bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#-----------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------
#*
# Split CIF files into separate files with one data_ section each.
#
# This script parses given CIF files to separate the datablocks, so is
# capable of splitting non-correctly formatted and nested CIF files.
#**

use strict;
use CIFTagCanonicalNames;
use CIFTagPrint;
use File::Basename;
use SOptions;
use SUsage;
use UserMessage;

my $verbose = 1;
my $output_dir = "";

my $use_parser = "c";

@ARGV = getOptions(
#** -o, --output-dir out/
#**     Put all split files into the directory out/.
#**
#** -v, --verbose      print names of the generated files to STDERR
#** -q, --quiet        do not print file names to STDERR
#**
#** --use-perl-parser
#**    Use Perl parser for CIF parsing.
#**
#** --use-c-parser
#**    Use Perl & C parser for CIF parsing.
#**
#** --help,--usage     print short usage message (this message) and exit

   "-o,--output-dir" => \$output_dir,
   "-v,--verbose"    => sub { $verbose = 1 },
   "-q,--quiet"      => sub { $verbose = 0 },
   "--help,--usage"  => sub { SUsage::usage; exit },
);

$output_dir =~ s./+$..;

my %files = ();

@ARGV = ("-") unless @ARGV;

for my $filename (@ARGV) {
    my $data;
    my $error_count;
    if( $use_parser eq "perl" ) {
        require CIFParser;
        my $parser = new CIFParser;
        $data = $parser->Run($filename);

        if( defined $parser->YYData->{ERRCOUNT} ) {
            $error_count = $parser->YYData->{ERRCOUNT};
        }
    } else {
        require CCIFParser;
        ( $data, $error_count ) = CCIFParser::parse($filename);
    }

    if( defined $error_count && $error_count > 0 ) {
        error( $0, $filename, undef,
               $error_count . " error(s) encountered while parsing" );
        next;
    }

    canonicalize_all_names( $data );

    my $data_global;
    for my $dataset (@$data) {
        my $dataname = $dataset->{name};

        if( $dataname eq 'global' ) {
            if( !$data_global ) {
                $data_global = $dataset;
            } else {
                warning( $0, $filename, $dataname,
                         "second data_global encountered -- skipping" );
            }
            next;
        }

        close STDOUT;

        my $suffix = $dataname;
        $suffix =~ s/[^-+._a-zA-Z0-9]/_/g;

        my $basename = basename( $filename, ".cif" );
        my $output_file;
        if( $basename ne "-" ) {
            $output_file = basename( $ARGV, ".cif" ) . "_${suffix}" . ".cif";
        } else {
            $output_file = "${suffix}" . ".cif";
        }
        if( $output_dir ne "" ) {
            $output_file = $output_dir . "/" . $output_file;
        }
        if( !exists $files{$output_file} ) {
            open( STDOUT, ">$output_file" ) or
                die( "Could not open file '${output_file}' for writing: $!" );

            $files{$output_file} = $output_file;

            print STDERR "$output_file\n" if $verbose;
            if( $data_global ) {
                print_cif( $data_global,
                           {
                                preserve_loop_order => 1,
                                keep_tag_order => 1
                           }
                         );
            }
            print_cif( $dataset,
                       {
                            preserve_loop_order => 1,
                            keep_tag_order => 1
                       }
                     );
        } else {
            open( STDOUT, ">>$output_file" ) or
                die( "Could not open file '${output_file}' for appending: $!" );
            
            print STDERR "$output_file (appending)\n" if $verbose;
        }
    }
}
