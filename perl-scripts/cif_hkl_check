#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Check the correspondence between CIF and Fobs files, taking datablock
#  names, cell parameters, author lists and symmetry group names into
#  account.
#**

use strict;
use warnings;
use CIFParser;
use CIFDiff;
use UserMessage;
use SOptions;
use SUsage;

my $use_parser = "c";

#* USAGE:
#*     $0 [options] input.cif input.hkl [input2.cif input2.hkl ...]
#*
#* OPTIONS:
#*     --use-perl-parser
#*        Use Perl parser for CIF parsing.
#*
#*     --use-c-parser
#*        Use Perl & C parser for CIF parsing.
#*
#*     --help,--usage
#*        Print short usage message (this message) and exit.
#**

@ARGV = getOptions(
    "--use-perl-parser" => sub{ $use_parser = "perl" },
    "--use-c-parser"    => sub{ $use_parser = "c" },
    "--help,--usage" => sub { SUsage::usage; exit },
);

PAIR:
while( @ARGV > 0 ) {
    my $cif_file = shift( @ARGV );
    if( @ARGV == 0 ) {
        error( $0, $cif_file, undef, "missing Fobs file" );
        die;
    }
    my $hkl_file = shift( @ARGV );

    my( $cif_data, $cif_errors ) = parse_file( $cif_file, $use_parser );
    next if $cif_errors > 0;

    if( !@$cif_data || !defined $cif_data->[0] ||
        !defined $cif_data->[0]{name} ) {
        warning( $0, $cif_file, undef,
                 "file '$cif_file' seems to be empty" );
        next;
    }

    my( $hkl_data, $hkl_errors ) = parse_file( $hkl_file, $use_parser );
    next if $hkl_errors > 0;

    if( !@$hkl_data || !defined $hkl_data->[0] ||
        !defined $hkl_data->[0]{name} ) {
        warning( $0, $cif_file, undef,
                 "file '$hkl_file' seems to be empty" );
        next;
    }

    if( @$hkl_data > 1 ) {
        warning( $0, $cif_file, undef, "file '$hkl_file' contains more " .
                                       "than one datablock" );
        next;
    }
    my $hkl_dataset = $hkl_data->[0];
    my $hkl_values = $hkl_dataset->{values};
    foreach( 'h', 'k', 'l' ) {
        if( !exists $hkl_values->{"_refln_index_$_"} ) {
            warning( $0, $cif_file, undef,
                     "can not confirm that file '$hkl_file' contains " .
                     "Fobs data: one or more tags from list " .
                     "( '_refln_index_h', '_refln_index_k', " .
                     "'_refln_index_l' ) is missing" );
            next PAIR;
        }
    }
    my $hkl_dataname = get_source_block_name( $hkl_dataset );
    my $cif_index;
    my @cif_datanames;
    for( my $i = 0; $i < @$cif_data; $i++ ) {
        my $cif_dataname = get_source_block_name( $cif_data->[$i] );
        push( @cif_datanames, $cif_dataname );
        if( $cif_dataname eq $hkl_dataname ) {
            $cif_index = $i;
            last;
        }
    }
    if( !defined $cif_index ) {
        warning( $0, $cif_file, undef,
                 "can not confirm relation between any datablocks in " .
                 "CIF and Fobs files -- there are no datablocks with " .
                 "the same name in both files (CIF datablock(s): " .
                 join( ", ", map { "'$_'" } @cif_datanames ) .
                 ", Fobs datablock: '$hkl_dataname')" );
        next PAIR;
    }
    my $comm = CIFDiff::comm( $cif_data->[$cif_index], $hkl_dataset,
        {
            'compare_only' =>
                [
                    '_cell_length_a',
                    '_cell_length_b',
                    '_cell_length_c',
                    '_cell_angle_alpha',
                    '_cell_angle_beta',
                    '_cell_angle_gamma',
                    '_publ_author_name',
                    '_symmetry_space_group_name_Hall',
                    '_symmetry_space_group_name_H-M',
                ],
            'comparators'  =>
                {
                    '_cell_length_a' => \&compare_cif_numbers,
                    '_cell_length_b' => \&compare_cif_numbers,
                    '_cell_length_c' => \&compare_cif_numbers,
                    '_cell_angle_alpha' => \&compare_cif_numbers,
                    '_cell_angle_beta'  => \&compare_cif_numbers,
                    '_cell_angle_gamma' => \&compare_cif_numbers,
                    '_publ_author_name' => \&compare_lc_strings,
                }
        } );
    foreach my $line ( @$comm ) {
        if( defined $line->[0] && defined $line->[2] ) {
            my $reason;
            if( $line->[0] eq '_publ_author_name' ) {
                $reason = "publication author lists differ";
            } else {
                $reason = "values of tag '$line->[0]' differ";
            }
            $reason .= ": '" . join( ', ', map { "'$_'" }
                  @{$cif_data->[$cif_index]{values}{$line->[0]}} ) .
                  "' (CIF) and '" . join( ', ', map { "'$_'" }
                  @{$hkl_values->{$line->[0]}} ) .
                  "' (Fobs)";
            warning( $0, $cif_file, undef,
                     "can not confirm relation between datablocks named " .
                     "'$hkl_dataname' from supplied CIF and Fobs files -- " .
                     $reason );
            next PAIR;
        }
    }
    note( $0, $cif_file, undef, "OK" );
}

sub parse_file
{
    my( $file, $use_parser ) = @_;
    my( $data, $errors );
    if( $use_parser eq "perl" ) {
        my $parser = new CIFParser;
        $data = $parser->Run($file);
        $errors = 0;
        if( defined $parser->YYData->{ERRCOUNT} ) {
            $errors = $parser->YYData->{ERRCOUNT};
        }
    } else {
        require CCIFParser;
        ( $data, $errors ) = CCIFParser::parse( $file );
    }
    return( $data, $errors );
}

sub compare_cif_numbers
{
    my( $a, $b ) = @_;
    return 1 - can_be_equal( $a, $b );
}

sub compare_lc_strings
{
    my( $a, $b ) = @_;
    return lc( $a ) cmp lc( $b );
}

# Unpacks CIF number to the value that can be processed with Perl
# Parameters:
#       -- $cif_number
# Return:
#       -- $unpacked_number
#       -- $precision
sub unpack_cif_number
{
    my ($value) = @_;
    my $number_pos =
        '(?:\+?' .
        '(?:\d+(?:\.\d*)?|\.\d+))';
    my $number_neg =
        '(?:\-' .
        '(?:\d+(?:\.\d*)?|\.\d+))';
    my $exponent =
        '(?:[eE][-+]?\d+)';
    my $sigma =
        '(?:\(\d+\))';
    $value =~ /($number_pos|$number_neg)($exponent?)($sigma?)/;
    my ($number_part, $exponent_part, $sigma_part ) = ($1, $2, $3);
    $sigma_part =~ s/\((\d+)\)/$1/;
    $exponent_part =~ s/[eE]([-+]?\d+)/$1/;
    $exponent_part = 0 if $exponent_part eq "";
    $sigma_part = 0 if $sigma_part eq "";
    my $converted = 10 ** $exponent_part * $number_part;
    my $digits_after_period = 0;
    if( $number_part =~ /\.(\d+)$/ ) {
        $digits_after_period = length($1);
    }
    my $precision = $sigma_part / 10 ** $digits_after_period;
    return ($converted, $precision);
}

# Checks if two CIF format numbers are (possibly) equal.
# Parameters:
#       -- $first_cif_number
#       -- $second_cif_number
# Return:
#       -- 1 if numbers are equal, 0 otherwise
sub can_be_equal
{
    my ($x, $y) = @_;
    my @x = unpack_cif_number($x);
    my @y = unpack_cif_number($y);
    if( $x[1] == 0 && $y[1] == 0 ) {
        return $x[0] == $y[0];
    } elsif( $x[1] == 0 ) {
        return $x[0] > $y[0] - $y[1] && $x[0] < $y[0] + $y[1];
    } elsif( $y[1] == 0 ) {
        return $y[0] > $x[0] - $x[1] && $y[0] < $x[0] + $x[1];
    } elsif( $x[0] + $x[1] == $y[0] - $y[1] ||
             $y[0] + $y[1] == $x[0] - $x[1] ) {
        return 0; # Intervals are open (?)
    } else {
        my @edges = (   [ $x[0] - $x[1],  1 ],
                        [ $x[0] + $x[1], -1 ],
                        [ $y[0] - $y[1],  1 ],
                        [ $y[0] + $y[1], -1 ]  );
        my $open_intervals = 0;
        foreach( sort { $a->[0] <=> $b->[0] } @edges) {
            $open_intervals += $_->[1];
            if( $open_intervals > 1 ) { return 1; }
        }
    }
}

# Returns datablock name. Original source data block name, if specified, is
# prefered. If not specified, current data block name is returned.
sub get_source_block_name
{
    my( $datablock ) = @_;
    my $values = $datablock->{values};
    if( exists $values->{'_cod_data_source_block'} ) {
        return $values->{'_cod_data_source_block'}[0];
    }
    if( exists $values->{'_[local]_cod_data_source_block'} ) {
        return $values->{'_[local]_cod_data_source_block'}[0];
    }
    return $datablock->{name};
}
