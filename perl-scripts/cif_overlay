#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Overlay atoms from each pair of CIFs given on the command line.
#**

use strict;
use lib "./lib/perl5";
use lib "../lib/perl5/COD";
use lib "./CIFParser";
use CIFParser;
use SymopAlgebra;
use AtomOverlay;
use Fractional;
use UserMessage;
use ShowStruct;

my $exclude_zero_occupancies = 0;

sub atom_array_from_cif($$);
sub get_unit_cell($$);

while( @ARGV > 0 ) {

    my $filename1 = shift(@ARGV);
    my $filename2 = shift(@ARGV);

    if( !defined $filename2 ) {
        die "Even number of files required on the command line"
    }

    my $parser;

    $parser = new CIFParser;
    my $data1 = $parser->Run($filename1);

    $parser = new CIFParser;
    my $data2 = $parser->Run($filename2);

    if( @$data1 < @$data2 ) {
        warn "file '$filename2' has more data blocks than '$filename1', " .
            "some will stay unused";
    }

    for my $dataset1 (@$data1) {
        my $dataset2 = shift( @$data2 );
        if( !defined $dataset2 ) {
            warn "file '$filename1' has more data blocks than '$filename2'";
            last;
        }
        print $dataset1->{name}, " ", $dataset2->{name}, "\n";
        my $atoms1 = atom_array_from_cif( $dataset1, $filename1 );
        my $atoms2 = atom_array_from_cif( $dataset2, $filename2 );

        print int(@$atoms1), " ", int(@$atoms2), "\n";

        my $overlay_symop = overlay_atoms( $atoms1, $atoms2 );
        print SymopAlgebra::symop_det( $overlay_symop ), "\n";
    }
}

# ============================================================================ #
# Gets atom descriptions, as used in this program, from a CIF datablock.
#
# Returns an array of
#
#   $atom_info = {
#                   site_label=>"C1",
#                   name=>"C1_2",
#                   chemical_type=>"C",
#                   atom_site_type_symbol = "C",
#                   coordinates_fract=>[1.0, 1.0, 1.0],
#                   unity_matrix_applied=>1,
#                   assembly=>"A", # "."
#                   group=>"1", # "."
#                   multiplicity=>"1",
#                   multiplicity_ratio=>"1",
#              }
#
sub atom_array_from_cif($$)
{
    my( $datablock, $filename ) = @_;

    my $values = $datablock->{values};
    my $dataname = $datablock->{name};

    # Get the unit cell information and construct the fract->ortho and
    # ortho->fract conversion matrices:

    my @cell = get_unit_cell( $datablock, $filename );
    my $f2o = symop_ortho_from_fract( @cell );

    # Determine which atom site label tag is present and which can be
    # used for identifying atoms:

    my $atom_site_tag;

    if( exists $values->{"_atom_site_label"} ) {
        $atom_site_tag = "_atom_site_label";
    } elsif( exists $values->{"_atom_site_type_symbol"} ) {
        $atom_site_tag = "_atom_site_type_symbol";

        error( $0, $filename, $dataname,
               "_atom_site_label tag was not found. " .
               "A serial number will be appended " .
               "to _atom_site_type_symbol to make atom labels" );
    } else {
        error( $0, $filename, $dataname,
               "neither _atom_site_type_symbol nor _atom_site_label " .
               "were found" );
	return undef;
    }

    my $atom_labels = $values->{$atom_site_tag};

    my @atom_list;

    for (my $i = 0; $i < @{$atom_labels}; $i++)
    {
        if( $exclude_zero_occupancies &&
            defined $values->{_atom_site_occupancy} ) {
            my $occupancy = $values->{_atom_site_occupancy}[$i];
            $occupancy =~ s/\(\d+\)$//; # remove precission
            if( $occupancy eq "?" || $occupancy eq "." ||
                $occupancy == 0.0 ) {
                next;
            }
        }

        my $label;
        if ( $atom_site_tag eq "_atom_site_type_symbol" ) {
            $label = $values->{$atom_site_tag}[$i] . $i;
        } else {
            $label = $values->{$atom_site_tag}[$i];
        }

        my $atom_info = extract_atom( $label, $values, $i, $f2o );

        if( exists $values->{_atom_site_symmetry_multiplicity} &&
            $values->{_atom_site_symmetry_multiplicity}[$i] ne '?' &&
            $values->{_atom_site_symmetry_multiplicity}[$i] ne '.' ) {
            $atom_info->{_atom_site_symmetry_multiplicity} =
                $values->{_atom_site_symmetry_multiplicity}[$i];
        }

        push( @atom_list, $atom_info );
    }

    return \@atom_list;
}

#===============================================================#
# Extracts atom information from the CIF file.
#
# Accepts
#     values     - a hash where a data from the CIF file is stored
#     atom_label - atom site label or atom site type symbol from the CIF file
#     number     - a number of the current atom
#
# Returns a hash:
#
#             $atom = {
#                       label=>"C1",
#                       site_label=>"C1";
#                       cell_label=>"C1";
#                       chemical_type=>"C",
#                       atom_site_type_symbol = "C",
#                       coordinates_fract=>[1.0, 1.0, 1.0],
#                       assembly=>"A", # "."
#                       group=>"1", # "."
#                     }

sub extract_atom
{
    my($atom_label, $values, $number, $f2o) = @_;

    my %atom_info;
    my @atom_xyz;

    for my $cif_fract ( "_atom_site_fract_x",
                        "_atom_site_fract_y",
                        "_atom_site_fract_z" ) {
        push(@atom_xyz, $values->{$cif_fract}[$number]);
        $atom_xyz[-1] =~ s/\(\d+\)$//;
    }

    $atom_info{"coordinates_fract"}     = \@atom_xyz;
    $atom_info{"name"}                  = $atom_label;
    $atom_info{"site_label"}            = $atom_label;
    $atom_info{"cell_label"}            = $atom_label;

    $atom_info{f2o} = $f2o;
    $atom_info{coordinates_ortho} =
        SymopAlgebra::symop_apply( $f2o, \@atom_xyz );

    my $atom_type;

    if( exists $values->{_atom_site_type_symbol}  &&
        defined $values->{_atom_site_type_symbol}[$number] &&
        $values->{_atom_site_type_symbol}[$number] ne '?' ) {
        $atom_type = $values->{_atom_site_type_symbol}[$number];
        $atom_info{atom_site_type_symbol} = $atom_type;
        if( $atom_type =~ m/^([A-Za-z]{1,2})/ ) {
            $atom_type = ucfirst( lc( $1 ));
        }
    } else {
        if( $values->{_atom_site_label}[$number] =~
            m/^([A-Za-z]{1,2})/ ) {
            $atom_type = ucfirst( lc( $1 ));
        } else {
            die( "could not determine atom type for atom " .
                 "'$values->{_atom_site_label}[$number]'" );
        }
    }

    $atom_info{chemical_type} = $atom_type;

    if( exists $values->{_atom_site_disorder_assembly}[$number]) {
        $atom_info{assembly} =
	    $values->{_atom_site_disorder_assembly}[$number];
    } else {
        $atom_info{assembly} = ".";
    }

    if( exists $values->{_atom_site_disorder_group}[$number] ) {
        $atom_info{group} = $values->{_atom_site_disorder_group}[$number];
    } else {
        $atom_info{group} = ".";
    }

    if( exists $values->{_atom_site_occupancy} ) {
        $atom_info{atom_site_occupancy} =
            $values->{_atom_site_occupancy}[$number];
    }

    if( exists $values->{_atom_site_U_iso_or_equiv} ) {
        $atom_info{atom_site_U_iso_or_equiv} =
            $values->{_atom_site_U_iso_or_equiv}[$number];
    }

    if( exists $values->{_atom_site_symmetry_multiplicity} ) {
        $atom_info{multiplicity} =
            $values->{_atom_site_symmetry_multiplicity}[$number];
    }

    if( exists $values->{_atom_site_attached_hydrogens} ) {
        $atom_info{attached_hydrogens} =
            $values->{_atom_site_attached_hydrogens}[$number];
    }

    if( exists $values->{_atom_site_refinement_flags} ) {
        $atom_info{refinement_flags} =
            $values->{_atom_site_refinement_flags}[$number];
    }

    if( exists $values->{_atom_site_refinement_posn} ) {
        $atom_info{refinement_flags_position} =
            $values->{_atom_site_refinement_posn}[$number];
    }

    if( exists $values->{_atom_site_refinement_adp} ) {
        $atom_info{refinement_flags_adp} =
            $values->{_atom_site_refinement_adp}[$number];
    }

    if( exists $values->{_atom_site_refinement_occupancy} ) {
        $atom_info{refinement_flags_occupancy} =
            $values->{_atom_site_refinement_occupancy}[$number];
    }

    return \%atom_info;
}

#===============================================================#
# Extract unit cell angles and lengths.
#
# Accepts
#     values - a hash where a data from the CIF file is stored
# Returns
#     cell - an array  with stored information.

sub get_unit_cell($$)
{
    my( $datablock, $filename ) = @_;

    my $values = $datablock->{values};
    my $dataname = $datablock->{name};

    my @cell;

    for my $cif_tag (qw(_cell_length_a
                        _cell_length_b
                        _cell_length_c
                        )) {
        push(@cell, $values->{$cif_tag}[0]);
        $cell[-1] =~ s/\(\d+\)$//;
    }

    for my $cif_tag (qw(_cell_angle_alpha
                        _cell_angle_beta
                        _cell_angle_gamma
                        )) {
        if( exists $values->{$cif_tag} ) {
            push( @cell, $values->{$cif_tag}[0] );
            $cell[-1] =~ s/\(\d+\)$//;
        } else {
            warning( $0, $filename, $dataname,
                     "cell angle '$cif_tag' not present -- " .
                     "taking default value 90 degress." );
            push( @cell, 90 );
        }
    }

    return @cell;
}
