#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Overlay atoms from each pair of CIFs given on the command line.
#**

use strict;
use lib "./lib/perl5";
use lib "../lib/perl5/COD";
use lib "./CIFParser";
use CIFParser;
use CIFSymmetryGenerator;
use SymopAlgebra qw( symop_apply symop_mul symop_invert );
use AtomOverlay;
use Fractional;
use UserMessage;
use ShowStruct;

my $exclude_zero_occupancies = 0;

sub atom_array_from_cif($$);

while( @ARGV > 0 ) {

    my $filename1 = shift(@ARGV);
    my $filename2 = shift(@ARGV);

    if( !defined $filename2 ) {
        die "Even number of files required on the command line"
    }

    my $parser;

    $parser = new CIFParser;
    my $data1 = $parser->Run($filename1);

    $parser = new CIFParser;
    my $data2 = $parser->Run($filename2);

    if( @$data1 < @$data2 ) {
        warn "file '$filename2' has more data blocks than '$filename1', " .
            "some will stay unused";
    }

    for my $dataset1 (@$data1) {
        my $dataset2 = shift( @$data2 );
        if( !defined $dataset2 ) {
            warn "file '$filename1' has more data blocks than '$filename2'";
            last;
        }
        print "FILE1\t", $filename1, "\n";
        print "FILE2\t", $filename2, "\n";
        print "DBLOCK1\t", $dataset1->{name}, "\n";
        print "DBLOCK2\t", $dataset2->{name}, "\n";
        my $atoms1 = atom_array_from_cif( $dataset1, $filename1 );
        my $atoms2 = atom_array_from_cif( $dataset2, $filename2 );

        print "ATMCNTS\t", int(@$atoms1), " ", int(@$atoms2), "\n";

        my $overlay_symop = overlay_atoms( $atoms1, $atoms2 );
        printf "RDET\t%8.6f\n", SymopAlgebra::symop_det( $overlay_symop );

        ## use Serialise;
        ## serialiseRef( $atoms1->[0]{f2o} );

        my $fract_overlay = symop_mul( symop_invert($atoms1->[0]{f2o}),
                                       symop_mul( $overlay_symop,
                                                  $atoms1->[0]{f2o} ));

        do {
            local $, = "\t";
            local $\ = "\n";
            printf "SYMOP1\t%9.6f\t%9.6f\t%9.6f\t%9.6f\n", @{$fract_overlay->[0]};
            printf "SYMOP2\t%9.6f\t%9.6f\t%9.6f\t%9.6f\n", @{$fract_overlay->[1]};
            printf "SYMOP3\t%9.6f\t%9.6f\t%9.6f\t%9.6f\n", @{$fract_overlay->[2]};
            print "SYMOP4", @{$fract_overlay->[3]};
        };

        my $atoms1_on_atoms2 = symop_apply_to_atoms( $atoms1, $fract_overlay );

        ## use Serialise;
        ## serialiseRef( $atoms1_on_atoms2 );

        printf "RMS\t%8.6f\n", atom_rms( $atoms2, $atoms1_on_atoms2 );
    }
}

# ============================================================================ #
# Gets atom descriptions, as used in this program, from a CIF datablock.
#
# Returns an array of
#
#   $atom_info = {
#                   site_label=>"C1",
#                   name=>"C1_2",
#                   chemical_type=>"C",
#                   atom_site_type_symbol = "C",
#                   coordinates_fract=>[1.0, 1.0, 1.0],
#                   unity_matrix_applied=>1,
#                   assembly=>"A", # "."
#                   group=>"1", # "."
#                   multiplicity=>"1",
#                   multiplicity_ratio=>"1",
#              }
#
sub atom_array_from_cif($$)
{
    my( $datablock, $filename ) = @_;

    my $values = $datablock->{values};
    my $dataname = $datablock->{name};

    # Get the unit cell information and construct the fract->ortho and
    # ortho->fract conversion matrices:

    my @cell = get_cell( $values, $filename, $dataname );
    my $f2o = symop_ortho_from_fract( @cell );

    push( @{$f2o->[0]}, 0 );
    push( @{$f2o->[1]}, 0 );
    push( @{$f2o->[2]}, 0 );
    push( @$f2o, [0,0,0,1] );

    # Determine which atom site label tag is present and which can be
    # used for identifying atoms:

    my $atom_site_tag;

    if( exists $values->{"_atom_site_label"} ) {
        $atom_site_tag = "_atom_site_label";
    } elsif( exists $values->{"_atom_site_type_symbol"} ) {
        $atom_site_tag = "_atom_site_type_symbol";

        error( $0, $filename, $dataname,
               "_atom_site_label tag was not found. " .
               "A serial number will be appended " .
               "to _atom_site_type_symbol to make atom labels" );
    } else {
        error( $0, $filename, $dataname,
               "neither _atom_site_type_symbol nor _atom_site_label " .
               "were found" );
	return undef;
    }

    my $atom_labels = $values->{$atom_site_tag};

    my @atom_list;

    for (my $i = 0; $i < @{$atom_labels}; $i++)
    {
        if( $exclude_zero_occupancies &&
            defined $values->{_atom_site_occupancy} ) {
            my $occupancy = $values->{_atom_site_occupancy}[$i];
            $occupancy =~ s/\(\d+\)$//; # remove precission
            if( $occupancy eq "?" || $occupancy eq "." ||
                $occupancy == 0.0 ) {
                next;
            }
        }

        my $label;
        if ( $atom_site_tag eq "_atom_site_type_symbol" ) {
            $label = $values->{$atom_site_tag}[$i] . $i;
        } else {
            $label = $values->{$atom_site_tag}[$i];
        }

        my $atom_info = extract_atom( $label, $values, $i, $f2o );

        if( exists $values->{_atom_site_symmetry_multiplicity} &&
            $values->{_atom_site_symmetry_multiplicity}[$i] ne '?' &&
            $values->{_atom_site_symmetry_multiplicity}[$i] ne '.' ) {
            $atom_info->{_atom_site_symmetry_multiplicity} =
                $values->{_atom_site_symmetry_multiplicity}[$i];
        }

        push( @atom_list, $atom_info );
    }

    return \@atom_list;
}

#===============================================================#
# Extracts atom information from the CIF file.
#
# Accepts
#     values     - a hash where a data from the CIF file is stored
#     atom_label - atom site label or atom site type symbol from the CIF file
#     number     - a number of the current atom
#
# Returns a hash:
#
#             $atom = {
#                       label=>"C1",
#                       site_label=>"C1";
#                       cell_label=>"C1";
#                       chemical_type=>"C",
#                       atom_site_type_symbol = "C",
#                       coordinates_fract=>[1.0, 1.0, 1.0],
#                       assembly=>"A", # "."
#                       group=>"1", # "."
#                     }

sub extract_atom
{
    my($atom_label, $values, $number, $f2o) = @_;

    my %atom_info;
    my @atom_xyz;

    for my $cif_fract ( "_atom_site_fract_x",
                        "_atom_site_fract_y",
                        "_atom_site_fract_z" ) {
        push(@atom_xyz, $values->{$cif_fract}[$number]);
        $atom_xyz[-1] =~ s/\(\d+\)$//;
    }

    $atom_info{"coordinates_fract"}     = \@atom_xyz;
    $atom_info{"name"}                  = $atom_label;
    $atom_info{"site_label"}            = $atom_label;
    $atom_info{"cell_label"}            = $atom_label;

    $atom_info{f2o} = $f2o;
    $atom_info{coordinates_ortho} =
        SymopAlgebra::symop_apply( $f2o, \@atom_xyz );

    my $atom_type;

    if( exists $values->{_atom_site_type_symbol}  &&
        defined $values->{_atom_site_type_symbol}[$number] &&
        $values->{_atom_site_type_symbol}[$number] ne '?' ) {
        $atom_type = $values->{_atom_site_type_symbol}[$number];
        $atom_info{atom_site_type_symbol} = $atom_type;
        if( $atom_type =~ m/^([A-Za-z]{1,2})/ ) {
            $atom_type = ucfirst( lc( $1 ));
        }
    } else {
        if( $values->{_atom_site_label}[$number] =~
            m/^([A-Za-z]{1,2})/ ) {
            $atom_type = ucfirst( lc( $1 ));
        } else {
            die( "could not determine atom type for atom " .
                 "'$values->{_atom_site_label}[$number]'" );
        }
    }

    $atom_info{chemical_type} = $atom_type;

    if( exists $values->{_atom_site_disorder_assembly}[$number]) {
        $atom_info{assembly} =
	    $values->{_atom_site_disorder_assembly}[$number];
    } else {
        $atom_info{assembly} = ".";
    }

    if( exists $values->{_atom_site_disorder_group}[$number] ) {
        $atom_info{group} = $values->{_atom_site_disorder_group}[$number];
    } else {
        $atom_info{group} = ".";
    }

    if( exists $values->{_atom_site_occupancy} ) {
        $atom_info{atom_site_occupancy} =
            $values->{_atom_site_occupancy}[$number];
    }

    if( exists $values->{_atom_site_U_iso_or_equiv} ) {
        $atom_info{atom_site_U_iso_or_equiv} =
            $values->{_atom_site_U_iso_or_equiv}[$number];
    }

    if( exists $values->{_atom_site_symmetry_multiplicity} ) {
        $atom_info{multiplicity} =
            $values->{_atom_site_symmetry_multiplicity}[$number];
    }

    if( exists $values->{_atom_site_attached_hydrogens} ) {
        $atom_info{attached_hydrogens} =
            $values->{_atom_site_attached_hydrogens}[$number];
    }

    if( exists $values->{_atom_site_refinement_flags} ) {
        $atom_info{refinement_flags} =
            $values->{_atom_site_refinement_flags}[$number];
    }

    if( exists $values->{_atom_site_refinement_posn} ) {
        $atom_info{refinement_flags_position} =
            $values->{_atom_site_refinement_posn}[$number];
    }

    if( exists $values->{_atom_site_refinement_adp} ) {
        $atom_info{refinement_flags_adp} =
            $values->{_atom_site_refinement_adp}[$number];
    }

    if( exists $values->{_atom_site_refinement_occupancy} ) {
        $atom_info{refinement_flags_occupancy} =
            $values->{_atom_site_refinement_occupancy}[$number];
    }

    return \%atom_info;
}

#===============================================================#
# Apply symmetry operator to all atoms in the list
#
# Accepts
#     $atoms -- a reference to an atom array
#     $symop -- a symmetry operator to be applied to all atoms
# Returns
#     a reference to an array with copies of atoms transformed 
#     by $symop.

sub symop_apply_to_atoms
{
    my ($atoms, $symop) = @_;

    my @applied;

    for my $atom (@{$atoms}) {
        my %new_atom = %$atom;

        $new_atom{coordinates_fract} =
            symop_apply( $symop, $atom->{coordinates_fract} );

        $new_atom{coordinates_ortho} =
            symop_apply( $atom->{f2o}, $new_atom{coordinates_fract} );

        push( @applied, \%new_atom );
    }

    return \@applied;
}

#===============================================================#
# Apply symmetry operator to all atoms in the list
#
# Accepts
#     $atoms1, $atoms2 -- references to two atom arrays
# Returns
#     an RMS deviation between atoms
sub atom_rms
{
    my ( $atoms1, $atoms2 ) = @_;

    my $N = @$atoms1 < @$atoms2 ? @$atoms1 : @$atoms2;
    my $sum = 0.0;

    return 0.0 if $N == 0;

    for( my $i = 0; $i < $N; $i++ ) {
        my $a1 = $atoms1->[$i];
        my $a2 = $atoms2->[$i];

        $sum +=
            ($a1->{coordinates_ortho}[0]-$a2->{coordinates_ortho}[0])**2 +
            ($a1->{coordinates_ortho}[1]-$a2->{coordinates_ortho}[1])**2 +
            ($a1->{coordinates_ortho}[2]-$a2->{coordinates_ortho}[2])**2;
    }
    return sqrt($sum/$N);
}
