#!/usr/bin/perl

#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Rev$
#$URL$
#------------------------------------------------------------------------------
#*
#   Calculates minimal distance between atoms read from a cif file.
#**

use lib "../../CIFData";
use lib "../../CIFParser";
use lib "../../Spacegroups";
use lib "../../lib/perl5";
use lib "../../../trunk";
use lib "../../perl-scripts";
use strict;
use warnings;
use CIFCellContents;
use CIFParser;
use Fractional;
use Spacegroups::SymopParse;
use Spacegroups::SpacegroupNames;
use CIFData::CIFSymmetryGenerator;
use SOptions;
use SUsage;

my $silence_dist_matrix;
my $print_original_atoms;
my $print_symmetrical_atoms;
my $print_shifted_atoms;
my $fraction_precision = 3;
my $line_length = 80;
my $print_paired;

@ARGV = getOptions( 
    "-m,--silence-dist-matrix"    => sub { $silence_dist_matrix = 1; },
    "-p,--print-paired-distance"  => sub { $print_paired = 1 },
    "-o,--print-original-atoms"   => sub { $print_original_atoms = 1 },
    "-s,--print-symetrical-atoms" => sub { $print_symmetrical_atoms = 1 },
    "-h,--print-shifted-atoms"    => sub { $print_shifted_atoms = 1 },
    "-d,--precision"              => sub { $fraction_precision = get_value() },
    "-l,--matrix-line-length"     => sub { $line_length = get_value() },
    "--help,--usage"               => sub { SUsage::usage; exit },
);

#*
#   -m, --silence-dist-matrix       do not output distance matrix.
#   -p, --print-paired-distance     print distances in alternative 
#                                   format displaying each atom line and
#                                   the distance between then in a 
#                                   separate line.
#   -o, --print-original-atoms      print atoms read from cif file.
#   -s, --print-symetrical-atoms    print atoms generated by applying
#                                   symmetry operators.
#   -h, --print-shifted-atoms       print atoms generated by shifting
#                                   all the atoms of the first octant.
#   -d, --precision                 number of fraction digits displayed  
#                                   in distance matrix distances.
#   -l, --matrix-line-length        maximum length of an output line in
#                                   distance matrix.
#   --help,--usage                  prints this message and quits.
#**

my $filename = shift( @ARGV );

my $parser = new CIFParser;

my $data = $parser->Run( $filename );

my $dataset = @$data[ 0 ];

my $values = $dataset->{values};

#   extracts atom site label or atom site type symbol
my $loop_tag;

if( exists $values->{ "_atom_site_label" } ) {
    $loop_tag = "_atom_site_label";
    } elsif( exists $values->{ "_atom_site_type_symbol" } ) {
        $loop_tag = "_atom_site_type_symbol";
    } else {
        error( $0, $filename, $dataset->{name},
               "neither _atom_site_label " .
               "nor _atom_site_type_symbol was found in the input file" );
        return undef;
}

#   extracts cell constants
my @unit_cell =
    CIFSymmetryGenerator::get_cell( $values, $filename, $dataset->{name} );

my $ortho_matrix = symop_ortho_from_fract( @unit_cell );

#   extracts symmetry operators
my $sym_data =
    CIFSymmetryGenerator::get_symmetry_operators( $dataset, $filename );

#   extracts atoms
my $atoms = CIFCellContents::get_atoms( $dataset, $filename, $loop_tag );

my $printable_properties = [ "atom_name", "atom_type", 
                             "coordinates_ortho", "coordinates_fract" ];

if ( $print_original_atoms ) {
    print_atoms( $atoms, $printable_properties );
}

#   generates atoms by applying symmetry operators.
#   at this subroutine original atoms are fitted into the first octant
#   by applying x,y,z operator modulus 1

my ( $sym_atoms, $symmetry_operator_count ) = generate_symmetrical_atoms( 
                                               $sym_data, 
                                               $atoms, 
                                               $ortho_matrix 
                                               );

push @$printable_properties, "sym_operator";
if ( $print_symmetrical_atoms ) {
    print_atoms( $sym_atoms, $printable_properties );
}

my @shifted_atoms = map { shift_atom( $_ ) } @{$sym_atoms};

push @$printable_properties, "shift_vector";
if ( $print_shifted_atoms ) {
    print_atoms( \@shifted_atoms, $printable_properties );
}

my ( $distances, $headers, $atoms_used ) = get_distances( \@shifted_atoms, 
                                                $symmetry_operator_count );

if ( !$silence_dist_matrix ) {
    print_distance_matrix( $distances, $headers, $fraction_precision, 
                           $line_length );
}

if ( $print_paired ) {
    print_paired( $distances, $atoms_used );
}

exit;

##
# Generates symmetrical atoms from the given original atoms and 
# symmetry operators.
# @param $sym_data
#       Reference to an array containing symmetry operators in string 
#       format.
# @param $atoms
#       Reference to an array of original atoms. 
# @param $ortho_matrix
#       Reference to a struture containing matrix, that is used to
#       convert fractional coordinates to orthogonal in the newly
#       generated atoms.
#  @return
#       Reference to an array containing atoms generated by applying 
#       symmetry operators. Each atom hash is given a new field 
#       "sym_operator".
##

sub generate_symmetrical_atoms {
    my ( $sym_data, $atoms, $ortho_matrix ) = @_;

    #   computes symmetry operator matrices
    my @sym_operators = map { SymopParse::symop_from_string($_) } @{$sym_data};
    
    my $sym_atoms = CIFSymmetryGenerator::symop_generate_atoms( 
                                                    \@sym_operators, 
                                                    $atoms,
                                                    $ortho_matrix );

    #It might be better to make a copy of the symop_generate_atoms 
    #subroutine and add the symmetry opperator directly there    
    my $i = 0;
    foreach ( @{ $sym_atoms } ) {
        $_ -> { "sym_operator" } = @$sym_data[ $i ];
        
        $i++;
        if ( $i >= @$sym_data ) {
            $i = 0;
        };
    }    

    return $sym_atoms, scalar( @sym_operators );
}

##
# Calculates the minimum distance between two atoms from the given array.
# It is expected that atoms, derived from the original atom by applying
# symmetry operator and shifting operators, are put near each other in the 
# array, making clusters of size $syum_operator_count * 27 (number of 
# octants). Since all atoms of the cluster are derived from one original 
# atom, distances between them are not calculated.
# @param $all_atom
#       Reference to an array containing all atoms generated after 
#       applying symmetry and shift operators.
# @param $sym_operator_count
#       Number of symmetry operators that have been applied.
##

sub get_distances {
    my ( $all_atoms, $sym_operator_count ) = @_; 
    my $cluster_size = $sym_operator_count * 27; #27 is the number of octants
    my @headers;
    my @distances;
    my @atoms_used;
 
    for ( my $i  = 0; $i < @$all_atoms; $i += $cluster_size ) {
        my $atom1 = $all_atoms -> [ $i ];
        push @headers, "$atom1->{atom_name}/$atom1->{atom_type}";
        my @atom_rows_used;
        push @atom_rows_used, $atom1;
        my @distance_row = ();
        push @distance_row, 0;
        my $processed_atom_number = $cluster_size;
        for ( my $j = $i + $cluster_size; $j < @$all_atoms; $j++ ) {
            my $atom2 = $all_atoms -> [ $j ];
            my $distance = get_distance( $atom1->{coordinates_ortho}, 
                                         $atom2->{coordinates_ortho} );
            if ( !defined( $distance_row[ floor( $processed_atom_number / $cluster_size ) ] ) ||
                $distance_row[ floor( $processed_atom_number / $cluster_size ) ] > $distance ) {
                $distance_row[ floor( $processed_atom_number / $cluster_size ) ] = $distance;
                $atom_rows_used[ floor( $processed_atom_number / $cluster_size ) ] = $atom2;
            }
            $processed_atom_number++;
        }
        push @distances, \@distance_row;
        push @atoms_used, \@atom_rows_used;
    }
return ( \@distances, \@headers, \@atoms_used );
}

##
# Calculates distance between two equal length vectors.
# @param $vector1
#       Reference to an array of coordinates of the first vector.
# @param $vector2
#       Reference to an array of coordinates of the second vector.
# @return
#       Distance between vectors.
##

sub get_distance {
    my ( $vector1, $vector2 ) = @_;
    my $dist = 0;

    for ( my $i = 0; $i < @{$vector1}; $i++ ) {
        $dist += ( ${$vector1}[ $i ] - ${$vector2}[ $i ] ) ** 2;
    }
    return sqrt( $dist );
}

##
# Returns an array of atom hashes generated by shifting the original 
# atom in 26 directions (3-D space).
# @param $atom_ref
#       Reference to a hash, containing atom information.
# @return @shifted_atoms;
#       Array of atom hashes.
##

sub shift_atom {
    my ( $atom_ref ) = @_;

    $atom_ref->{ "shift_vector" } = [ 5, 5, 5 ];
    my @shifted_atoms;
    push @shifted_atoms, $atom_ref;
    my @shifting_params = ( -1, 0, 1 );
    
    for( my $i = 0; $i < @shifting_params; $i++ ) {
        for( my $j = 0; $j < @shifting_params; $j++ ) {
            for( my $k = 0; $k < @shifting_params; $k++ ) {
                my %new_atom;
                my @new_atom_xyz;
                if( $shifting_params[ $i ] != 0 || 
                    $shifting_params[ $j ] != 0 ||
                    $shifting_params[ $k ] != 0 ) {
                    $new_atom_xyz[ 0 ] =
                        $atom_ref->{ "coordinates_fract" }[ 0 ] +  
                                     $shifting_params[ $i ];
                    $new_atom_xyz[ 1 ] =
                        $atom_ref->{ "coordinates_fract" }[ 1 ] +  
                                     $shifting_params[ $j ];
                    $new_atom_xyz[ 2 ] =
                        $atom_ref->{ "coordinates_fract" }[ 2 ] +  
                                     $shifting_params[ $k ];
            
                    $new_atom{ "coordinates_fract" } = \@new_atom_xyz;
                    $new_atom {coordinates_ortho} =
                    CIFSymmetryGenerator::mat_vect_mul( $ortho_matrix,
                    $new_atom {coordinates_fract} );
                    $new_atom{ "atom_type" } = $atom_ref->{ "atom_type" };
                    $new_atom{ "atom_name" } = $atom_ref->{ "atom_name" };
                    $new_atom{ "sym_operator" } = $atom_ref->{ "sym_operator" };
                    $new_atom{ "shift_vector" } = [ 5 + $shifting_params[ $i ],
                                                    5 + $shifting_params[ $j ],
                                                    5 + $shifting_params[ $k ]
                                                  ];
                    push( @shifted_atoms, \%new_atom );
                }
            }
        }
    }

    return @shifted_atoms;
}

##
# Prints atoms fieldname values from an array.
# @param $array_ref
#       Reference to an array from which the atoms are printed.  
##

sub print_atoms {
    my ( $array_ref, $properties ) = @_;
    foreach my $atom_ref ( @$array_ref ) {
        foreach my $property ( @$properties ) {
            if ( $property eq "atom_name" ) {
                print "Atom name: $atom_ref->{atom_name} \n";
            } elsif ( $property eq "atom_type" ) {
                print "Atom type: $atom_ref->{atom_type} \n";
            } elsif ( $property eq "occupancy" ) {
                print "Ocupancy: $atom_ref->{occupancy} \n";
            } elsif ( $property eq "cif_multiplicity" ) {
                print "cif_multiplicity: " . 
                      "$atom_ref->{cif_multiplicity} \n";
            } elsif ( $property eq "coordinates_ortho" ) {
                print "Orthogonal coordinates: " . 
                "@{ $atom_ref->{coordinates_ortho} } \n";
            } elsif ( $property eq "coordinates_fract" ) {
                print "Fractional coordinates: " .
                "@{ $atom_ref->{coordinates_fract} } \n";
            } elsif ( $property eq "shift_vector" ) {
                print "Shift vector: " .
                "@{ $atom_ref->{shift_vector} } \n";
            } elsif ( $property eq  "sym_operator" ) {
                print "Symmetry operator: " . 
                      "$atom_ref->{sym_operator} \n";
            }
        }
    }
}

##
# Prints distances between atoms in the default format, defined in
# cod-tools/trunk/perl-scripts/cif-distances/cif-distances_matrix_v.1
# @param $distance_ref
#       Reference to an array distances between atoms.
# @param $header_ref;
#       Reference to an array of strings containing information about 
#       atoms that were used in the calculation of distances.
#       of the distances.
# @param $fraction_precision
#       Number of fraction digits of the distances that should be printed.
# @param $line_length
#       Length of the matrix line in symbols.
##

sub print_distance_matrix {
    my ( $distance_ref, $header_ref, $fraction_precision, 
         $line_length ) = @_;
    my @distances = @$distance_ref;
    my $cell_width = 11;
    use POSIX;
    my $cell_count = floor ( $line_length / $cell_width ) - 1;
    
    print "The following output format is defined in " .
    "cod-tools/trunk/perl-scripts/cif-distances/cif-distances_matrix_v.1 \n";
    my $print_iteration = 0;
    while ( $print_iteration < ceil( @distances / $cell_count ) ) {
        my $start_cell_index = $cell_count * $print_iteration;
        my $finish_cell_index = $cell_count * ( $print_iteration + 1 );
        if ( $finish_cell_index > @distances ) {
            $finish_cell_index = @distances;
        }
        
        printf( "%-${cell_width}s", "ATOMS" );
        for ( my $k = $start_cell_index; $k < $finish_cell_index; $k++ ) {
            printf( "%-${cell_width}s", @$header_ref[ $k ] );
        }
        print "\n";
        
        for ( my $i = 0; $i < @distances; $i++ ) {
            printf( "%-${cell_width}s", @$header_ref[ $i ] );
            for ( my $j = $start_cell_index; $j < $finish_cell_index; $j++ ) {
                if ( $i == $j ) {
                    printf( "%-${cell_width}.${fraction_precision}f", 
                            0 )
                } elsif ( $j > $i ) {
                    printf( "%-${cell_width}.${fraction_precision}f", 
                            $distances[ $i ][ $j - $i ] );
                } else {
                    printf( "%-${cell_width}.${fraction_precision}f", 
                            $distances[ $j ][ $i - $j ] );
                }
            };
            print "\n";
        }
        
        print "\n";
        $print_iteration++;
    }
}

##
# Prints distances between atoms in an alternative format, defined in
# cod-tools/trunk/perl-scripts/cif-distances/cif-distances_paired_v.1
# @param $distances
#       Reference to an array distances between atoms.
# @param $atoms_used
#       Reference to an array of atoms that were used in the calculation
#       of the distances.
##

sub print_paired {
    my ( $distances, $atoms_used ) = @_;
    
    print "The following output format is defined in " .
    "cod-tools/trunk/perl-scripts/cif-distances/cif-distances_paired_v.1 \n";
    
    for ( my $i = 0; $i < @$atoms_used; $i++ ) {
        my $atom_1 = @$atoms_used[ $i ] -> [ 0 ];

        for ( my $j = 1; $j < @{ @$atoms_used[ $i ] }; $j++ ) {
            my $atom_2 = @$atoms_used[ $i ] -> [ $j ];
            printf( 'DIST %-6.3f ATOM_1 %8s ATOM_2 %8s SYMOP %8s ' .
                    'SHIFT %s', 
                    @$distances[ $i ] -> [ $j ], 
                    $atom_1 -> { atom_name }."/".$atom_1 -> {atom_type},
                    $atom_2 -> { atom_name }."/".$atom_2 -> {atom_type},
                    $atom_2 -> { sym_operator },
                    "@{$atom_2 -> { shift_vector }}"
                    );
            print "\n";
        }
    }
}
