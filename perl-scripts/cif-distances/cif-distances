#!/usr/bin/perl

#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Rev$
#$URL$
#------------------------------------------------------------------------------
#*
#   Calculates minimal distance between atoms read from a cif file.
#**

use lib "./CIFData";
use lib "./CIFParser";
use lib "./Spacegroups";
use lib "./lib/perl5";
use lib "./trunk";
use lib "./perl-scripts";
use strict;
use warnings;
use CIFCellContents;
use CIFParser;
use Fractional;
use Spacegroups::SymopParse;
use Spacegroups::SpacegroupNames;
use CIFData::CIFSymmetryGenerator;
use UserMessage;

sub shift_atom( $ );
sub print_atoms( $ );

my $filename = shift(@ARGV);

my $parser = new CIFParser;

my $data = $parser->Run($filename);

my $dataset = @$data[0];

my $values = $dataset->{values};

#   extracts atom site label or atom site type symbol
my $loop_tag;

if( exists $values->{"_atom_site_label"} ) {
    $loop_tag = "_atom_site_label";
    } elsif( exists $values->{"_atom_site_type_symbol"} ) {
        $loop_tag = "_atom_site_type_symbol";
    } else {
        error( $0, $filename, $dataset->{name},
               "neither _atom_site_label " .
               "nor _atom_site_type_symbol was found in the input file" );
        return undef;
}

#   extracts cell constants
my @unit_cell =
    CIFSymmetryGenerator::get_cell( $values, $filename, $dataset->{name} );

my $ortho_matrix = symop_ortho_from_fract( @unit_cell );

#   extracts symmetry operators
my $sym_data =
    CIFSymmetryGenerator::get_symmetry_operators( $dataset, $filename );

#   extract atoms
my $atoms = CIFCellContents::get_atoms( $dataset, $filename, $loop_tag );

#   compute symmetry operator matrices
my @sym_operators = map { SymopParse::symop_from_string($_) } @{$sym_data};

    ## serialiseRef( \@sym_operators );

my $sym_atoms =
    CIFSymmetryGenerator::symop_generate_atoms( \@sym_operators, $atoms,
                                                    $ortho_matrix );

my @shifted_atoms;

foreach my $atom ( @$sym_atoms ) {
    push ( @shifted_atoms, shift_atom( $atom ) );
}

foreach my $atom ( @shifted_atoms ) {
    $atom->{coordinates_ortho} =
        CIFSymmetryGenerator::mat_vect_mul( $ortho_matrix,
                                            $atom->{coordinates_fract} );
}

push ( @shifted_atoms, @$sym_atoms );

print "Number of atoms after applying symmetry operators: " .
       scalar( @$sym_atoms ) . "\n";
print "Number of atoms after shifting ( without initial atoms): " .
       scalar( @shifted_atoms ) . "\n";

print_atoms( \@shifted_atoms );

exit;

##
#
##

sub get_distance {
    my ( $vector1, $vector2 ) = @_;
    my $dist = 0;

    for ( my $i = 0; $i < @{$vector1}; $i++ ) {
        $dist += (${$vector1}[ $i ] - ${$vector2}[ $i ]) ** 2;
    }
    return sqrt( $dist );
}

}

##
# Returns an array of atom hashes generated by shifting the original 
# atom in 26 directions (3-D space).
# @param $atom_ref
#       Reference to a hash, containing atom information.
# @return @shifted_atoms;
#       Array of atom hashes.
##

sub shift_atom( $ ) {
    my ( $atom_ref ) = @_;

    $atom_ref->{ "shift_vector" } = [ 0, 0, 0 ];
    my @shifted_atoms;
    my @shifting_params = ( -1, 0, 1 );
    
    for( my $i = 0; $i < @shifting_params; $i++ ) {
        for( my $j = 0; $j < @shifting_params; $j++ ) {
            for( my $k = 0; $k < @shifting_params; $k++ ) {
                my %new_atom_info;
                my @new_atom_xyz;
                if( $shifting_params[ $i ] != 0 || 
                    $shifting_params[ $j ] != 0 ||
                    $shifting_params[ $k ] != 0 ) {
                    $new_atom_xyz[ 0 ] =
                        $atom_info->{ "coordinates_fract" }[ 0 ] +  $shifting_params[$i];
                    $new_atom_xyz[ 1 ] =
                        $atom_info->{ "coordinates_fract" }[ 1 ] +  $shifting_params[$j];
                    $new_atom_xyz[ 2 ] =
                        $atom_info->{ "coordinates_fract" }[ 2 ] +  $shifting_params[$k];

                    $new_atom_info{ "coordinates_fract" } = \@new_atom_xyz;
                    $new_atom_info{ "atom_type" } =
                                                  $atom_info->{ "atom_type" };
                    $new_atom_info{ "atom_name" } = $atom_info->{ "atom_name" };
                    $new_atom_info{ "shift_vector" } = [ $shifting_params[ $i ],
                                                         $shifting_params[ $j ],
                                                         $shifting_params[ $k ]
                                                       ];
                    push( @shifted_atoms, \%new_atom_info );
                }
            }
        }
    }

    return @shifted_atoms;
}

##
# Prints atoms fieldname values from an array.
# @param $array_ref
#       Reference to an array from which the atoms are printed.  
##

sub print_atoms( $ ) {
    my ( $array_ref ) = @_;
    foreach my $atom_ref ( @$array_ref ) {
        print "Atom name:" .
              " $atom_ref->{atom_name} \n";
        print "Atom type:" .
              " $atom_ref->{atom_type} \n";
    #    print "Ocupancy:" .
    #          " $atom_ref->{occupancy} \n";
    #    print "cif_multiplicity:" .
    #          " $atom_ref->{cif_multiplicity} \n";
        print "Orthogonal coordinates:" . 
              " @{ $atom_ref->{coordinates_ortho} } \n";
        print "Fractional coordinates:" .
              " @{ $atom_ref->{coordinates_fract} } \n";
        print "Shift vector:" .
              "@{ $atom_ref->{shift_vector} } \n";
    }
}
