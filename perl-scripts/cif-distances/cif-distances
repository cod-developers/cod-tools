#!/usr/bin/perl

#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Rev$
#$URL$
#------------------------------------------------------------------------------
#*
#   Calculates minimal distance between atoms read from a cif file.
#**

use lib "./CIFData";
use lib "./CIFParser";
use lib "./Spacegroups";
use lib "./lib/perl5";
use lib "./trunk";
use lib "./perl-scripts";
use strict;
use warnings;
use CIFCellContents;
use CIFParser;
use Fractional;
use Spacegroups::SymopParse;
use Spacegroups::SpacegroupNames;
use CIFData::CIFSymmetryGenerator;
use UserMessage;

my $filename = shift(@ARGV);

my $parser = new CIFParser;

my $data = $parser->Run($filename);

my $dataset = @$data[0];

my $values = $dataset->{values};

#   extracts atom site label or atom site type symbol
my $loop_tag;

if( exists $values->{"_atom_site_label"} ) {
    $loop_tag = "_atom_site_label";
    } elsif( exists $values->{"_atom_site_type_symbol"} ) {
        $loop_tag = "_atom_site_type_symbol";
    } else {
        error( $0, $filename, $dataset->{name},
               "neither _atom_site_label " .
               "nor _atom_site_type_symbol was found in the input file" );
        return undef;
}

#   extracts cell constants
my @unit_cell =
    CIFSymmetryGenerator::get_cell( $values, $filename, $dataset->{name} );

my $ortho_matrix = symop_ortho_from_fract( @unit_cell );

#   extracts symmetry operators
my $sym_data =
    CIFSymmetryGenerator::get_symmetry_operators( $dataset, $filename );

#print @$sym_data;

#   extract atoms
my $atoms = CIFCellContents::get_atoms( $dataset, $filename, $loop_tag );

#   compute symmetry operator matrices
my @sym_operators = map { SymopParse::symop_from_string($_) } @{$sym_data};

my $sym_atoms =
    CIFSymmetryGenerator::symop_generate_atoms( \@sym_operators, $atoms,
                                                    $ortho_matrix );
                                                    
$atoms = CIFSymmetryGenerator::symop_generate_atoms( [ SymopParse::symop_from_string( "x,y,z" ) ], 
                                                        $atoms, $ortho_matrix );
#print_atoms( $atoms );
#print "\n-------------\n";
#print_atoms( $sym_atoms );

my @shifted_atoms;

foreach my $atom ( @$sym_atoms ) {
    push ( @shifted_atoms, shift_atom( $atom ) );
}

foreach my $atom ( @shifted_atoms ) {
    $atom->{coordinates_ortho} =
        CIFSymmetryGenerator::mat_vect_mul( $ortho_matrix,
                                            $atom->{coordinates_fract} );
}

my @headers;
my @distances;

for ( my $i = 0; $i < scalar( @$atoms ); $i++ ){
    my $atom1 = $atoms->[ $i ];
    #my ( $x1, $y1, $z1 ) = ( $atom1{'x'}, $atom1{'y'}, $atom1{'z'} );
    my @distances_row = ();
    push @headers, "$atom1->{atom_name}/$atom1->{atom_type}";
    for ( my $j = $i; $j < scalar( @$atoms) ; $j++ ) { 
        my $atom2 = $atoms->[ $j ];
        push @distances_row, get_distance( $atom1->{coordinates_ortho}, 
                                           $atom2->{coordinates_ortho} );
    }
    push @distances, \@distances_row;
}


push ( @shifted_atoms, @$sym_atoms );

#print "Number of atoms after applying symmetry operators: " .
#       scalar( @$sym_atoms ) . "\n";
#print "Number of atoms after shifting ( without initial atoms): " .
#       scalar( @shifted_atoms ) . "\n";

#print_atoms( \@shifted_atoms );

print_distances(\@distances, \@headers );

exit;

sub get_distances {
    
   # for ( )
}

##
# Calculates distance between two equal length vectors.
# @param $vector1
#       Reference to an array of coordinates of the first vector.
# @param $vector2
#       Reference to an array of coordinates of the second vector.
# @return
#       Distance between vectors.
##

sub get_distance {
    my ( $vector1, $vector2 ) = @_;
    my $dist = 0;

    for ( my $i = 0; $i < @{$vector1}; $i++ ) {
        $dist += (${$vector1}[ $i ] - ${$vector2}[ $i ]) ** 2;
    }
    return sqrt( $dist );
}

##
# Returns an array of atom hashes generated by shifting the original 
# atom in 26 directions (3-D space).
# @param $atom_ref
#       Reference to a hash, containing atom information.
# @return @shifted_atoms;
#       Array of atom hashes.
##

sub shift_atom {
    my ( $atom_ref ) = @_;

    $atom_ref->{ "shift_vector" } = [ 0, 0, 0 ];
    my @shifted_atoms;
    my @shifting_params = ( -1, 0, 1 );
    
    for( my $i = 0; $i < @shifting_params; $i++ ) {
        for( my $j = 0; $j < @shifting_params; $j++ ) {
            for( my $k = 0; $k < @shifting_params; $k++ ) {
                my %new_atom;
                my @new_atom_xyz;
                if( $shifting_params[ $i ] != 0 || 
                    $shifting_params[ $j ] != 0 ||
                    $shifting_params[ $k ] != 0 ) {
                    $new_atom_xyz[ 0 ] =
                        $atom_ref->{ "coordinates_fract" }[ 0 ] +  
                                     $shifting_params[$i];
                    $new_atom_xyz[ 1 ] =
                        $atom_ref->{ "coordinates_fract" }[ 1 ] +  
                                     $shifting_params[$j];
                    $new_atom_xyz[ 2 ] =
                        $atom_ref->{ "coordinates_fract" }[ 2 ] +  
                                     $shifting_params[$k];

                    $new_atom{ "coordinates_fract" } = \@new_atom_xyz;
                    $new_atom{ "atom_type" } =
                                                  $atom_ref->{ "atom_type" };
                    $new_atom{ "atom_name" } = $atom_ref->{ "atom_name" };
                    $new_atom{ "shift_vector" } = [ $shifting_params[ $i ],
                                                    $shifting_params[ $j ],
                                                    $shifting_params[ $k ]
                                                  ];
                    push( @shifted_atoms, \%new_atom );
                }
            }
        }
    }

    return @shifted_atoms;
}

##
# Prints atoms fieldname values from an array.
# @param $array_ref
#       Reference to an array from which the atoms are printed.  
##

sub print_atoms {
    my ( $array_ref ) = @_;
    foreach my $atom_ref ( @$array_ref ) {
        print "Atom name:" .
              " $atom_ref->{atom_name} \n";
        print "Atom type:" .
              " $atom_ref->{atom_type} \n";
    #    print "Ocupancy:" .
    #          " $atom_ref->{occupancy} \n";
    #    print "cif_multiplicity:" .
    #          " $atom_ref->{cif_multiplicity} \n";
        print "Orthogonal coordinates:" . 
              " @{ $atom_ref->{coordinates_ortho} } \n";
        print "Fractional coordinates:" .
              " @{ $atom_ref->{coordinates_fract} } \n";
    #    print "Shift vector:" .
    #          "@{ $atom_ref->{shift_vector} } \n";
    }
}

sub print_distances {
    my ( $distance_ref, $header_ref ) = @_;
    my @distances = @$distance_ref;
    my $line_width = 80;
    my $cell_width = 11;
    use POSIX;
    my $cell_count = floor ( $line_width / $cell_width ) - 1;
    
    my $print_iteration = 0;
    while ( $print_iteration < ceil( @distances / $cell_count ) ) {
        my $start_cell_index = $cell_count * $print_iteration;
        my $finish_cell_index = $cell_count * ( $print_iteration + 1 );
        if ( $finish_cell_index > @distances ) {
            $finish_cell_index = @distances;
        }
        
        printf( "%-${cell_width}s", "ATOMS" );
        for ( my $k = $start_cell_index; $k < $finish_cell_index; $k++ ) {
            printf( "%-${cell_width}s", @$header_ref[ $k ] );
        }
        print "\n";
        
        for ( my $i = 0; $i < @distances; $i++ ) {
            printf( "%-${cell_width}s", @$header_ref[ $i ] );
            for ( my $j = $start_cell_index; $j < $finish_cell_index; $j++ ) {
                if ( $j >= $i ) {
                    printf( "%-${cell_width}.3f", $distances[ $i ][ $j - $i ] );
                } else {
                    printf( "%-${cell_width}.3f", $distances[ $j ][ $i - $j ] );
                }
            };
            print "\n";
        }
        
        print "\n";
       $print_iteration++;
    }
 }
