#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Performs Niggli cell reduction of CIF files.
#**

use strict;
use warnings;
use CIFParser;
use CIFTagCanonicalNames;
use CIFTagPrint;
use COD::Cell::Niggli::KG76;
use Fractional;
use Spacegroups::SymopAlgebra;
use UserMessage;
use SOptions;
use SUsage;

sub get_unit_cell($$$);
sub mat_vect_mul($$);

my $use_parser = 'c';
$KG76::debug = 0;

#* USAGE:
#*     $0 [options] input.cif [input2.cif ...]
#* 
#* OPTIONS:
#*     --use-perl-parser
#*        Use Perl parser for CIF parsing.
#*
#*     --use-c-parser
#*        Use Perl & C parser for CIF parsing.
#*
#*     --help,--usage
#*        Print short usage message (this message) and exit.
#**

@ARGV = getOptions
(
    "--use-perl-parser" => sub{ $use_parser = "perl" },
    "--use-c-parser"    => sub{ $use_parser = "c" },

    "--help,--usage" => sub { SUsage::usage; exit },
);

@ARGV = ( "-" ) unless @ARGV;

for my $filename (@ARGV) {

    my( $data, $error_count );

    if( $use_parser eq "perl" ) {
        my $parser = new CIFParser;

        $data = $parser->Run($filename);

        if( defined $parser->YYData->{ERRCOUNT} ) {
            $error_count = $parser->YYData->{ERRCOUNT};
        }
    } else {
        require CCIFParser;
        ( $data, $error_count ) = CCIFParser::parse($filename);
    }

    canonicalize_all_names( $data );

    for my $datablock (@$data) {
        my $values = $datablock->{values};
        my @cell = get_unit_cell( $values, $filename, $datablock->{name} );
        my @niggli = KG76::reduce( @cell );
        my $M = symop_ortho_from_fract( @cell );
        my $N = symop_ortho_from_fract( @niggli );
        my $T = SymopAlgebra::symop_mul( mat3_inv( $N ), $M );

        $values->{_cell_length_a}[0] = $niggli[0];
        $values->{_cell_length_b}[0] = $niggli[1];
        $values->{_cell_length_c}[0] = $niggli[2];
        $values->{_cell_angle_alpha}[0] = $niggli[3];
        $values->{_cell_angle_beta}[0]  = $niggli[4];
        $values->{_cell_angle_gamma}[0] = $niggli[5];

        for my $i (0..$#{$values->{_atom_site_label}}) {
            my @old_coordinates = map { s/(\(\d+\))?$//; $_ }
                                  map { $values->{$_}[$i] }
                                    qw( _atom_site_fract_x
                                        _atom_site_fract_y
                                        _atom_site_fract_z );

            my @new_coordinates =
                mat_vect_mul( $T, \@old_coordinates );
            $values->{_atom_site_fract_x}[$i] = $new_coordinates[0];
            $values->{_atom_site_fract_y}[$i] = $new_coordinates[1];
            $values->{_atom_site_fract_z}[$i] = $new_coordinates[2];
        }

        print_cif( $datablock,
           {
                preserve_loop_order => 1,
                keep_tag_order => 1
           }
        );
    }
}

#===============================================================#
# Extract unit cell angles and lengths.
#
# Accepts
#     values - a hash where a data from the CIF file is stored
# Returns
#     cell - an array  with stored information.

sub get_unit_cell($$$)
{
    my( $values, $filename, $dataname ) = @_;

    my @cell;

    for my $cif_tag (qw(_cell_length_a
                        _cell_length_b
                        _cell_length_c
                        ))
    {
        push(@cell, $values->{$cif_tag}[0]);
        $cell[-1] =~ s/\(\d+\)$//;
    }

    for my $cif_tag (qw(_cell_angle_alpha
                        _cell_angle_beta
                        _cell_angle_gamma
                        ))
    {
        if( exists $values->{$cif_tag} ) {
            push( @cell, $values->{$cif_tag}[0] );
            $cell[-1] =~ s/\(\d+\)$//;
        } else {
            warning( $0, $filename, $dataname,
                     "cell angle '$cif_tag' not present -- " .
                     "taking default value 90 degress." );
            push( @cell, 90 );
        }
    }

    return @cell;
}

sub mat3_inv
{
    my( $m ) = @_;
    my $c = 1 / SymopAlgebra::symop_det($m);
    return [[ $c * ( $m->[1][1] * $m->[2][2] - $m->[1][2] * $m->[2][1] ),
             -$c * ( $m->[0][1] * $m->[2][2] - $m->[0][2] * $m->[2][1] ),
              $c * ( $m->[0][1] * $m->[1][2] - $m->[0][2] * $m->[1][1] )],
            [-$c * ( $m->[1][0] * $m->[2][2] - $m->[1][2] * $m->[2][0] ),
              $c * ( $m->[0][0] * $m->[2][2] - $m->[0][2] * $m->[2][0] ),
             -$c * ( $m->[0][0] * $m->[1][2] - $m->[0][2] * $m->[1][0] )],
            [ $c * ( $m->[1][0] * $m->[2][1] - $m->[1][1] * $m->[2][0] ),
             -$c * ( $m->[0][0] * $m->[2][1] - $m->[0][1] * $m->[2][0] ),
              $c * ( $m->[0][0] * $m->[1][1] - $m->[0][1] * $m->[1][0] )]];
}

sub mat_vect_mul($$)
{
    my($matrix, $vector) = @_;

    my @new_coordinates;

    for(my $i = 0; $i < @{$vector}; $i++)
    {
        $new_coordinates[$i] = 0;
        for(my $j = 0; $j < @{$vector}; $j++)
        {
            $new_coordinates[$i] += ${$matrix}[$i][$j] * ${$vector}[$j];
        }
    }

    if( @$vector == 3 && @$matrix == 4 ) {
        $new_coordinates[0] += $matrix->[0][3];
        $new_coordinates[1] += $matrix->[1][3];
        $new_coordinates[2] += $matrix->[2][3];
    }

    return wantarray ? @new_coordinates : \@new_coordinates;
}
