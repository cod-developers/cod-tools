#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Parse a CIF file, check if certain data values match COD
#  requirements.
#**

use strict;
use lib "./lib/perl5";
use lib "./CIFParser";
use CIFParser;
use ShowStruct;
use Spacegroups::SpacegroupNames;
use File::Basename;
use SOptions;

my $useReporter = 0;
my $reportFile = '-';

@ARGV = getOptions(
    "--use-reporter"      => sub{ $useReporter = 1; $reportFile = get_value() }
);

if( $reportFile =~ m/^\s*-\s*$/ || !-w dirname($reportFile) )
{
    open reportFileFH, ">&", \*STDOUT or die "Can't dup STDOUT: $!";
} else {
    open reportFileFH, ">", $reportFile;
}

binmode( reportFileFH, 'utf8' );

my %spacegroups = map {
    my $key1 = $_->[1];
    my $key2 = $_->[2];
    $key1 =~ s/\s//g;
    $key2 =~ s/\s//g;
    ($_->[2], $_->[2], $_->[1], $_->[2], $key1, $_->[2], $key2, $_->[2] )
} @SpacegroupNames::names;

for my $filename (@ARGV) {
    my $parser = new CIFParser;
    my $data;
    if( $useReporter == 1 )
    {
        $data = $parser->Run($filename, \&parser_error_reporter );
    } else {
        $data = $parser->Run($filename);
    }

    if( defined $parser->YYData->{ERRCOUNT} &&
        $parser->YYData->{ERRCOUNT} > 0 ) {
	print STDERR "$0: $filename: ",
	$parser->YYData->{ERRCOUNT},
	" error(s) encountered while parsing CIF data\n";
	exit -1;
    }

    my $warnings = 0;
    for my $dataset (@$data) {
	$warnings += check_data( $dataset, $filename );
	$warnings += check_bibliography( $dataset, $filename );
	$warnings += check_authors( $dataset, $filename );
	$warnings += check_chemical_formula_sum( $dataset, $filename );
	$warnings += check_spacegroup_info( $dataset, $filename );
	$warnings += check_symmetry_operators( $dataset, $filename );
    }
    printf "%-30s: OK\n", $filename if $warnings == 0;
}

sub check_data
{
    my ($dataset,$filename) = @_;

    if( !defined $dataset->{values} ) {
        error_reporter($filename, undef, $dataset->{name}, "no values?!");
	return 1;
    } else {
	return 0;
    }
}

sub check_bibliography
{
    my ($dataset,$filename) = @_;

    if( !defined $dataset->{values} ) {
	return 0;
    }

    my $warnings = 0;
    my $values = $dataset->{values};

    if( !defined $values->{_journal_name_full} ) {
        error_reporter($filename, undef, $dataset->{name},
                       "_journal_name_full is undefined");
	$warnings ++;
    }
    if( !defined $values->{_journal_year} &&
	!defined $values->{_journal_volume} ) {
	error_reporter($filename, undef, $dataset->{name},
                       "neither _journal_year "
                       . "nor _journal_volume is defined");
	$warnings ++;
    }
    if( !defined $values->{_journal_page_first} ) {
        error_reporter($filename, undef, $dataset->{name},
                       "_journal_page_first is undefined");
	$warnings ++;
    }
    return $warnings;
}

sub check_authors
{
    use Unicode2CIF;

    my ($dataset,$filename) = @_;

    if( !defined $dataset->{values} ) {
	return 0;
    }

    my $name_syntax_explained = 0;
    my $warnings = 0;
    my $values = $dataset->{values};

    my $First = qr/[[:upper:]] ['[:lower:]]+
                   ( \s*-\s* [[:upper:]] ['[:lower:]]+ )?/x;
                # Armel, Miguel, O'Reily. Ding-Quan

    my $Initial = qr/[[:upper:]] [[:lower:]]? \.
                   ( \s*-\s* [[:upper:]] [[:lower:]]?\. )?/x;
                # A., M., O., D.-Q.

    my $Last = qr/[[:upper:]] ['[:lower:]]*
                  ( \s*-\s* [[:upper:]] ['[:lower:]]+ )?/x;
                # Neuman, D'Lamber, le Bail, Le Bail (?),

    my $von = qr/[a-zA-Z][a-z]+(\s+[a-zA-Z][a-z]+)?/;
                # von, van, de, De, de la

    my $Jr  = qr/[A-Za-z]+\.?/;
                # Jr, Jr., I, II, III, IV

    my $FirstNames = qr/${First}(\s+${First})*/;
    my $Initials = qr/(${First}\s+|${Initial})(\s*$Initial)*/;
    my $LastNames = qr/${Last}(\s+${Last})*/;
    my $vonLast = qr/(${von}\s+)?${Last}/;
    my $vonLastNames = qr/(${von}\s+)?${Last}(\s+${Last})*/;

    if( !defined $values->{_publ_author_name} ) {
        error_reporter($filename, undef, $dataset->{name}, "_publ_author_name "
                       . "is undefined");
	$warnings ++;
    } else {
        for my $author (@{$values->{_publ_author_name}}) {
            my $UCS_author = cif2unicode( $author );
            if( $UCS_author !~
                /^\s*${FirstNames}\s+${vonLast}\s*$/ &&
                $UCS_author !~
                /^\s*${Initials}\s*${vonLast}\s*$/ &&
                $UCS_author !~
                /^\s*${vonLastNames}\s*,\s*${FirstNames}\s*$/ &&
                $UCS_author !~
                /^\s*${vonLastNames}\s*,\s*${Initials}\s*$/ &&
                $UCS_author !~
                /^\s*${vonLastNames}\s*,\s*${Jr}\s*,\s*${FirstNames}\s*$/ &&
                $UCS_author !~
                /^\s*${vonLastNames}\s*,\s*${Jr}\s*,\s*${Initials}\s*$/
                ) {
                error_reporter( $filename, undef, $dataset->{name},
                                "name '$author' ('$UCS_author')" .
                                " does not match name syntax" );
                if( ! $name_syntax_explained ) {
                    error_reporter( undef, undef, undef,
                                    "names should be written as " .
                                    "'First von Last', " .
                                    "'von Last, First', or " .
                                    "'von Last, Jr, First'"
                        );
                    $name_syntax_explained = 1;
                }
            }
        }
    }
    return $warnings;
}

sub check_chemical_formula_sum
{
    my ($dataset, $filename) = @_;

    if( !defined $dataset->{values} ) {
	return 0;
    }

    my $formula = $dataset->{values}{_chemical_formula_sum}[0];

    my $formula_component = "[a-zA-Z]{1,2}[0-9.]*";

    if( !defined $formula ) {
    error_reporter($filename, undef, $dataset->{name}, "no "
                    . "_chemical_formula_sum");
	return 1;
    } elsif( $formula !~ /^\s*($formula_component\s+)*($formula_component)\s*$/ ) {
	error_reporter($filename, undef, $dataset->{name}, "chemical formula "
	                . "'$formula' could not be parsed");
	return 1;
    } else {
	return 0;
    }
}

sub check_spacegroup_info
{
    my ($dataset, $filename ) = @_;

    if( !defined $dataset->{values} ) {
	return 0;
    }

    my $symops = $dataset->{values}{_symmetry_equiv_pos_as_xyz};
    my $values = $dataset->{values};

    my @spacegroup_tags = qw (
        _symmetry_space_group_name_H-M
        _symmetry_space_group_name_Hall
        _symmetry_Int_Tables_number
        _space_group_name_H-M_alt
        _space_group.name_H-M_full
        _space_group_name_Hall
        _space_group_ssg_name
        _space_group_ssg_name_IT
        _space_group_ssg_name_WJJ
    );

    my $warnings = 0;
    my $spacegroup_found;
    my $spacegroup;

    for my $sg_tag (@spacegroup_tags) {
	if( exists $values->{$sg_tag} ) {
	    $spacegroup = $values->{$sg_tag}[0];
	    my $no_spaces = $spacegroup;
	    $no_spaces =~ s/\s//g;
	    $no_spaces =~ s/[\(\)~]//g;
	    if( $sg_tag =~ /H-M/ ) {
		if( defined $spacegroup &&
		    !exists $spacegroups{$spacegroup} &&
		    !exists $spacegroups{$no_spaces} ) {
		    error_reporter($filename, undef, $dataset->{name}, "unrecognised "
		                    . "spacegroup '$spacegroup'");
		    $warnings ++;
		}
	    }
	    last
	}
    }
    if( !defined $spacegroup ) {
        if( !defined $symops ) {
            error_reporter($filename, undef, $dataset->{name}, "no symmetry "
                           . "information found");
        } else {
            error_reporter($filename, undef, $dataset->{name}, "no spacegroup "
                           . "symbol found");
        }
	$warnings ++;
    }
    return $warnings;
}

sub check_symmetry_operators
{
    my ($dataset, $filename) = @_;

    if( !defined $dataset->{values} ) {
	return 0;
    }

    my $symop_term = '(?:x|y|z|\d|\d*\.\d+|\d+\.\d*|\d/\d)';
    my $symop_component =
	"(?:(?:-|\\+)?$symop_term|" .
	"(?:-|\\+)?$symop_term(?:-|\\+)$symop_term|" .
	"(?:-|\\+)?$symop_term(?:-|\\+)$symop_term(?:-|\\+)$symop_term)";

    my $symops = $dataset->{values}{_symmetry_equiv_pos_as_xyz};

    if( !defined $symops ) {
	return 0; # Let's not regard missing symmetry operators as error.
    } else {
	for my $symop (@$symops) {
	    my $no_spaces = $symop;
	    $no_spaces =~ s/\s//g;
	    if( $no_spaces !~ 
		/^($symop_component,){2}($symop_component)$/i ) {
		error_reporter($filename, undef, $dataset->{name}, "symmetry operator "
		                . "'$symop' could not be parsed");
		return 1;
	    }
	}
    }
    return 0;
}

sub error_reporter
{
    my ($file, $line, $data, $message) = @_;
    $file = '-' unless $file;
    $line = ( defined $line ) ? '(' . $line . ')' : '';
    $data = ( defined $data ) ? ' data_' . $data : '';
    my $output = $0 . ': ' . $file . $line . $data;
    $output .= ': ' . $message . "\n";
    print reportFileFH $output;
    return 0;
}

sub parser_error_reporter
{
    my ($file, $line, $data) = @_;
    return error_reporter($file, $line, $data, "line currently"
                            ." processed: $line");
}
