#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Parse a CIF file, check if certain data values match COD
#  requirements and IUCr data validation criteria (Version: 2000.06.09,
#  ftp://ftp.iucr.ac.uk/pub/dvntests or ftp://ftp.iucr.org/pub/dvntests)
#**

use strict;
use lib "./lib/perl5";
use lib "./CIFParser";
use lib "./CCIFParser";
use CIFParser;
use CCIFParser;
use CIFTagCanonicalNames;
use CIFTagManage;
use ShowStruct;
use Spacegroups::SpacegroupNames;
use Spacegroups::SymopLookup;
use File::Basename;
use SOptions;
use SUsage;

my $name_syntax_explained = 0;
my $check_bibliography = 1;
my $check_authors = 1;
my $check_chemical_formula_sum = 1;
my $check_spacegroup_info = 1;
my $check_symmetry_operators = 1;
my $check_spacegroup_constraints = 1;
my $check_limits = 1;
my $use_precisions = 1;
my $check_temperature_factors = 1;

sub dont_check_any
{
    $check_bibliography = 0;
    $check_authors = 0;
    $check_chemical_formula_sum = 0;
    $check_spacegroup_info = 0;
    $check_symmetry_operators = 0;
    $check_spacegroup_constraints = 0;
    $check_limits = 0;
    $check_temperature_factors = 0;
}

sub check_all
{
    $check_bibliography = 1;
    $check_authors = 1;
    $check_chemical_formula_sum = 1;
    $check_spacegroup_info = 1;
    $check_symmetry_operators = 1;
    $check_spacegroup_constraints = 1;
    $check_limits = 1;
    $check_temperature_factors = 1;
}

my $useReporter = 0;
my $reportFile = '-';

#===================================================================#
#
# The structure of the default table of the limits 
# that uses '--check-limits' option is:
#
# { _tag_name -> [ [$begin,$end] , [$begin,$end] , [$begin,$end] ] }
# 
# The array [$begin,$end] is the range of the limits.
#
#===================================================================#

my %default_limits_table = (
    '_refine_ls_R_factor_gt' =>   [ [0.2], [0.15], [0.10] ],
    '_refine_ls_R_factor_obs' =>  [ [0.2], [0.15], [0.10] ],
    '_refine_ls_wR_factor_ref' => [ [0.45], [0.35], [0.25] ],
    '_refine_ls_wR_factor_obs' => [ [0.45], [0.35], [0.25] ],
    '_refine_ls_goodness_of_fit_ref' => [ [0.4,6], [0.6,4], [0.8,2] ],
    '_refine_ls_goodness_of_fit_obs' => [ [0.4,6], [0.6,4], [0.8,2] ],
    '_refine_ls_shift/su_max' =>  [ [0.20], [0.10], [0.05] ],
    '_refine_ls_shift/esd_max' => [ [0.20], [0.10], [0.05] ],
);

my %limits_table = %default_limits_table;
my $limits_table = \%limits_table;

# Subroutine that gets limits values from the file that is given under
# the option '--limits-file'

sub get_limits_table($) {
    my( $flimits ) = @_;
    my %ltable;
    open( LIST, $flimits ) or
        die "$0: $flimits: can not open file for input - $!";
    foreach( <LIST> ) {
        if( /^#/ ) { next; }
        my @constraints;
        my @data = split( /\s+/, $_, 4 );
        my $tag = shift( @data );
        foreach( @data ) {
            $_ =~ s/\s+//g;
            if( $_ =~ /(\d*\.?\d+)-(\d*\.?\d+)/ ) {
                push( @constraints, [$1,$2] );
            } else {
                push( @constraints, [$_] );
            }
        }
        $ltable{$tag} = \@constraints;
    }
    close( LIST ) or
        die "$0: $flimits: error closing file - $!";
    return \%ltable;
}

# Subroutine that merges tables of limits

sub merge_limits_tables($$) {
   my( $new_limits, $old_limits ) = @_;
   my $merged_limits = $old_limits;

   foreach my $tag( keys %$new_limits ) {
        if( exists $merged_limits->{$tag} ) {
            $merged_limits->{$tag} = $new_limits->{$tag};
            next;
        } else {
            $merged_limits->{$tag} = $new_limits->{$tag};
        } 
   }
   return $merged_limits; 
}

my $max_year_temperature_factors_optional = 1969;
my $use_parser = "perl";

#* USAGE:
#*    $0 [options] input1.cif [input2.cif ...]
#*
#* OPTIONS:
#* For every --check-xyz option, there are the following corresponding
#* related options:
#*
#*    --check-only-xyz
#*        Switch off any other checks and check ONLY xyz (the last option on the
#*        command line wins)
#*
#*    --dont-check-xyz, --do-not-check-xyz, --no-check-xyz
#*        Switch off checks of xyz condition
#*
#* The check options are:
#*
#*    --check-authors
#*
#*    --check-bibliography
#*
#*    --check-chemical-formula-sum
#*
#*    --check-spacegroup-info
#*
#*    --check-operators, --check-symmetry-operators
#*
#*    --check-unit-cell
#*
#*    --check-symmetry
#*
#*    --check-limits
#*
#*    --print-limits
#*
#*    --add-limits  limits.lst
#*
#*    --limits-file limits.lst
#*
#*    --reset-limits
#*
#*    --check-temperature-factors
#*
#*    --max-year-temperature-factors-optional 1969
#*
#*    --check-all
#*
#*    --check-none, --dont-check-any
#*
#*    --use-perl-parser
#*
#*    --use-c-parser
#*
#*    --help,--usage         Print a short usage message (this message) and exit.
#**

@ARGV = getOptions(
    "--check-bibliography"
        => sub{ $check_bibliography = 1 },
    "--check-only-bibliography"
        => sub{ dont_check_any(); $check_bibliography = 1 },
    "--dont-check-bibliography,--no-check-bibliography," .
    "--do-not-check-bibliography"
        => sub{ $check_bibliography = 0 },

    "--check-authors"
        => sub{ $check_authors = 1 },
    "--check-only-authors"
        => sub{ dont_check_any(); $check_authors = 1 },
    "--dont-check-authors,--no-check-authors," .
    "--do-not-check-authors"
        => sub{ $check_authors = 0 },

    "--check-chemical-formula-sum"
        => sub{ $check_chemical_formula_sum = 1 },
    "--check-only-chemical-formula-sum"
        => sub{ dont_check_any(); $check_chemical_formula_sum = 1 },
    "--dont-check-chemical-formula-sum,--no-check-chemical-formula-sum," .
    "--do-not-check-chemical-formula-sum"
        => sub{ $check_chemical_formula_sum = 0 },

    "--check-spacegroup-info"
        => sub{ $check_spacegroup_info = 1 },
    "--check-only-spacegroup-info"
        => sub{ dont_check_any(); $check_spacegroup_info = 1 },
    "--dont-check-spacegroup-info,--no-check-spacegroup-info" .
    "--do-not-check-spacegroup-info"
        => sub{ $check_spacegroup_info = 0 },

    "--check-symmetry-operators,--check-operators"
        => sub{ $check_symmetry_operators = 1 },
    "--check-only-symmetry-operators,--check-only-operators"
        => sub{ dont_check_any(); $check_symmetry_operators = 1 },
    "--dont-check-symmetry-operators,--no-check-symmetry-operators" .
    "--do-not-check-symmetry-operators" .
    "--dont-check-operators,--no-check-operators" .
    "--do-not-check-operators"
        => sub{ $check_symmetry_operators = 0 },

    "--check-constraints-on-unit-cell," .
    "--check-unit-cell"
        => sub{ $check_spacegroup_constraints = 1 },
    "--check-only-constraints-on-unit-cell," .
    "--check-only-unit-cell"
        => sub{ dont_check_any(); $check_spacegroup_constraints = 1 },
    "--dont-check-constraints-on-unit-cell," .
    "--do-not-check-constraints-on-unit-cell," .
    "--no-check-constraints-on-unit-cell," .
    "--dont-check-unit-cell,--do-not-check-unit-cell," .
    "--no-check-unit-cell"
        => sub{ $check_spacegroup_constraints = 0 },

    "--check-symmetry" => sub{
        $check_spacegroup_info = 1;
        $check_symmetry_operators = 1;
        $check_spacegroup_constraints = 1;
    },

    "--check-only-symmetry" => sub{
        dont_check_any();
        $check_spacegroup_info = 1;
        $check_symmetry_operators = 1;
        $check_spacegroup_constraints = 1;
    },

    "--check-limits" => sub{ $check_limits = 1 },
    "--check-only-limits" => sub{ dont_check_any(); $check_limits = 1 },
    "--dont-check-limits,--no-check-limits,--do-not-check-limits"
        => sub{ $check_limits = 0 },
    
    "--limits-file" => sub{ $limits_table = &get_limits_table( &get_value() ) },

    "--add-limits" => sub{ $limits_table = &merge_limits_tables( 
                               &get_limits_table( &get_value() ),
                               $limits_table )
    },

    "--reset-limits" => sub{ $limits_table = \%default_limits_table },
    
    "--print-limits" => sub{ &print_limits() }, 

    "--check-temperature-factors" =>
        sub { $check_temperature_factors = 1; },
    "--dont-check-temperature-factors,--no-check-temperature-factors" =>
        sub { $check_temperature_factors = 0; },
    "--do-not-check-temperature-factors" =>
        sub { $check_temperature_factors = 0; },
    "--max-year-temperature-factors-optional" =>
        \$max_year_temperature_factors_optional,

    "--check-all"
        => \&check_all,

    "--check-none,--dont-check-any,--do-not-check-any,--no-check-any"

        => \&dont_check_any,

    "--use-precisions"        => sub { $use_precisions = 1 },
    "--dont-use-precisions"   => sub { $use_precisions = 0 },
    "--do-not-use-precisions" => sub { $use_precisions = 0 },
    "--ignore-precisions"     => sub { $use_precisions = 0 },

    "--use-reporter" => sub{ $useReporter = 1; $reportFile = get_value() },

    "--use-perl-parser" => sub{ $use_parser = "perl" },
    "--use-c-parser"    => sub{ $use_parser = "c" },

    "--help,--usage" => sub { SUsage::usage; exit },
);

if( $reportFile =~ m/^\s*-\s*$/ || !-w dirname($reportFile) ) {
    open reportFileFH, ">&", \*STDOUT or die "Can't dup STDOUT: $!";
} else {
    open reportFileFH, ">", $reportFile;
}

# The subroutine that prints out the table of limits

sub print_limits {
    print "#" . "-"x70  . "\n" .
          "# The table of data value limits that 'cif_cod_check' script \n" .
          "# uses under the option '--check-limits'.\n" .
          "#" . "-"x70  . "\n";
    foreach my $tag( sort keys %$limits_table ) {
        printf "%-32s", $tag;
        for my $i( 0..$#{ $limits_table->{$tag} } ) {
            print "\t" , join( "-", @{ $limits_table->{$tag}[$i]} );
        }
        print "\n";
    }
    exit 0;
}

binmode( reportFileFH, 'utf8' );

my %spacegroups = map {
    my $key1 = $_->[1];
    my $key2 = $_->[2];
    $key1 =~ s/\s//g;
    $key2 =~ s/\s//g;
    ($_->[2], $_->[2], $_->[1], $_->[2], $key1, $_->[2], $key2, $_->[2] )
} @SpacegroupNames::names,
  map { [ $_->{number}, $_->{hermann_mauguin}, $_->{universal_h_m} ] }
      @SymopLookup::table, @SymopLookup::extra_settings;

$| = 1; # Flush buffers immediately, to avoid mixing lines of STDOUT
        # and STDERR.

@ARGV = ("-") unless @ARGV;

for my $filename (@ARGV) {

    my( $data, $error_count );

    if( $use_parser eq "perl" ) {
        my $parser = new CIFParser;
        if( $useReporter == 1 )
        {
            $data = $parser->Run($filename, \&parser_error_reporter );
        } else {
            $data = $parser->Run($filename);
        }
        if( defined $parser->YYData->{ERRCOUNT} ) {
            $error_count = $parser->YYData->{ERRCOUNT};
        }
    } else {
        ( $data, $error_count ) = CCIFParser::parse( $filename );
    }
    
    if( defined $error_count && $error_count > 0 ) {
        print STDERR "$0: $filename: ", $error_count,
        " error(s) encountered while parsing CIF data\n";
        exit -1;
    }
    
    canonicalize_all_names( $data );
    
    my $warnings = 0;
    for my $dataset (@$data) {
        $warnings += check_data( $dataset, $filename );
        $warnings += check_bibliography( $dataset, $filename )
            if $check_bibliography;
        $warnings += check_authors( $dataset, $filename )
            if $check_authors;
        $warnings += check_chemical_formula_sum( $dataset, $filename )
            if $check_chemical_formula_sum;
        $warnings += check_spacegroup_info( $dataset, $filename )
            if $check_spacegroup_info;
        $warnings += check_symmetry_operators( $dataset, $filename )
            if $check_symmetry_operators;
        $warnings += check_spacegroup_constraints( $dataset, $filename )
            if $check_spacegroup_constraints;
        $warnings += check_limits( $dataset, $filename )
            if $check_limits;
        $warnings += check_temperature_factors( $dataset, $filename )
            if $check_temperature_factors;
    }
    printf "%-30s: OK\n", $filename if $warnings == 0;
}

sub check_data
{
    my ($dataset,$filename) = @_;

    if( !defined $dataset->{values} ) {
        error_reporter($filename, undef, $dataset->{name}, "no values?!");
        return 1;
    } else {
        return 0;
    }
}

sub check_bibliography
{
    my ($dataset,$filename) = @_;
    
    if( !defined $dataset->{values} ) {
        return 0;
    }

    my $warnings = 0;
    my $values = $dataset->{values};

    if( !defined $values->{_journal_name_full} ) {
        error_reporter($filename, undef, $dataset->{name},
                       "_journal_name_full is undefined");
        $warnings ++;
    }
    if( !defined $values->{_publ_section_title} ) {
        error_reporter($filename, undef, $dataset->{name},
                       "_publ_section_title is undefined");
        $warnings ++;
    }
    if( !defined $values->{_journal_year} &&
        !defined $values->{_journal_volume} ) {
        error_reporter($filename, undef, $dataset->{name},
                       "neither _journal_year "
                       . "nor _journal_volume is defined");
        $warnings ++;
    }
    if( !defined $values->{_journal_page_first} &&
        !defined $values->{_journal_article_reference} ) {
        error_reporter($filename, undef, $dataset->{name},
                       "neither _journal_page_first "
                       . "nor _journal_article_reference is defined");
        $warnings ++;
    }
    return $warnings;
}

sub check_authors
{
    use Unicode2CIF;

    my ($dataset,$filename) = @_;

    if( !defined $dataset->{values} ) {
        return 0;
    }

    my $warnings = 0;
    my $values = $dataset->{values};

    my $First = qr/[[:upper:]] ('[[:alpha:]])? [[:lower:]]*
                   ( \s*-\s* [[:upper:]]? ['[:lower:]]* )?/x;
                # Armel, Miguel, O'Reily, Ding-Quan, Chun-hsien

    my $Initial = qr/[[:upper:]] [[:lower:]]? \.
                   ( \s*-\s* [[:upper:]] [[:lower:]]?\. )?/x;
                # A., M., O., D.-Q.

    my $Last = qr/([[:upper:]][[:lower:]]{1,2})? # optional Mc, Da, La prefix
                   [[:upper:]] ('[[:alpha:]])? ['[:lower:]]*
                  (?: \s*-\s* [[:upper:]] ['[:lower:]]+ )?
                  (?: \s+ i \s+ [[:upper:]] [[:lower:]]+ )? # poss. 'i Surname'
                  |
                  [[:upper:]][[:lower:]]+
                  -[[:lower:]][[:lower:]]-
                  [[:upper:]][[:lower:]]+
                  /x;
                # Neuman, D'Lamber, le Bail, Le Bail (?), Mairata i Payeras

    my $von = qr/[a-zA-Z][a-z]+(\s+[a-zA-Z][a-z]+)?/;
                # von, van, de, De, de la

    my $Jr  = qr/[A-Za-z]+\.?/;
                # Jr, Jr., I, II, III, IV

    my $FirstNames = qr/${First}(\s+${First})*/;
    my $Initials = qr/(${Initial}\s*|${First}\s+)*(${First}|${Initial})/;
    my $LastNames = qr/${Last}(\s+${Last})*/;
    my $vonLast = qr/(${von}\s+)?${Last}/;
    my $vonLastNames = qr/(${von}\s+)?${Last}(\s+${Last})*/;

    if( !defined $values->{_publ_author_name} ) {
        error_reporter($filename, undef, $dataset->{name}, "_publ_author_name "
                       . "is undefined");
        $warnings ++;
    } else {
        for my $author (@{$values->{_publ_author_name}}) {
            my $UCS_author = cif2unicode( $author );
            if( $UCS_author =~ /^([^[:alpha:]])/ ||
                $UCS_author =~ /([^-\.,[:alpha:]'()\s])/ ) {
                error_reporter( $filename, undef, $dataset->{name},
                                "WARNING, " .
                                "name '$author'" .
                                ( $author eq $UCS_author ?
                                    "" : " ('$UCS_author')" ) .
                                " contains symbol '$1' that is not permitted in names" );
                if( ! $name_syntax_explained ) {
                    error_reporter( undef, undef, undef,
                                    "WARNING, " .
                                    "names should be written as " .
                                    "'First von Last', " .
                                    "'von Last, First', or " .
                                    "'von Last, Jr, First' (mind the case!)"
                        );
                    $name_syntax_explained = 1;
                }
                $warnings ++;
            } elsif( $UCS_author !~
                /^\s*${FirstNames}\s+${vonLast}\s*$/ &&
                $UCS_author !~
                /^\s*${Initials}\s*${vonLast}\s*$/ &&
                $UCS_author !~
                /^\s*${vonLastNames}\s*,\s*${FirstNames}\s*$/ &&
                $UCS_author !~
                /^\s*${vonLastNames}\s*,\s*${Initials}\s*$/ &&
                $UCS_author !~
                /^\s*${vonLastNames}\s*,\s*${Jr}\s*,\s*${FirstNames}\s*$/ &&
                $UCS_author !~
                /^\s*${vonLastNames}\s*,\s*${Jr}\s*,\s*${Initials}\s*$/ &&
                $UCS_author !~
                /^\s*${First}-ur-${Last}\s*$/
                ) {
                error_reporter( $filename, undef, $dataset->{name},
                                "NOTE, " .
                                "name '$author'" .
                                ( $author eq $UCS_author ?
                                    "" : " ('$UCS_author')" ) .
                                " seems unusual" );
                if( ! $name_syntax_explained ) {
                    error_reporter( undef, undef, undef,
                                    "NOTE, " .
                                    "names should be written as " .
                                    "'First von Last', " .
                                    "'von Last, First', or " .
                                    "'von Last, Jr, First' (mind the case!)"
                        );
                    $name_syntax_explained = 1;
                }
                $warnings ++;
            }
        }
    }
    return $warnings;
}

sub check_chemical_formula_sum
{
    my ($dataset, $filename) = @_;
    
    if( !defined $dataset->{values} ) {
        return 0;
    }
    
    my $formula = $dataset->{values}{_chemical_formula_sum}[0];
    
    my $formula_component = "[a-zA-Z]{1,2}[0-9.]*";
    
    if( !defined $formula ) {
    error_reporter($filename, undef, $dataset->{name}, "no "
                    . "_chemical_formula_sum");
        return 1;
    } elsif( $formula !~
             /^\s*($formula_component\s+)*($formula_component)\s*$/ ) {
        error_reporter( $filename, undef, $dataset->{name}, "chemical formula "
                        . "'$formula' could not be parsed");
        return 1;
    } else {
        return 0;
    }
}

sub check_spacegroup_info
{
    my ($dataset, $filename ) = @_;

    if( !defined $dataset->{values} ) {
        return 0;
    }

    my $symops = $dataset->{values}{_symmetry_equiv_pos_as_xyz};
    my $values = $dataset->{values};

    my @spacegroup_tags = qw (
        _symmetry_space_group_name_H-M
        _symmetry_space_group_name_Hall
        _symmetry_Int_Tables_number
        _space_group_name_H-M_alt
        _space_group.name_H-M_full
        _space_group_name_Hall
        _space_group_ssg_name
        _space_group_ssg_name_IT
        _space_group_ssg_name_WJJ
    );

    my $warnings = 0;
    my $spacegroup_found;
    my $spacegroup;

    for my $sg_tag (@spacegroup_tags) {
        if( exists $values->{$sg_tag} ) {
            $spacegroup = $values->{$sg_tag}[0];
            my $no_spaces = $spacegroup;
            $no_spaces =~ s/\s//g;
            $no_spaces =~ s/[\(\)~]//g;
            if( $sg_tag =~ /H-M/ ) {
                if( defined $spacegroup &&
                    !exists $spacegroups{$spacegroup} &&
                    !exists $spacegroups{$no_spaces} ) {
                    error_reporter( $filename, undef, $dataset->{name},
                                    "unrecognised spacegroup '$spacegroup'");
                    $warnings ++;
                }
            }
            last
        }
    }
    if( !defined $spacegroup ) {
        if( !defined $symops ) {
            error_reporter( $filename, undef, $dataset->{name},
                            "no symmetry information found");
        } else {
            error_reporter( $filename, undef, $dataset->{name},
                            "no spacegroup symbol found");
        }
        $warnings ++;
    }
    return $warnings;
}

sub check_temperature_factors
{
    my( $dataset, $filename ) = @_;

    if( !defined $dataset->{values} ) {
        return 0;
    }

    my $values = $dataset->{values};
    my $warnings = 0;

    if( CIFTagManage::tag_is_empty( $dataset, '_journal_year' ) ) {
        return 0;
    }
    if( $values->{_journal_year}[0] <= 
        $max_year_temperature_factors_optional ) {
        return 0;
    }

    if( !CIFTagManage::tag_is_empty($dataset,'_atom_site_B_iso_or_equiv') ||
        !CIFTagManage::tag_is_empty($dataset,'_atom_site_U_iso_or_equiv') ) {
        return 0;
    }
    foreach my $indexes ( '11', '12', '13', '22', '23', '33' ) {
        if( !CIFTagManage::tag_is_empty($dataset,
            '_atom_site_aniso_B_' . $indexes) ||
            !CIFTagManage::tag_is_empty($dataset,
            '_atom_site_aniso_U_' . $indexes) ) {
            return 0;
        }
    }
    error_reporter( $filename, undef, $dataset->{name},
        "structure is published after " . 
        $max_year_temperature_factors_optional . ", but does not contain " .
        "temperature factors" );
    $warnings++;
    return $warnings;
}

#===============================================================#
# Gets symmetry operators if they are not directly represented in the CIF file.

# Accepts
#     option - an option, for example, "hall"
#     param  - according to an option a value given in the CIF file

# Uses @SymopLookup::table =
# (
# {
#     number          => 1,
#     hall            => ' P 1',
#     schoenflies     => 'C1^1',
#     hermann_mauguin => 'P 1',
#     universal_h_m   => 'P 1',
#     crystal_class   => 'monoclinic',
#     constraints     => '1',
#     symops => [
#         'x,y,z',
#     ],
#     ncsym => [
#         'x,y,z',
#     ]
# },
# );

# Returns a reference to the spacegroup descriptor
# (a @SymopLookup::table element).

sub lookup_spacegroup
{
    my ($option, $param) = @_;

    $param =~ s/ //g;
    $param =~ s/_//g;

    foreach my $hash (@SymopLookup::table, @SymopLookup::extra_settings) {
        my $value = $hash->{$option};
        $value =~ s/ //g;
        $value =~ s/_//g;

        if( $value eq $param ) {
            return $hash;
        }
    }
    return undef;
}

sub get_spacegroup_descriptions
{
    my ( $dataset, $filename ) = @_;

    my $values = $dataset->{values};

    my $sym_data;
    my $warnings = 0;

    if( exists $values->{"_space_group_name_Hall"} &&
        not defined $sym_data ) {
        my $hall = $values->{"_space_group_name_Hall"}[0];
        $sym_data = lookup_spacegroup("hall", $hall);
        
        if( !defined $sym_data ) {
            error_reporter( $filename, undef, $dataset->{name},
                   "incorrect _space_group_name_Hall '$hall'" );
            $warnings++;
        }
    } elsif( exists $values->{"_symmetry_space_group_name_Hall"} &&
        not defined $sym_data ) {
        my $hall = $values->{"_symmetry_space_group_name_Hall"}[0];
        $sym_data = lookup_spacegroup("hall", $hall);
        
        if( !defined $sym_data ) {
            error_reporter( $filename, undef, $dataset->{name},
                   "incorrect _symmetry_space_group_name_Hall '$hall'" );
            $warnings++;
        }
    }
    
    if(exists $values->{"_space_group_name_H-M_alt"} &&
       not defined $sym_data) {
        my $h_m = $values->{"_space_group_name_H-M_alt"}[0];
        $sym_data = lookup_spacegroup("hermann_mauguin", $h_m);
        $sym_data = lookup_spacegroup("universal_h_m", $h_m)
            unless defined $sym_data;
        
        if( !defined $sym_data ) {
            error_reporter( $filename, undef, $dataset->{name},
                   "incorrect _space_group_name_H-M_alt '$h_m'" );
            $warnings++;
        }
    } elsif(exists $values->{"_symmetry_space_group_name_H-M"} &&
            not defined $sym_data) {
        my $h_m = $values->{"_symmetry_space_group_name_H-M"}[0];
        $sym_data = lookup_spacegroup("hermann_mauguin", $h_m);
        $sym_data = lookup_spacegroup("universal_h_m", $h_m)
            unless defined $sym_data;
        
        if( !defined $sym_data ) {
            error_reporter( $filename, undef, $dataset->{name},
                   "incorrect _symmetry_space_group_name_H-M '$h_m'" );
            $warnings++;
        }
    }
    
    if(not defined $sym_data) {
        if( $warnings == 0 ) {
            my @spacegroup_tags = qw (
                _space_group_symop_ssg_id
                _space_group_symop_ssg_operation_algebraic
                _space_group_ssg_name
                _space_group_ssg_name_IT
                _space_group_ssg_name_WJJ
            );
            for my $sg_tag (@spacegroup_tags) {
                if( exists $dataset->{values}{$sg_tag} ) {
                    return (undef, 0);
                }
            }
            error_reporter( $filename, undef, $dataset->{name},
                            "no spacegroup symbol to check cell constraints" );
            $warnings = 1;
        }
    }

    return ( $sym_data, $warnings );
}

sub get_unit_cell($$)
{
    my( $dataset, $filename ) = @_;
    my $values = $dataset->{values};

    my @cell;

    for my $cif_tag (qw(_cell_length_a
                        _cell_length_b
                        _cell_length_c
                        )) {
        push(@cell, $values->{$cif_tag}[0]);
        $cell[-1] =~ s/\(\d+\)$//;
    }

    for my $cif_tag (qw(_cell_angle_alpha
                        _cell_angle_beta
                        _cell_angle_gamma
                        )) {
        if( exists $values->{$cif_tag} ) {
            push( @cell, $values->{$cif_tag}[0] );
            $cell[-1] =~ s/\(\d+\)$//;
        } else {
            error_reporter( $filename, undef, $dataset->{name},
                     "cell angle '$cif_tag' not present -- " .
                     "taking default value 90 degrees." );
            push( @cell, 90 );
        }
    }

    return @cell;
}

sub get_unit_cell_sigmas($$)
{
    my( $dataset, $filename ) = @_;
    my $values = $dataset->{precisions};

    my @cellsig;

    for my $cif_tag (qw(_cell_length_a
                        _cell_length_b
                        _cell_length_c
                        _cell_angle_alpha
                        _cell_angle_beta
                        _cell_angle_gamma
                        )) {
        push( @cellsig, $values->{$cif_tag}[0] );
    }

    return @cellsig;
}

sub eqsig
{
    my ( $x, $sigx, $y, $sigy ) = @_;

    $sigx = 0.0 unless defined $sigx;
    $sigy = 0.0 unless defined $sigy;

    return ($x - $y)**2 <= 9 * $sigx**2 + $sigy**2;
}

sub regularize_cell($$$$)
{
    my ( $cell, $cellsig, $crystal_class, $h_m_symbol ) = @_;

    my @regcell = @$cell;

    my @cellsig = map { defined $_ ? $_ : 0 } @$cellsig;

    # snap cell lengths:
    if( $crystal_class ne "triclinic" && $crystal_class ne "monoclinic" ) {
        if( eqsig( $cell->[0], $cellsig[0], $cell->[1], $cellsig[1] )) {
            if( ( $crystal_class eq "rhombohedral" ||
                  $crystal_class eq "cubic" ) &&
                eqsig( $cell->[0], $cellsig[0], $cell->[2], $cellsig[2] ) &&
                eqsig( $cell->[1], $cellsig[1], $cell->[2], $cellsig[2] )) {
                $regcell[1] = $regcell[2] = $regcell[0];
            } else {
                $regcell[0] = $regcell[1];
            }
        } elsif( eqsig( $cell->[0], $cellsig[0], $cell->[2], $cellsig[2] )) {
                $regcell[0] = $regcell[2];
        } elsif( eqsig( $cell->[1], $cellsig[1], $cell->[2], $cellsig[2] )) {
                $regcell[1] = $regcell[2];
        }
    }

    # snap unit cell angles:
    for my $i (( 3, 4, 5 )) {
        my $angle = $cell->[$i];
        my $sigma = $cellsig[$i];
        if( eqsig( $angle, $sigma, 90, 0 ) &&
            $crystal_class ne "triclinic" &&
            ( $crystal_class ne "rhombohedral" ||
              $h_m_symbol =~ /^H|:H$/ )) {
            $regcell[$i] = 90;
        } elsif( eqsig( $angle, $sigma, 120, 0 ) &&
                 (( $crystal_class eq "rhombohedral" &&
                    $h_m_symbol =~ /^H|:H$/ ) ||
                  $crystal_class eq "trigonal" ||
                  $crystal_class eq "hexagonal" )) {
            $regcell[$i] = 120;
        }
    }

    if( $crystal_class eq "rhombohedral" && $h_m_symbol !~ /^H|:H$/ ) {
        if( eqsig( $cell->[3], $cellsig[3], $cell->[4], $cellsig[4] ) &&
            eqsig( $cell->[3], $cellsig[3], $cell->[5], $cellsig[5] ) &&
            eqsig( $cell->[4], $cellsig[4], $cell->[5], $cellsig[5] )) {
            $regcell[4] = $regcell[5] = $regcell[3];
        }
    }

    return @regcell;
}

sub check_spacegroup_constraints
{
    my ( $dataset, $filename ) = @_;

    if( !defined $dataset->{values} ) {
        return 0;
    }

    my ( $spacegroup_descr, $warnings ) =
        get_spacegroup_descriptions( $dataset, $filename );

    if( !defined $spacegroup_descr ) {
        return $warnings;
    }

    if( !exists $spacegroup_descr->{constraints} ) {
        error_reporter( $filename, undef, $dataset->{name},
                        "could not find constraints for spacegroup ".
                        "'$spacegroup_descr->{universal_h_m}'" );
        return $warnings + 1;
    }

    my $constraints = $spacegroup_descr->{constraints};
    my $cryst_class = $spacegroup_descr->{crystal_class};
    my $h_m_symbol = $spacegroup_descr->{universal_h_m};
    my @cell = get_unit_cell( $dataset, $filename );
    my @cellsig = get_unit_cell_sigmas( $dataset, $filename );

    do {
        my ( $a, $b, $c, $alpha, $beta, $gamma );

        if( $use_precisions ) {
            ( $a, $b, $c, $alpha, $beta, $gamma ) =
                regularize_cell( \@cell, \@cellsig,
                                 $cryst_class, $h_m_symbol );
        } else {
            ( $a, $b, $c, $alpha, $beta, $gamma ) = @cell;
        }

        do {
            local $" = ", ";
            print ">>> CELL: @cell\n";
            print ">>> REGULARISED: $a, $b, $c, $alpha, $beta, $gamma\n";
        } if 0;

        if( !eval $constraints ) {
            local $" = " ";
            error_reporter( $filename, undef, $dataset->{name},
                            "unit cell '@cell' does not satisfy " .
                            "constraints '$constraints'" );
            return $warnings+1;
        }

        do {
            local $" = " ";
            print( "$0: $filename  $dataset->{name}: " .
                   "unit cell '$a $b $c $alpha $beta $gamma' IS FINE with " .
                   "constraints '$constraints'!\n" );
        } if 0;
    };
    return $warnings;
}

sub check_symmetry_operators
{
    my ($dataset, $filename) = @_;

    if( !defined $dataset->{values} ) {
        return 0;
    }

    my $symop_term = '(?:x|y|z|\d|\d*\.\d+|\d+\.\d*|\d/\d)';
    my $symop_component =
        "(?:(?:-|\\+)?$symop_term|" .
        "(?:-|\\+)?$symop_term(?:-|\\+)$symop_term|" .
        "(?:-|\\+)?$symop_term(?:-|\\+)$symop_term(?:-|\\+)$symop_term)";

    my $symops = $dataset->{values}{_symmetry_equiv_pos_as_xyz};

    if( !defined $symops ) {
        return 0; # Let's not regard missing symmetry operators as error.
    } else {
        for my $symop (@$symops) {
            my $no_spaces = $symop;
            $no_spaces =~ s/\s//g;
            if( $no_spaces !~ 
                /^($symop_component,){2}($symop_component)$/i ) {
                error_reporter( $filename, undef, $dataset->{name},
                                "symmetry operator "
                                . "'$symop' could not be parsed");
                return 1;
            }
        }
    }
    return 0;
}

sub error_reporter
{
    my ($file, $line, $data, $message) = @_;
    $line = ( defined $line ) ? '(' . $line . ')' : '';
    my $output = $0;
    if( defined $file || defined $data ) {
        $file = '-' unless $file;
        $data = ( defined $data ) ? ' data_' . $data : '';
        $output .= ': ' . $file . $line . $data;
    }
    $output .= ': ' . $message . "\n";
    print reportFileFH $output;
    flush reportFileFH;
    return 0;
}

sub parser_error_reporter
{
    my ($file, $line, $data) = @_;
    return error_reporter($file, $line, $data, "line currently"
                            ." processed: $line");
}

# To check that the specified XYZ tag value is within expected limits.

sub check_limits {
    my( $dataset, $filename ) = @_;
    my $dataname = 'data_' . $dataset->{name};
    my $warnings = 0;
    
    if(! defined $dataset->{values} ) {
        return 0;
    }
    my @report_names = ( "ERROR", "WARNING", "NOTE" );
    my $numeric = '([+-]?(\d+(\.\d*)?|\.\d+))';
    my $values = $dataset->{values};
    
    foreach my $tag( keys %$limits_table ) {
        if( exists $values->{$tag} ) {
            my $value = $values->{$tag}[0];
            if( $value =~ /^(\.|\?)$/ ) {
                next;
            }
            if( $value !~ /^([+-]?(?:\d+(?:\.\d*)?|\.\d+))\(?(\d*)\)?$/ ) {
                print STDERR "$0: $filename $dataname: ERROR, tag '$tag' " .
                    "value '$value' is not numeric.\n";
                $warnings++;
                next;
            } else {
                my $number = $1;
                my $precision = $2;
                if( ($tag =~ /_w?R_factor_/) && ( $precision ) ) {
                    print STDERR "$0: $filename $dataname: WARNING, '$tag' " .
                        "value is '$value', but it should be numeric and " .
                        "without presicion (esd value).\n";
                    $warnings++;
                    next;
                }
                if( $number < 0 ) {
                    print STDERR "$0: $filename $dataname: WARNING, '$tag' " .
                        "value '$value' should be in range [0.0;+inf].\n";
                    $warnings++;
                    next;
                } elsif(! defined $limits_table->{$tag}[0][1] ) {
                    foreach my $i( 0..$#{ $limits_table->{$tag} } ) {
                        my $limit = @{ $limits_table->{$tag}->[$i]}[0];
                        if( $number > $limit ) {
                            error_reporter($filename, undef, $dataset->{name},
                                           $report_names[$i] .       
                                           ", tag '$tag' value '$value' " .
                                           "is > " . $limit . ".");
                            $warnings ++;
                            last;
                        }
                    }
                } else {
                    foreach my $i( 0..$#{ $limits_table->{$tag} } ) {
                        my $begin = @{ $limits_table->{$tag}->[$i]}[0];
                        my $end = @{ $limits_table->{$tag}->[$i]}[1];
                        if( ($number < $begin) || ($number > $end) ) {
                            error_reporter( $filename, undef, $dataset->{name},
                                            $report_names[$i] .       
                                            ", tag '$tag' value '$value' " .
                                            "lies outside the range " . 
                                            $begin . " <> " . $end . "." );
                            $warnings ++;
                            last;
                        } 
                    }
                    
                }
            }
        }
    }
    return $warnings;
}
