#!/usr/bin/perl

#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Rev$
#$URL$
#------------------------------------------------------------------------------
#*
#   Calculates minimal distance between atoms read from a cif file.
#**

use lib "../../CIFData/";
use lib "../../Spacegroups/";
use lib "../../CIFParser/";
use lib "../../lib/perl5/";
use lib "../../";

use strict;
use warnings;
use File::Basename;
use CIFCellContents;
use CIFParser;
use Fractional;
use Spacegroups::SymopParse;
use Spacegroups::SpacegroupNames;
use CIFData::CIFSymmetryGenerator;
use SOptions;
use SUsage;

my $print_distance_matrix = 1;
my $print_pairwise;
my $print_original;
my $print_symmetrical;
my $print_shifted;
my $add_filename;
my $verbose;
my $format = "%-11.3f";
my $line_length = 80;

#** -F, --add-filename
#**                     Add a filename field at the end of pairwise 
#**                     distance format lines.
#** --no-add-filename,--do-not-add-filename
#**                     Do not add a filename field at the end of 
#**                     pairwise distance format lines (default).
#** -H, --shifted-atoms
#**                     Print atoms generated by shifting all the atoms 
#**                     of the first octant.
#** --no-shifted-atoms  
#**                     Do not print shifted atoms (default).
#** -M, --distance-matrix
#**                     Set distance matrix output format (default).
#** -O, --original-atoms
#**                     Print atoms read from cif file.
#** --no-original-atoms
#**                     Do not print original atoms (default).
#** -P, --pairwise-distance
#**                     Set pairwise distance output format.
#** -S, --symetrical-atoms
#**                     Print atoms generated by applying symmetry 
#**                     operators.
#** --no-symetrical-atoms
#**                     Do not print symetrical atoms (default).
#** -l, --matrix-line-length "80"
#**                     Maximum length of an output line in distance 
#**                     matrix format (default 80).
#** --format "%8.6f"    
#**                     Use the specified format for distance matrix 
#**                     format printout (default "%-11.3f").
#** --help,--usage      Print a short usage message (this message) and exit.

@ARGV = getOptions(
    "-F,--add-filename"       => sub { $add_filename = 1 },
    "--no-add-filename"       => sub { $add_filename = undef },
    "--do-not-print-filename" => sub { $add_filename = undef },
    "-H,--shifted-atoms"      => sub { $print_shifted = 1 },
    "--no-shifted-atoms"      => sub { $print_shifted = undef },
    "-M,--distance-matrix"    => sub { $print_distance_matrix = 1;
                                       $print_pairwise = undef },
    "-O,--original-atoms"     => sub { $print_original = 1 },
    "--no-original-atoms"     => sub { $print_original = undef },
    "-P,--pairwise-distance"  => sub { $print_pairwise = 1;
                                       $print_distance_matrix = undef },
    "-S,--symetrical-atoms"   => sub { $print_symmetrical = 1 },
    "--no-symetrical-atoms"   => sub { $print_symmetrical = undef },
    "-l,--matrix-line-length" => sub { $line_length = get_value() },
    "--format"                => sub { $format = get_value() },
    "-v,--verbose"            => sub { $verbose = 1;
                                       $print_shifted = 1;
                                       $print_original = 1;
                                       $print_symmetrical = 1 },
    "-s,--silent,--quiet"     => sub { $verbose = undef;
                                       $print_shifted = undef;
                                       $print_original = undef;
                                       $print_symmetrical = undef },
    "--help,--usage"          => sub { SUsage::usage; exit },
);

@ARGV = ( "-" ) unless @ARGV;

if ( $print_pairwise ) {
    print "FORMAT cif-distances_paired http://cod.ibt.lt/cod-tools/trunk" .
	      "/perl-scripts/cif-distances/output_format/cif-distances_paired_v1.0 \n";
} else {
    print "FORMAT distance-matrix v1.0 http://cod.ibt.lt/cod-tools/trunk" .
	      "/perl-scripts/cif-distances/docs/cif_distances_matrix_v1.0 \n";
}

foreach my $filename ( @ARGV ) {

    my $parser = new CIFParser;

    my $data = $parser->Run( $filename );

    foreach my $dataset ( @$data ) {

        my $values = $dataset->{values};

        #   extracts atom site label or atom site type symbol
        my $loop_tag;

        eval {

        if( exists $values->{ "_atom_site_label" } ) {
            $loop_tag = "_atom_site_label";
        } elsif( exists $values->{ "_atom_site_type_symbol" } ) {
            $loop_tag = "_atom_site_type_symbol";
        } else {
            error( $0, $filename, $dataset->{name},
                   "neither _atom_site_label nor _atom_site_type_symbol " .
                   "was found in the input file" );
        }
    
        #   extracts cell constants
        my @unit_cell =
            CIFSymmetryGenerator::get_cell( $values, $filename, $dataset->{name} );
    
        my $ortho_matrix = symop_ortho_from_fract( @unit_cell );
    
        #   extracts symmetry operators
        my $sym_data = CIFSymmetryGenerator::get_symmetry_operators( 
                                                    $dataset, $filename );

        #   extracts atoms
        my $atoms = CIFCellContents::get_atoms( $dataset, $filename, $loop_tag );
        
        @$atoms = sort { ( $a -> {atom_type} cmp $b -> {atom_type} ) ||
                         ( $a -> {atom_name} cmp $b -> {atom_name} ) } @$atoms;
        
        my $printable_properties = [ "atom_name", "atom_type", 
                                     "coordinates_ortho", "coordinates_fract" ];
    
        if ( $print_original ) {
            print_atoms( $atoms, $printable_properties );
        }
    
        #   generates atoms by applying symmetry operators.
        #   at this subroutine original atoms are fitted into the first octant
        #   by applying x,y,z operator modulus 1
        my ( $sym_atoms, $symmetry_operator_count );        

            ( $sym_atoms, $symmetry_operator_count ) = 
                                            generate_symmetrical_atoms( 
                                                       $sym_data, 
                                                       $atoms, 
                                                       $ortho_matrix 
                                                       );

        push @$printable_properties, "sym_operator";
        if ( $print_symmetrical ) {
            print_atoms( $sym_atoms, $printable_properties );
        }
    
        my @shifted_atoms = map { shift_atom( $_, $ortho_matrix ) } @{$sym_atoms};
    
        push @$printable_properties, "shift_vector";
        if ( $print_shifted ) {
            print_atoms( \@shifted_atoms, $printable_properties );
        }
    
        my ( $distances, $headers, $atoms_used ) = get_distances( \@shifted_atoms, 
                                                       $symmetry_operator_count );
    
        if ( $print_distance_matrix ) {
            print_distance_matrix( $distances, $headers, $format, 
                                   $line_length );
        }
    
        if ( $print_pairwise ) {
            print_pairwise( $distances, $atoms_used, $filename, $add_filename );
        }
        
        }; warn $@ if $@;
    }
}

exit;

##
# Generates symmetrical atoms from the given original atoms and 
# symmetry operators.
# @param $sym_data
#       Reference to an array containing symmetry operators in string 
#       format.
# @param $atoms
#       Reference to an array of original atoms. 
# @param $ortho_matrix
#       Reference to a struture containing matrix, that is used to
#       convert fractional coordinates to orthogonal in the newly
#       generated atoms.
#  @return
#       Reference to an array containing atoms generated by applying 
#       symmetry operators. Each atom hash is given a new field 
#       "sym_operator".
##

sub generate_symmetrical_atoms {
    my ( $sym_data, $atoms, $ortho_matrix ) = @_;

    # computes symmetry operator matrices
    my @sym_operators = map { SymopParse::symop_from_string( $_ ) } @{$sym_data};
    # converts matrices back to strings all having the same format.
    @{$sym_data} = map { SymopParse::string_from_symop( $_ ) } @{sym_operators};

    my $sym_atoms = CIFSymmetryGenerator::symop_generate_atoms( 
                                                    \@sym_operators, 
                                                    $atoms,
                                                    $ortho_matrix );

    # It might be better to make a copy of the symop_generate_atoms 
    # subroutine and add the symmetry opperator directly there    
    my $i = 0;
    foreach ( @{ $sym_atoms } ) {
        $_ -> { "sym_operator" } = @$sym_data[ $i ];
        
        $i++;
        if ( $i >= @$sym_data ) {
            $i = 0;
        };
    }    

    return $sym_atoms, scalar( @sym_operators );
}

##
# Calculates the minimum distance between two atoms from the given array.
# It is expected that atoms, derived from the original atom by applying
# symmetry operator and shifting operators, are put near each other in the 
# array, making groups of size $sym_operator_count * 27 (number of 
# octants). Since all atoms of the cluster are derived from one original 
# atom, distances between them are not calculated.
# @param $all_atom
#       Reference to an array containing all atoms generated after 
#       applying symmetry and shift operators.
# @param $sym_operator_count
#       Number of symmetry operators that have been applied.
##

sub get_distances {
    my ( $all_atoms, $sym_operator_count ) = @_; 
    my $group_size = $sym_operator_count * 27; # 27 is the number of octants
    my $number_of_groups = @$all_atoms/$group_size;
    my @headers;
    my @distances;
    my @atoms_used;
    
    # $i holds the index of the first group
    for ( my $i  = 0; $i < $number_of_groups; $i++ ) {
        my $atom_1 = $all_atoms -> [ $i * $group_size ]; # acquiring first atom
        
        push @headers, "$atom_1->{atom_name}/$atom_1->{atom_type}";
        my @atom_rows_used;
        push @atom_rows_used, $atom_1;
        my @distance_row;
        push @distance_row, 0;
        
        # $j holds the index of the second group
        for ( my $j = $i + 1; $j < $number_of_groups; $j++ ) {
            my $atom_2 = $all_atoms->[ $j * $group_size ];
            my $min_distance = get_distance( $atom_1->{coordinates_ortho}, 
                                             $atom_2->{coordinates_ortho} );
            my $min_index = 0;
            
            # $k holds the element index in the second group 
            for ( my $k = 1; $k < $group_size; $k++ ) {
                $atom_2 = $all_atoms -> [ $j * $group_size + $k ];
                my $distance = get_distance( $atom_1->{coordinates_ortho}, 
                                             $atom_2->{coordinates_ortho} );
                
                if ( $distance < $min_distance ) {
                     $min_distance = $distance;
                     $min_index = $k;
                }
            }

            push @distance_row, $min_distance;
            push @atom_rows_used, $all_atoms -> [ $j * $group_size + $min_index ];

        }

        push @distances, \@distance_row;
        push @atoms_used, \@atom_rows_used;
    }

return ( \@distances, \@headers, \@atoms_used );
}

##
# Calculates distance between two equal length vectors.
# @param $vector1
#       Reference to an array of coordinates of the first vector.
# @param $vector2
#       Reference to an array of coordinates of the second vector.
# @return
#       Distance between vectors.
##

sub get_distance {
    my ( $vector1, $vector2 ) = @_;
    my $dist = 0;

    for ( my $i = 0; $i < @{$vector1}; $i++ ) {
        $dist += ( ${$vector1}[ $i ] - ${$vector2}[ $i ] ) ** 2;
    }
    return sqrt( $dist );
}

##
# Returns an array of atom hashes generated by shifting the original 
# atom in 26 directions (3-D space).
# @param $atom_ref
#       Reference to a hash, containing atom information.
# @return @shifted_atoms;
#       Array of atom hashes.
##

sub shift_atom {
    my ( $atom_ref, $ortho_matrix ) = @_;

    $atom_ref->{ "shift_vector" } = "5,5,5";
    my @shifted_atoms;
    push @shifted_atoms, $atom_ref;
    my @shifting_params = ( -1, 0, 1 );
    
    for( my $x = 0; $x < @shifting_params; $x++ ) {
        for( my $y = 0; $y < @shifting_params; $y++ ) {
            for( my $z = 0; $z < @shifting_params; $z++ ) {
                my %new_atom;
                my @new_atom_xyz;
                if( $shifting_params[ $x ] != 0 || 
                    $shifting_params[ $y ] != 0 ||
                    $shifting_params[ $z ] != 0 ) {
                    $new_atom_xyz[ 0 ] =
                        $atom_ref->{ "coordinates_fract" }[ 0 ] +  
                                     $shifting_params[ $x ];
                    $new_atom_xyz[ 1 ] =
                        $atom_ref->{ "coordinates_fract" }[ 1 ] +  
                                     $shifting_params[ $y ];
                    $new_atom_xyz[ 2 ] =
                        $atom_ref->{ "coordinates_fract" }[ 2 ] +  
                                     $shifting_params[ $z ];
            
                    $new_atom{ "coordinates_fract" } = \@new_atom_xyz;
                    $new_atom { "coordinates_ortho" } =
                    CIFSymmetryGenerator::mat_vect_mul( $ortho_matrix,
                    $new_atom { "coordinates_fract" } );
                    $new_atom{ "atom_type" } = $atom_ref->{ "atom_type" };
                    $new_atom{ "atom_name" } = $atom_ref->{ "atom_name" };
                    $new_atom{ "sym_operator" } = $atom_ref->{ "sym_operator" };
                    $new_atom{ "shift_vector" } = ( 5 + $shifting_params[ $x ] ) . "," .
                                                  ( 5 + $shifting_params[ $y ] ) . "," .
                                                  ( 5 + $shifting_params[ $z ] );
                    push( @shifted_atoms, \%new_atom );
                }
            }
        }
    }

    return @shifted_atoms;
}

##
# Prints atoms fieldname values from an array.
# @param $array_ref
#       Reference to an array from which the atoms are printed.  
##

sub print_atoms {
    my ( $array_ref, $properties ) = @_;
    foreach my $atom_ref ( @$array_ref ) {
        foreach my $property ( @$properties ) {
            if ( $property eq "atom_name" ) {
                print "Atom name: $atom_ref->{atom_name} \n";
            } elsif ( $property eq "atom_type" ) {
                print "Atom type: $atom_ref->{atom_type} \n";
            } elsif ( $property eq "occupancy" ) {
                print "Ocupancy: $atom_ref->{occupancy} \n";
            } elsif ( $property eq "cif_multiplicity" ) {
                print "cif_multiplicity: " . 
                      "$atom_ref->{cif_multiplicity} \n";
            } elsif ( $property eq "coordinates_ortho" ) {
                printf 'Orthogonal coordinates: %8.3f %8.3f %8.3f',
                        $atom_ref -> {coordinates_ortho} -> [0],
                        $atom_ref -> {coordinates_ortho} -> [1],
                        $atom_ref -> {coordinates_ortho} -> [2];
                print "\n";
            } elsif ( $property eq "coordinates_fract" ) {
                printf 'Fractional coordinates: %8.3f %8.3f %8.3f',
                        $atom_ref -> {coordinates_fract} -> [0],
                        $atom_ref -> {coordinates_fract} -> [1],
                        $atom_ref -> {coordinates_fract} -> [2];
                print "\n";
            } elsif ( $property eq "shift_vector" ) {
                print "Shift vector: " .
                    "$atom_ref->{shift_vector} \n";
            } elsif ( $property eq  "sym_operator" ) {
                print "Symmetry operator: " . 
                      "$atom_ref->{sym_operator} \n";
            }
        }
    }
}

##
# Prints distances between atoms in the default format, defined in
# cod-tools/trunk/perl-scripts/cif-distances/cif-distances_matrix_v.1
# @param $distance_ref
#       Reference to an array distances between atoms.
# @param $header_ref;
#       Reference to an array of strings containing information about 
#       atoms that were used in the calculation of distances.
# @param $fraction_precision
#       Number of fraction digits of the distances that should be printed.
# @param $line_length
#       Length of the matrix line in symbols.
##

sub print_distance_matrix {
    my ( $distance_ref, $header_ref, $format, $line_length ) = @_;
    my @distances = @$distance_ref;
    my $cell_width;
    if ( $format =~ /^%\D*(\d+)\D/ ) {
        $cell_width = $1;
    } else {
        $cell_width = 11;
    }
    use POSIX;
    my $cell_count = floor ( $line_length / $cell_width ) - 1;

    my $print_iteration = 0;
    while ( $print_iteration < ceil( @distances / $cell_count ) ) {
        my $start_cell_index = $cell_count * $print_iteration;
        my $finish_cell_index = $cell_count * ( $print_iteration + 1 );
        if ( $finish_cell_index > @distances ) {
            $finish_cell_index = @distances;
        }
        
        printf( "%-${cell_width}s", "ATOMS" );
        for ( my $k = $start_cell_index; $k < $finish_cell_index; $k++ ) {
            printf( "%-${cell_width}s", @$header_ref[ $k ] );
        }
        print "\n";
        
        for ( my $i = 0; $i < @distances; $i++ ) {
            printf( "%-${cell_width}s", @$header_ref[ $i ] );
            for ( my $j = $start_cell_index; $j < $finish_cell_index; $j++ ) {
                if ( $i == $j ) {
                    printf( $format, 0 )
                } elsif ( $j > $i ) {
                    printf( $format, $distances[ $i ][ $j - $i ] );
                } else {
                    printf( $format, $distances[ $j ][ $i - $j ] );
                }
            };
            print "\n";
        }
        
        print "\n";
        $print_iteration++;
    }
}

##
# Prints distances between atoms in an alternative format, defined in
# cod-tools/trunk/perl-scripts/cif-distances/cif-distances_paired_v.1
# @param $distances
#       Reference to an array distances between atoms.
# @param $atoms_used
#       Reference to an array of atoms that were used in the calculation
#       of the distances.
##

sub print_pairwise {
    my ( $distances, $atoms_used, $filename, $print_filename ) = @_;
    
    for ( my $i = 0; $i < @$atoms_used; $i++ ) {
        my $atom_1 = @$atoms_used[ $i ] -> [ 0 ];

        for ( my $j = 1; $j < @{ @$atoms_used[ $i ] }; $j++ ) {
            my $atom_2 = @$atoms_used[ $i ] -> [ $j ];
            
            printf( 'DIST %-6.3f %10s %10s %24s %8s ', 
                    @$distances[ $i ] -> [ $j ], 
                    $atom_1 -> { atom_name }."/".$atom_1 -> {atom_type},
                    $atom_2 -> { atom_name }."/".$atom_2 -> {atom_type},
                    $atom_2 -> { sym_operator },
                    $atom_2 -> { shift_vector },
                    );
            if ( $print_filename ) {
                print basename( $filename );
            }
            print "\n";
        }
    }
}
