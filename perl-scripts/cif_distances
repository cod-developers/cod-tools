#!/usr/bin/perl

#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Rev$
#$URL$
#------------------------------------------------------------------------------
#*
#   Calculates minimal distance between atoms read from a cif file.
#**

use lib "../../CIFData/";
use lib "../../Spacegroups/";
use lib "../../CIFParser/";
use lib "../../lib/perl5/";
use lib "../../";

use strict;
use warnings;
use File::Basename; 
use CIFData::CIFCellContents;
use CIFParser;
use Fractional;
use Spacegroups::SymopParse;
use Spacegroups::SpacegroupNames;
use SOptions;
use SUsage;
use UserMessage;

my $print_distance_matrix = 1;
my $uniquify_atoms = 1;
my $print_pairwise;
my $print_original;
my $print_symmetrical;
my $print_shifted;
my $add_filename;
my $verbose;
my $format = "%-11.3f";
my $line_length = 80;

@ARGV = getOptions( 

#** -F, --add-filename
#**                     Add a filename field at the end of pairwise 
#**                     distance format lines.
#** --no-add-filename,--do-not-add-filename
#**                     Do not add a filename field at the end of 
#**                     pairwise distance format lines (default).
#** -H, --shifted-atoms
#**                     Print atoms generated by shifting all the atoms 
#**                     of the first octant.
#** --no-shifted-atoms  
#**                     Do not print shifted atoms (default).
#** -M, --distance-matrix
#**                     Set distance matrix output format (default).
#** -O, --original-atoms
#**                     Print atoms read from cif file.
#** --no-original-atoms
#**                     Do not print original atoms (default).
#** -P, --pairwise-distance
#**                     Set pairwise distance output format.
#** -S, --symetrical-atoms
#**                     Print atoms generated by applying symmetry 
#**                     operators.
#** --no-symetrical-atoms
#**                     Do not print symetrical atoms (default).
#** -l, --matrix-line-length "80"
#**                     Maximum length of an output line in distance 
#**                     matrix format (default 80).
#** --format "%8.6f"    
#**                     Use the specified format for distance matrix 
#**                     format printout (default "%-11.3f").
#** --uniquify-atoms
#**                    Makes unique the labels of atoms (default).
#** --no-uniquify-atoms
#**                    Does not make unique labels for atoms.
#** -v, --verbose
#**                    Print additional information for each step of the script.
#** -s, --silent, --quiet
#**                    Print no additional information.
#** --help,--usage     Print a short usage message (this message) and exit.

    "-F,--add-filename"       => sub { $add_filename = 1 },
    "--no-add-filename"       => sub { $add_filename = undef },
    "--do-not-print-filename" => sub { $add_filename = undef },
    "-H,--shifted-atoms"      => sub { $print_shifted = 1 },
    "--no-shifted-atoms"      => sub { $print_shifted = undef },
    "-M,--distance-matrix"    => sub { $print_distance_matrix = 1;
                                       $print_pairwise = undef },
    "-O,--original-atoms"     => sub { $print_original = 1 },
    "--no-original-atoms"     => sub { $print_original = undef },
    "-P,--pairwise-distance"  => sub { $print_pairwise = 1;
                                       $print_distance_matrix = undef },
    "-S,--symetrical-atoms"   => sub { $print_symmetrical = 1 },
    "--no-symetrical-atoms"   => sub { $print_symmetrical = undef },
    "-l,--matrix-line-length" => sub { $line_length = get_value() },
    "--format"                => sub { $format = get_value() },
    "-v,--verbose"            => sub { $verbose = 1;
                                       $print_shifted = 1;
                                       $print_original = 1;
                                       $print_symmetrical = 1 },
    "--uniquify-atoms"      => sub { $uniquify_atoms = 1; },
    "--no-uniquify-atoms"   => sub { $uniquify_atoms = 0; },
    "-s,--silent,--quiet"     => sub { $verbose = undef;
                                       $print_shifted = undef;
                                       $print_original = undef;
                                       $print_symmetrical = undef },
    "--help,--usage"          => sub { SUsage::usage; exit }
);

@ARGV = ( "-" ) unless @ARGV; 

if ( $print_pairwise ) {
    print "FORMAT pairwise_distance v1.0 svn://www.crystallography.net/" . 
          "cod-tools/trunk/perl-scripts/docs/" .
          "cif_distances_pairwise_distance_v1.0\n"
} else {
    print "FORMAT distance_matrix v1.0 svn://www.crystallography.net/cod-tools/" .
          "trunk/perl-scripts/docs/cif_distances_distance_matrix_v1.0\n";
}

foreach my $filename ( @ARGV ) { 

    my $parser = new CIFParser;

    my $data = $parser->Run( $filename );

    foreach my $dataset ( @$data ) {

        eval {
    
        #   extracts cell constants
        my @unit_cell =
            CIFSymmetryGenerator::get_cell( $dataset->{values}, $filename, 
                                            $dataset->{name} );
    
        my $ortho_matrix = symop_ortho_from_fract( @unit_cell );
    
        #   extracts symmetry operators
        my $sym_data = CIFSymmetryGenerator::get_symmetry_operators( 
                                                    $dataset, $filename );

        #   extracts atoms
        my $atoms = get_atoms( $dataset, $ortho_matrix, $filename, $uniquify_atoms );
        
        @$atoms = sort { ( $a -> {chemical_type} cmp $b -> {chemical_type} ) ||
                         ( $a -> {label} cmp $b -> {label} ) } @$atoms;
        
        my $printable_properties = [ "label", "chemical_type", 
                                     "coordinates_ortho", "coordinates_fract",
                                     "disorder_group", "disorder_assembly" ];
    
        if ( $print_original ) {
            print_atoms( $atoms, $printable_properties );
        }
    
        #   generates atoms by applying symmetry operators.
        #   at this subroutine original atoms are fitted into the first octant
        #   by applying x,y,z operator modulus 1        

        my ( $sym_atoms, $symop_count ) = symops_apply( $sym_data, $atoms,
                                                        $ortho_matrix );

        push @$printable_properties, "sym_operator";
        if ( $print_symmetrical ) {
            print_atoms( $sym_atoms, $printable_properties );
        }
    
        my @shifted_atoms = map { shift_atom( $_, $ortho_matrix ) } @{$sym_atoms};
    
        push @$printable_properties, "shift_vector";
        if ( $print_shifted ) {
            print_atoms( \@shifted_atoms, $printable_properties );
        }
    
        my ( $distances, $headers, $atoms_used ) = get_distances( \@shifted_atoms, 
                                                                  $symop_count );
    
        if ( $print_distance_matrix ) {
            print_distance_matrix( $distances, $headers, $format, $line_length );
        }
    
        if ( $print_pairwise ) {
            print_pairwise( $distances, $atoms_used, $filename, $add_filename );
        }
        
        }; warn $@ if $@;
    }
}

exit;

##
# Extracts atom information from given dataset.
# @param $dataset
#       Dataset containing cif file information extracted by a cif file parser.
# @param $ortho_matrix
#       Reference to a structure containing matrix information used to convert
#       fractional coordinates to orthogonal.
# @return $atoms
#       Reference to a data structure containing atom information.
##

sub get_atoms {

    my ( $dataset, $ortho_matrix, $filename, $uniquify_atoms ) = @_;

    my $values = $dataset->{values};
    my $dataset_name = $dataset->{name};

    #   extracts atom site label or atom site type symbol
    my $atom_site_tag;

    if( exists $values->{"_atom_site_label"} ) {
        $atom_site_tag = "_atom_site_label";
    } elsif( exists $values->{"_atom_site_type_symbol"} ) {
        $atom_site_tag = "_atom_site_type_symbol";
    } else {
        error( $0, $filename, $dataset->{name},
               "neither _atom_site_type_symbol nor _atom_site_label were found" );
	return undef;
    }

    my @atoms;

    for my $i ( 0 .. $#{$values->{$atom_site_tag}} ) {
        my $atom = {
            label => $values->{$atom_site_tag}[$i],
            chemical_type => exists $values->{_atom_site_type_symbol} ?
                $values->{_atom_site_type_symbol}[$i] : undef,
            disorder_group => exists $values->{_atom_site_disorder_group}[$i] ?
                $values->{_atom_site_disorder_group}[$i] : ".",
            disorder_assembly => exists $values->{_atom_site_disorder_assembly}[$i] ?
                $values->{_atom_site_disorder_assembly}[$i] : ".",
            coordinates_fract => [
                $values->{_atom_site_fract_x}[$i],
                $values->{_atom_site_fract_y}[$i],
                $values->{_atom_site_fract_z}[$i]
            ],
        };

        if( !defined $atom->{chemical_type} ) {
            $atom->{chemical_type} = $atom->{label};
        }

        if( $atom->{chemical_type} =~ m/^([A-Za-z]{1,2})/ ) {
            $atom->{chemical_type} = ucfirst( lc( $1 ));
        }

        @{$atom->{coordinates_fract}} = map { s/\(\d+\)\s*$//; $_ }
            @{$atom->{coordinates_fract}};  

        $atom->{coordinates_ortho} =
            CIFSymmetryGenerator::mat_vect_mul( $ortho_matrix,
                                                $atom->{coordinates_fract} );

        if( defined $values->{_atom_site_occupancy} ) {
            if( $values->{_atom_site_occupancy}[$i] ne '?' &&
                $values->{_atom_site_occupancy}[$i] ne '.' ) {
                $atom->{occupancy} = $values->{_atom_site_occupancy}[$i];
                $atom->{occupancy} =~ s/\(\d+\)\s*$//;
            } else {
                $atom->{occupancy} = 1;  
            }
        }

        if( defined $values->{_atom_site_symmetry_multiplicity} &&
            $values->{_atom_site_symmetry_multiplicity}[$i] ne '?' ) {
            $atom->{cif_multiplicity} =
                $values->{_atom_site_symmetry_multiplicity}[$i];
        }

        push( @atoms, $atom );
    }
    
    return uniquify_atom_names( \@atoms, $uniquify_atoms, $filename, $dataset_name );
}

##
# Renames atoms upon them having identical names.
# @param $init_atoms
#       Reference to an array of
#       $atom_info = {
#                     label=>"C1_2",
#                     chemical_type=>"C",
#                     coordinates_fract=>[1.0, 1.0, 1.0],
#                     coordinates_ortho=>[5.3, 6.1, 5.3],
#                     disorder_assembly=>"A", # ".",
#                     disorder_group=>"1", # ".",
#                     occupancy=>"1"
#                    }
# @param $uniquify_atoms
#       Logical value which determines whether atoms should be uniquified.
# @param $filename
#       Name of the file that is currently proccessed.
# @dataset_name
#       Name of the proccessed dataset.
# @return
#       Reference to an array of proccessed atoms.    
##

sub uniquify_atom_names()
{
    my ( $init_atoms, $uniquify_atoms, $filename, $dataset_name ) = @_;

    my $max_label_suffix = 30000; # Maximum number to be appened to labels 
                                  # when trying to produce unique names.

    my @checked_initial_atoms;

    my %used_labels;
    my @labels_to_be_renamed;

    foreach my $atom ( @{$init_atoms} )
    {
        my $atom_copy = CIFSymmetryGenerator::copy_atom( $atom );
        my $label = $atom->{label};

        push( @checked_initial_atoms, $atom_copy );

        if( ! exists $used_labels{$label} ) {
            $used_labels{$label}{atoms} = [ $atom_copy ];
        } else {
            push( @{$used_labels{$label}{atoms}}, $atom_copy );
            warning( $0, $filename, $dataset_name,
                     "atom label '$label' is not unique" );
            push( @labels_to_be_renamed, $label );
        }
        $used_labels{$label}{count} ++;
    }

    if( $uniquify_atoms )
    {
        foreach my $label (@labels_to_be_renamed)
        {
            foreach my $renamed_atom (@{$used_labels{$label}{atoms}}) {
                my $id = 0;
                while( exists $used_labels{$label . "_" .$id} &&
                       $id <= $max_label_suffix ) {
                    $id ++;
                }
                if( $id > $max_label_suffix ) {
                    error( $0, $filename, $dataset_name,
                           "could not generate unique atom name for ".
                           "atom '$label', even after $id iterations" );
                }
                my $new_label = $label . "_" . $id;
                warning( $0, $filename, $dataset_name,
                         "renaming atom '$label' " .
                         "to '" . $new_label . "'" );
                $renamed_atom->{label}          = $new_label;
                $renamed_atom->{original_label} = $new_label;
                $used_labels{$new_label}{count} ++;
            }
        }
    }

    return \@checked_initial_atoms;
}

##
# Generates symmetrical atoms from the given original atoms and 
# symmetry operators.
# @param $sym_data
#       Reference to an array containing symmetry operators in string 
#       format.
# @param $atoms
#       Reference to an array of original atoms. 
# @param $ortho_matrix
#       Reference to a struture containing matrix, that is used to
#       convert fractional coordinates to orthogonal in the newly
#       generated atoms.
#  @return
#       Reference to an array containing atoms generated by applying 
#       symmetry operators. Each atom hash is given a new field 
#       "sym_operator".
##

sub symops_apply {
    my ( $sym_data, $atoms, $ortho_matrix ) = @_;

    # computes symmetry operator matrices
    my @sym_operators = map { SymopParse::symop_from_string( $_ ) } @{$sym_data};
    # converts matrices back to strings all having the same format.
    @{$sym_data} = map { SymopParse::string_from_symop( $_ ) } @{sym_operators};

    my $sym_atoms = CIFSymmetryGenerator::symop_generate_atoms( 
                                                    \@sym_operators, 
                                                    $atoms,
                                                    $ortho_matrix );

    # It might be better to make a copy of the symop_generate_atoms 
    # subroutine and add the symmetry opperator directly there    
    my $i = 0;
    foreach ( @{ $sym_atoms } ) {
        $_ -> { "sym_operator" } = @$sym_data[ $i ];
        
        $i++;
        if ( $i >= @$sym_data ) {
            $i = 0;
        };
    }    

    return $sym_atoms, scalar( @sym_operators );
}

##
# Calculates the minimum distance between two atoms from the given array.
# It is expected that atoms, derived from the original atom by applying
# symmetry operator and shifting operators, are put near each other in the 
# array, making groups of size $sym_operator_count * 27 (number of 
# octants). Since all atoms of the cluster are derived from one original 
# atom, distances between them are not calculated.
# @param $all_atom
#       Reference to an array containing all atoms generated after 
#       applying symmetry and shift operators.
# @param $sym_operator_count
#       Number of symmetry operators that have been applied.
##

sub get_distances {
    my ( $all_atoms, $sym_operator_count ) = @_; 
    my $group_size = $sym_operator_count * 27; # 27 is the number of octants
    my $number_of_groups = @$all_atoms/$group_size;
    my @headers;
    my @distances;
    my @atoms_used;
    
    # $i holds the index of the first group
    for ( my $i  = 0; $i < $number_of_groups; $i++ ) {
        my $atom_1 = $all_atoms -> [ $i * $group_size ]; # acquiring first atom
        
        push @headers, "$atom_1->{label}/$atom_1->{chemical_type}";
        my @atom_rows_used;
        push @atom_rows_used, $atom_1;
        my @distance_row;
        push @distance_row, 0;
        
        # $j holds the index of the second group
        for ( my $j = $i + 1; $j < $number_of_groups; $j++ ) {
            my $atom_2 = $all_atoms->[ $j * $group_size ];
            #
            my $min_distance;
            my $min_index = 0;
            
            if ( check_disorder( $atom_1, $atom_2 ) ) {

                $min_distance = get_distance( $atom_1->{coordinates_ortho}, 
                                              $atom_2->{coordinates_ortho} );
                
            
                # $k holds the element index in the second group 
                for ( my $k = 0; $k < $group_size; $k++ ) {
                    $atom_2 = $all_atoms -> [ $j * $group_size + $k ];
                    my $distance = get_distance( $atom_1->{coordinates_ortho}, 
                                                 $atom_2->{coordinates_ortho} );
                
                    if ( $distance < $min_distance ) {
                         $min_distance = $distance;
                         $min_index = $k;
                    }
                }
            } else {
                $min_distance = "-";
            }
            #
            push @distance_row, $min_distance;
            push @atom_rows_used, $all_atoms -> [ $j * $group_size + $min_index ];

        }

        push @distances, \@distance_row;
        push @atoms_used, \@atom_rows_used;
    }

return ( \@distances, \@headers, \@atoms_used );
}

##
# Calculates distance between two equal length vectors.
# @param $vector1
#       Reference to an array of coordinates of the first vector.
# @param $vector2
#       Reference to an array of coordinates of the second vector.
# @return
#       Distance between vectors.
##

sub get_distance {
    my ( $vector1, $vector2 ) = @_;
    my $dist = 0;

    for ( my $i = 0; $i < @{$vector1}; $i++ ) {
        $dist += ( ${$vector1}[ $i ] - ${$vector2}[ $i ] ) ** 2;
    }
    return sqrt( $dist );
}
 
##
# Checks if the atoms belong to the same disorder group.
# @param $atom_1
#       Reference to a hash, containing information of the first atom.
# @param $atom_2
#       Reference to a hash, containing information of the second atom.
# @return
#       undef is atoms belong to different disorder groups but the same 
#       disorder assembly. 1 otherwise. 
##

sub check_disorder {
    my ( $atom_1, $atom_2 ) = @_;
    if ( ( $atom_1 -> {disorder_group} ne "." ) && 
         ( $atom_2 -> {disorder_group} ne "." ) &&
         ( $atom_1 -> {disorder_group} ne $atom_2 -> {disorder_group} ) &&
         ( $atom_1 -> {disorder_assembly} ne "." ) && 
         ( $atom_2 -> {disorder_assembly} ne "." ) &&
         ( $atom_1 -> {disorder_assembly} eq $atom_2 -> {disorder_assembly} ) ) {
        return undef;
    }
    return 1;
}

##
# Returns an array of atom hashes generated by shifting the original 
# atom in 26 directions (3-D space).
# @param $atom_ref
#       Reference to a hash, containing atom information.
# @return @shifted_atoms;
#       Array of atom hashes.
##

sub shift_atom {
    my ( $original_atom, $ortho_matrix ) = @_;

    $original_atom->{ "shift_vector" } = "5,5,5";
    my @shifted_atoms;
    push @shifted_atoms, $original_atom;
    my @shifting_param = ( -1, 0, 1 );
    
    for( my $x = 0; $x < @shifting_param; $x++ ) {
        for( my $y = 0; $y < @shifting_param; $y++ ) {
            for( my $z = 0; $z < @shifting_param; $z++ ) {
                my $new_atom = CIFSymmetryGenerator::copy_atom($original_atom);

                if( $shifting_param[ $x ] != 0 || 
                    $shifting_param[ $y ] != 0 ||
                    $shifting_param[ $z ] != 0 ) {

                    $new_atom -> { coordinates_fract }[0] += $shifting_param[ $x ];
                    $new_atom -> { coordinates_fract }[1] += $shifting_param[ $y ];
                    $new_atom -> { coordinates_fract }[2] += $shifting_param[ $z ];

                    $new_atom -> { coordinates_ortho } =
                    CIFSymmetryGenerator::mat_vect_mul( $ortho_matrix,
                    $new_atom -> { coordinates_fract } );
                    $new_atom->{ shift_vector } = ( 5 + $shifting_param[ $x ] ) . "," .
                                                  ( 5 + $shifting_param[ $y ] ) . "," .
                                                  ( 5 + $shifting_param[ $z ] );
                    push( @shifted_atoms, $new_atom );
                }
            }
        }
    }

    return @shifted_atoms;
}

##
# Prints atoms fieldname values from an array.
# @param $array_ref
#       Reference to an array from which the atoms are printed.  
##

sub print_atoms {
    my ( $array_ref, $properties ) = @_;
    foreach my $atom_ref ( @$array_ref ) {
        foreach my $property ( @$properties ) {
            if ( $property eq "label" ) {
                print "Atom name: $atom_ref->{label} \n";
            } elsif ( $property eq "chemical_type" ) {
                print "Chemical type: $atom_ref->{chemical_type} \n";
            } elsif ( $property eq "occupancy" ) {
                print "Ocupancy: $atom_ref->{occupancy} \n";
            } elsif ( $property eq "cif_multiplicity" ) {
                print "cif_multiplicity: $atom_ref->{cif_multiplicity} \n";
            } elsif ( $property eq "disorder_group" ) {
                print "Atom site disorder group: $atom_ref->{disorder_group} \n";
            } elsif ( $property eq "disorder_assembly" ) {
                print "Atom site disorder assembly: $atom_ref->{disorder_assembly} \n";
            } elsif ( $property eq "coordinates_ortho" ) {
                printf 'Orthogonal coordinates: %8.3f %8.3f %8.3f',
                        $atom_ref -> {coordinates_ortho} -> [0],
                        $atom_ref -> {coordinates_ortho} -> [1],
                        $atom_ref -> {coordinates_ortho} -> [2];
                print "\n";
            } elsif ( $property eq "coordinates_fract" ) {
                printf 'Fractional coordinates: %8.3f %8.3f %8.3f',
                        $atom_ref -> {coordinates_fract} -> [0],
                        $atom_ref -> {coordinates_fract} -> [1],
                        $atom_ref -> {coordinates_fract} -> [2];
                print "\n";
            } elsif ( $property eq "shift_vector" ) {
                print "Shift vector: " .
                    "$atom_ref->{shift_vector} \n";
            } elsif ( $property eq  "sym_operator" ) {
                print "Symmetry operator: " . 
                      "$atom_ref->{sym_operator} \n";
            }
        }
    }
}

##
# Prints distances between atoms in the default format, defined in
# cod-tools/trunk/perl-scripts/cif-distances/cif-distances_matrix_v.1
# @param $distance_ref
#       Reference to an array distances between atoms.
# @param $header_ref;
#       Reference to an array of strings containing information about 
#       atoms that were used in the calculation of distances.
# @param $fraction_precision
#       Number of fraction digits of the distances that should be printed.
# @param $line_length
#       Length of the matrix line in symbols.
##

sub print_distance_matrix {
    my ( $distance_ref, $header_ref, $format, $line_length ) = @_;
    my @distances = @$distance_ref;
    my $cell_width;
    if ( $format =~ /^%\D*(\d+)\D/ ) {
        $cell_width = $1;
    } else {
        $cell_width = 11;
    }
    use POSIX;
    my $cell_count = floor ( $line_length / $cell_width ) - 1;

    my $print_iteration = 0;
    while ( $print_iteration < ceil( @distances / $cell_count ) ) {
        my $start_cell_index = $cell_count * $print_iteration;
        my $finish_cell_index = $cell_count * ( $print_iteration + 1 );
        if ( $finish_cell_index > @distances ) {
            $finish_cell_index = @distances;
        }
        
        printf( "%-${cell_width}s", "ATOMS" );
        for ( my $k = $start_cell_index; $k < $finish_cell_index; $k++ ) {
            printf( "%-${cell_width}s", @$header_ref[ $k ] );
        }
        print "\n";
        
        for ( my $i = 0; $i < @distances; $i++ ) {
            printf( "%-${cell_width}s", @$header_ref[ $i ] );
            for ( my $j = $start_cell_index; $j < $finish_cell_index; $j++ ) {
                if ( $i == $j ) {
                    printf( $format, 0 )
                } elsif ( $j > $i ) {
                    printf( $format, $distances[ $i ][ $j - $i ] );
                } else {
                    printf( $format, $distances[ $j ][ $i - $j ] );
                }
            };
            print "\n";
        }
        
        print "\n";
        $print_iteration++;
    }
}

##
# Prints distances between atoms in an alternative format, defined in
# cod-tools/trunk/perl-scripts/cif-distances/cif-distances_paired_v.1
# @param $distances
#       Reference to an array distances between atoms.
# @param $atoms_used
#       Reference to an array of atoms that were used in the calculation
#       of the distances.
##

sub print_pairwise {
    my ( $distances, $atoms_used, $filename, $print_filename ) = @_;
    
    for ( my $i = 0; $i < @$atoms_used; $i++ ) {
        my $atom_1 = @$atoms_used[ $i ] -> [ 0 ];

        for ( my $j = 1; $j < @{ @$atoms_used[ $i ] }; $j++ ) {
            my $atom_2 = @$atoms_used[ $i ] -> [ $j ];
            
            if ( @$distances[ $i ] -> [ $j ] eq "-" ) {
                printf( 'DIST %-6s', "-" );
            } else {
                printf( 'DIST %-6.3f', @$distances[ $i ] -> [ $j ] );
            }

            printf( ' %10s %10s %24s %8s ',  
                    $atom_1 -> { label }."/".$atom_1 -> { chemical_type },
                    $atom_2 -> { label }."/".$atom_2 -> { chemical_type },
                    $atom_2 -> { sym_operator },
                    $atom_2 -> { shift_vector },
                    );

            if ( $print_filename ) {
                print basename( $filename );
            }
            print "\n";
        }
    }
}
