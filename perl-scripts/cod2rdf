#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Describe (in RDF format) properties of COD structures.
#**

use strict;
use warnings;

use DBI;
use Encode;
use HTML::Entities;
use SOptions;

my $vocabulary_name = "cod";
my $vocabulary_url_prefix = "http://www.crystallography.net/cod/doc/rdf/";
my $url_prefix  = "http://www.crystallography.net/cod/";
my $url_postfix = ".html";
my $refering_db_name = "cod";

my $split_author_names = 1;
my $output_format = "xml";
my $replace_utf_code_points_from;

my %database = (
    host  => "www.crystallography.net",
    user  => "cod_reader",
    name  => "cod",
    password => "",
    platform => "mysql",
    definition_table => "databases",
);

@ARGV = getOptions(
    "-d,--database"  => \$database{name},
    "-l,--localhost" => sub { $database{host} = 'localhost' },
    "-h,--host"      => \$database{host},
    "-p,--port"      => \$database{port},
    "-s,--server"    => \$database{host},
    "-u,--user"      => \$database{user},
    "--password"     => \$database{password},
    "--platform"     => \$database{platform},

    "--vocabulary-name" => \$vocabulary_name,
    "--vocabulary-url-prefix" => \$vocabulary_url_prefix,
    "--prefix,--db-url-prefix"   => \$url_prefix,
    "--postfix,--db-url-postfix" => \$url_postfix,
    "--def-table,--definition-table" => \$database{definition_table},
    "--db-name,--database-name" => \$refering_db_name,

    "--split-author-names" => sub { $split_author_names = 1 },
    "--no-split-author-names" => sub { $split_author_names = 0 },
    "--dont-split-author-names" => sub { $split_author_names = 0 },

    "--xml-output"     => sub { $output_format = "xml" },
    "--n3-output"       => sub { $output_format = "n3" },
    "--turtle-output"   => sub { $output_format = "turtle"},

    "--replace-utf-codepoints-from" => \$replace_utf_code_points_from,
    "--no-replace-utf-codepoints" =>
        sub { $replace_utf_code_points_from = undef },
    "--dont-replace-utf-code-points" =>
        sub { $replace_utf_code_points_from = undef },
);

binmode( STDOUT, ":utf8" );

my $dbh = db_connect( $database{platform},
                      $database{host},
                      $database{name},
                      $database{port},
                      $database{user},
                      $database{password} );
die "connection to database failed" if !$dbh;

my $data = $dbh->selectall_arrayref(
                "SELECT * FROM data " .
                "WHERE file IN (" . join( ", ", @ARGV ) . ")",
                { Slice => {} }
           );

$data = { map { $_->{file} => $_ } @$data };

my $any_data_seen = 0;
for my $codid (@ARGV) {
    if( !exists $data->{$codid} ) {
        print STDERR "$0: structure $codid can not be found " .
                     "in the COD database\n";
    } else {
        $any_data_seen = 1;
        last;
    }
}
die "no data for RDF was found in the database" if !$any_data_seen;

for my $entry (values %$data) {
    delete $entry->{text};
    delete $entry->{flags};
}

my $databases = $dbh->selectall_arrayref(
    "SELECT name, url_prefix, url_postfix " .
    "FROM `$database{definition_table}`",
    { Slice => {} }
);

my %databases = map{ lc($_->{name}) => { url_prefix => $_->{url_prefix},
                                         url_postfix => $_->{url_postfix} } }
                     @$databases;

my $ids = join( ", ", @ARGV );
my %vocabularies = ( $vocabulary_name => $vocabulary_url_prefix );

for my $database (keys %databases) {
    my $table = $database . "_x_" . $refering_db_name;
    my $db_data = $dbh->selectall_arrayref( <<"SQLEND"
        SELECT ${refering_db_name}_id AS db_id,
               ext_id,
               relation,
               vocabulary,
               rdf_relations.uri_prefix AS vocabulary_uri_prefix
        FROM `$table`
        JOIN rdf_relations
            ON relation_id = rdf_relations.id
        WHERE ${refering_db_name}_id IN ($ids)
SQLEND
        , { Slice => {} }
    );

    for my $entry (@$db_data) {
        my $db_id = $entry->{db_id};
        $vocabularies{$entry->{vocabulary}} =
            $entry->{vocabulary_uri_prefix};
        $data->{$db_id}{links} = [] unless exists $data->{$db_id}{links};
        push( @{$data->{$db_id}{links}},
            {
                db => $database,
                ext_id => $entry->{ext_id},
                relation => $entry->{relation},
                vocabulary => $entry->{vocabulary},
            } );
    }
}

if ($output_format eq "xml") {
    print "<?xml version=\"1.0\"?>\n";
    print "<rdf:RDF xmlns:rdf=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"";
    print "\n" if keys %vocabularies > 0;
    print join( "\n", map( " " x 9 . "xmlns:$_=\"$vocabularies{$_}\"",
                           sort keys %vocabularies ) ) . ">\n";

    foreach my $codid (sort keys %$data) {
        my $struct = $data->{$codid};
        print "  <rdf:Description rdf:about=\"${url_prefix}" .
            $struct->{file} . "${url_postfix}\">\n";

        for my $prop (@{$struct->{links}}) {
            my $db = $prop->{db};
            print "    <" . $prop->{vocabulary} . ":" . $prop->{relation} . "\n";
            print "     rdf:resource=\"" .
                $databases{$db}->{url_prefix} . $prop->{ext_id} .
                $databases{$db}->{url_postfix} . "\" />\n";
        }

        for my $field (sort keys %$struct) {
            next if $field eq 'file' || $field eq 'links';
            next if !$struct->{$field};
            $struct->{$field} = decode( 'UTF-8', $struct->{$field} );
            $struct->{$field} = encode_entities( $struct->{$field},
                                                 "\"'<>\&" );
            if( $field eq 'formula' || $field eq 'calcformula' ) {
                $struct->{$field} =~ s/^-\s*//;
                $struct->{$field} =~ s/\s*-$//;
            }
            if( $field ne 'authors' || !$split_author_names ) {
                if( defined $replace_utf_code_points_from ) {
                    $struct->{$field} =
                        replace_utf_codepoints( $struct->{$field},
                                                $replace_utf_code_points_from );
                }
                print "    <${vocabulary_name}:$field>";
                print $struct->{$field};
                print "</${vocabulary_name}:$field>\n";
            } else {
                print join( "\n",
                            map( "    <${vocabulary_name}:author>" .
                                 ( defined $replace_utf_code_points_from
                                     ? replace_utf_codepoints( $_,
                                               $replace_utf_code_points_from )
                                     : $_ ) .
                                 "</${vocabulary_name}:author>",
                                 split( /\s*;\s*/, $struct->{$field} ) ) );
                print "\n";
            }
        }
        print "  </rdf:Description>\n";
    }
    print "</rdf:RDF>\n";    
} elsif ($output_format eq "n3") {
    die "output in N3 format is not implemented yet";
    # n3 implementation code
} elsif ($output_format eq "turtle") {
    die "output in turtle format is not implemented yet";
    # turtle implementation code
}

sub replace_utf_codepoints
{
    my( $string, $from ) = @_;
    my $hex = sprintf( "%x", $from );
    $string =~
        s/([\x{$hex}-\x{7FFFFFFF}])/sprintf("&#x%04X;", ord($1))/eg;
    return $string;
}

# Function used to connect to database
sub db_connect
{
    my ($db_platform, $db_host, $db_name, $db_port, $db_user, $db_pass) = @_;
    my $dsn = "dbi:$db_platform:" .
              "hostname=$db_host;".
              "dbname=$db_name".
              ($db_port ? ";$db_port" : "");
    my $dbh = DBI->connect( $dsn, $db_user, $db_pass );
    if( !$dbh ) {
        die( "could not connect to the database - " . lcfirst( $DBI::errstr ));
    }
    if( $db_platform ne 'SQLite' ) {
        $dbh->do( "SET CHARACTER SET utf8" );
        $dbh->do( 'set @@character_set_client = utf8' );
        $dbh->do( 'set @@character_set_connection = utf8' );
        $dbh->do( 'set @@character_set_server = utf8' );
        $dbh->do( 'set @@character_set_database = utf8' );
    }
    return $dbh;
}
