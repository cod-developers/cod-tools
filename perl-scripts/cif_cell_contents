#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Generate symetric atoms
#**

use strict;
use lib "./lib/perl5";
use lib "./CIFParser";
use lib "./Spacegroups";
use CIFParser;
use CIFTagCanonicalNames;
use ShowStruct;
use Serialise;
use SymopParse;
use SymopLookup;
use Fractional;
use File::Basename;

sub print_error($$$$$)
{
    my ( $program, $filename, $datablock, $errlevel, $message ) = @_;

    print STDERR $program, ": ", $filename,
    defined $datablock ? " data_" . $datablock : "",
    defined $errlevel ? ": " . $errlevel : "",
    ": ", $message, ".\n";
}

sub error($$$$)
{
    my ( $program, $filename, $datablock, $message ) = @_;
    print_error( $program, $filename, $datablock, "ERROR", $message );
}

sub warning($$$$)
{
    my ( $program, $filename, $datablock, $message ) = @_;
    print_error( $program, $filename, $datablock, "WARNING", $message );
}

my $Id = '$Id$';

my $filename = shift(@ARGV);

my $parser = new CIFParser;

my $data = $parser->Run($filename);

sub get_cell($$$);
sub get_symmetry_operators($$);

for my $dataset (@$data) {

    canonicalize_names( $dataset );

    my $values = $dataset->{values};

#   extracts atom site label or atom site type symbol
    my $loop_tag;

    if( exists $values->{"_atom_site_label"} ) {
        $loop_tag = "_atom_site_label";
    } elsif( exists $values->{"_atom_site_type_symbol"} ) {
        $loop_tag = "_atom_site_type_symbol";
    } else {
        error( $0, $filename, $dataset->{name},
	       "neither _atom_site_label " .
	       "nor _atom_site_type_symbol was found in the input file" );
        next;
    }

#   extracts cell constants

    my @unit_cell = get_cell( $values, $filename, $dataset->{name} );
    my $ortho_matrix = symop_ortho_from_fract( @unit_cell );

#   extracts symmetry operators
    my $sym_data = get_symmetry_operators( $dataset, $filename );

#   extract atoms
    my $atoms = get_atoms( $dataset, $filename, $loop_tag );

#   compute symmetry operator matrices
    my @sym_operators = map { symop_from_string($_) } @{$sym_data};


    serialiseRef( $atoms );
}

#===============================================================#
sub symop_apply
{
    my($atom_xyz, $symop) = @_;
    my @new_atom_xyz;

    for(my $i = 0; $i < @{$symop}; $i++)
    {
	$new_atom_xyz[$i] = 0;
	for(my $j = 0; $j < @{$symop}; $j++)
	{
	    ${$atom_xyz}[$j] =~ s/\(\d+\)$//;
	    $new_atom_xyz[$i] += ${$atom_xyz}[$j] * ${$symop}[$i][$j];
	}
	$new_atom_xyz[$i] = modulo_1($new_atom_xyz[$i]);
    }
    
    return \@new_atom_xyz;
}

#===============================================================#
# @SymopLookup::table =
# (
# {
#     number          => 1,
#     hall            => ' P 1',
#     schoenflies     => 'C1^1',
#     hermann_mauguin => 'P 1',
#     universal_h_m   => 'P 1',
#     symops => [
#         'x,y,z',
#     ],
#     ncsym => [
#         'x,y,z',
#     ]
# },
# );

sub lookup_symops
{
    my ($option, $param) = @_;

    $param =~ s/ //g;
    $param =~ s/_//g;

    foreach my $hash (@SymopLookup::table)
    {
        my $value = $hash->{$option};
        $value =~ s/ //g;
        $value =~ s/_//g;

        if($value eq $param)
        {
            return $hash->{symops};
        }
    }
    return 0;
}

#===============================================================#
# Extract unit cell angles and lengths.

# Accepts
#     values - a hash where a data from the CIF file is stored
# Returns
#     cell_lengths_and_angles - an array  with stored information.

sub get_cell($$$)
{
    my( $values, $filename, $dataname ) = @_;

    my @cell_lengths_and_angles;

    for my $cif_tag (qw(_cell_length_a
                        _cell_length_b
                        _cell_length_c
                        ))
    {
        if( exists $values->{$cif_tag} ) {
	    push(@cell_lengths_and_angles, $values->{$cif_tag}[0]);
	    $cell_lengths_and_angles[-1] =~ s/\(\d+\)$//;
        } else {
            error( $0, $filename, $dataname,
		   "cell angle '$cif_tag' not present" );
	}
    }

    for my $cif_tag (qw(_cell_angle_alpha
                        _cell_angle_beta
                        _cell_angle_gamma
                        ))
    {
        if( exists $values->{$cif_tag} ) {
            push( @cell_lengths_and_angles, $values->{$cif_tag}[0] );
            $cell_lengths_and_angles[-1] =~ s/\(\d+\)$//;
        } else {
            warning( $0, $filename, $dataname,
                     "cell angle '$cif_tag' not present -- " .
                     "taking default value 90 degress." );
            push( @cell_lengths_and_angles, 90 );
        }
    }

    return @cell_lengths_and_angles;
}

sub get_symmetry_operators($$)
{
    my ( $dataset, $filename ) = @_;

    my $values = $dataset->{values};

    my $sym_data;

    if( exists $values->{"_symmetry_equiv_pos_as_xyz"}) {
        $sym_data = $values->{"_symmetry_equiv_pos_as_xyz"};
    }

    if( exists $values->{"_symmetry_space_group_name_Hall"} &&
	not defined $sym_data ) {
        my $hall = $values->{"_symmetry_space_group_name_Hall"}[0];
        $sym_data = lookup_symops("hall", $hall);

        if( !$sym_data ) {
            error( $0, $filename, $dataset->{name},
		   "_symmetry_space_group_name_Hall value '$hall' is " .
		   "not recognised" );
        } 
    }

    if( exists $values->{"_symmetry_space_group_name_H-M"} &&
       ( not defined $sym_data or $sym_data == 0 )) {
        my $h_m = $values->{"_symmetry_space_group_name_H-M"}[0];
        $sym_data = lookup_symops("hermann_mauguin", $h_m);

        if( !$sym_data ) {
            error( $0, $filename, $dataset->{name},
		   "_symmetry_space_group_name_H-M value '$h_m' is " .
		   "not recognised" );
            die;
        }
    }

    if( not defined $sym_data ) {
        error( $0, $filename, $dataset->{name},
	       "neither _symmetry_equiv_pos_as_xyz " .
	       "nor _symmetry_space_group_name_Hall " .                  
	       "nor _symmetry_space_group_name_H-M could be processed" );
        die;
    }

    return $sym_data;
}

#===============================================================#
# Multiplies an ortho matrix with a vector.

# my $ortho = [
#     [ o11 o12 o13 ]
#     [ 0   o22 o23 ]
#     [ 0   0   o33 ]
# ]
#

sub mat_vect_mul
{
    my($matrix, $vector) = @_;

    my @new_coordinates;

    for(my $i = 0; $i < @{$vector}; $i++)
    {
        $new_coordinates[$i] = 0;
        for(my $j = 0; $j < @{$vector}; $j++)
        {
            $new_coordinates[$i] += ${$matrix}[$i][$j] * ${$vector}[$j];
        }
    }

    return \@new_coordinates;
}

sub get_atoms
{
    my ( $dataset, $filename, $loop_tag ) = @_;

    my $values = $dataset->{values};

    my @unit_cell = get_cell( $values, $filename, $dataset->{name} );
    my $ortho_matrix = symop_ortho_from_fract( @unit_cell );

    my @atoms;

    for my $i ( 0 .. $#{$values->{$loop_tag}} ) {
	my $atom = {
	    atom_name => $values->{$loop_tag}[$i],
	    atom_type => exists $values->{_atom_site_type_symbol} ?
		$values->{_atom_site_type_symbol}[$i] : undef,
	    coordinates_fract => [
		$values->{_atom_site_fract_x}[$i],
		$values->{_atom_site_fract_y}[$i],
		$values->{_atom_site_fract_z}[$i]
	    ],
	};

	@{$atom->{coordinates_fract}} = map { s/\(\d+\)\s*$//; $_ }
	    @{$atom->{coordinates_fract}};

	$atom->{coordinates_ortho} =
	    mat_vect_mul( $ortho_matrix, $atom->{coordinates_fract} );

	if( defined $values->{_atom_site_occupancy} &&
	    $values->{_atom_site_occupancy}[$i] ne '?' ) {
	    $atom->{occupancy} = $values->{_atom_site_occupancy}[$i];
	}

	if( defined $values->{_atom_site_symmetry_multiplicity} &&
	    $values->{_atom_site_symmetry_multiplicity}[$i] ne '?' ) {
	    $atom->{cif_multiplicity} =
		$values->{_atom_site_symmetry_multiplicity}[$i];
	}

	push( @atoms, $atom );
    }

    return \@atoms;
}
