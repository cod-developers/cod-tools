#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;

#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Parse CIF file(s) and CIF dictionary(ies).
#  Check CIF file against CIF dictionaries.
#**

#
# here we link libraries
#
use strict;
use warnings;
use Scalar::Util;
use lib "./lib/perl5";
use lib "./CIFParser";
use CIFParser;
use CIFTagCanonicalNames;
use ShowStruct;
use SOptions;

#
# here we define variables
#	first - constant values
#	then  - common variables
#
my $version = 0.1;

my $CIFfile = ();
my $CIFtags;
my $outputFile;
my $dictFiles = [];
my $setOfEnum = [];
my $dictFilesParsed = [];
my $dictTags = {};
my $quiet = 0;
my $errorLevel = 2;
my $parser = new CIFParser;
#
# We read user requested options into an array-ref in this case user can 
# define '--check' many times with different or same options, that are 
# parsed later.
#
my $outputOptions = [];
#
# Errors reporting and CIF validation is performed according to this 
# hash entries.
# All possible options MUST be listed here, because no checking whereas 
# option exists will be made (it MUST be NOT necessary).
# NOTE: please update 'HelpMessage' subroutine when adding new option, 
# so that user would know what options are possible.
# TODO: 'errorLevel' and 'quiet' options must be removed later in 
# accordance to this option. Some 'debug' option might be created, to 
# report more information than it is necessary to understand validation 
# errors.
#
my %showMap = (
        #
        # some private tags
        '_debug'             => 1,
        #
        # tag name checking related options
        'tag-exists'         => 1,
        'tag-exists-local'   => 0,
        'tag-deprecated'     => 0,
        #
        # loop_ checking related options
        'tags-grouped'       => 0,
        'list-mandatory'     => 1,
        'ref-list-mandatory' => 1,
        #
        # value checking related options
        'values-enum'        => 1,
        'values-enum-nocase' => 0,
        'value-type'         => 1,
        'values-range'       => 1
    );

#
# here we declare subroutines
#

# subroutine to print module version and copyright notice
sub VersionMessage;

# subroutine to print help on module usage
sub HelpMessage;

# subroutine to print validation message (for SPOT purposes)
# list of arguments:
#     1. severity level (# ../doc/error-levels.txt)
#     2. CIF file analysed
#     3. CIF data block analysed
#     4. error message experienced
sub showValidationMessage;

# subroutine to extract tags from dictionary (parsed using CIFParser)
# it takes reference to CIFParser output
# returns hash of tags and related references to parsed data blocks
sub getDict;

# subroutine to check value against range (defined in dictionary)
# Arguments:
#   1. type of value (numb or char);
#   2. reference to range as $$range{min} and $$range{max};
#   3. value, that must be checked.
sub checkAgainstRange;

# subroutine to check number value against range (defined in dictionary)
# Arguments:
#   1. reference to range as $$range{min} and $$range{max};
#   2. value, that must be checked.
sub checkAgainstRangeNumb;

# subroutine to check character value against range (defined in dictionary)
# Arguments:
#   1. reference to range as $$range{min} and $$range{max};
#   2. value, that must be checked.
sub checkAgainstRangeChar;

# subroutine to return name of closest (according to dictionary) 
#     mandatory tag, if applicable. Return undef, if no mandatory tag is 
#     related to tag analysed
# Arguments:
#   1. reference to dictionary
#   2. lowercased name of currently analysed tag
sub getRelatedMandatory;

#
# main program code
#

# Treat '_atom_site_refinement_flags' by default, as it is so documented 
# in CIF core dictionary.
push @$setOfEnum, '_atom_site_refinement_flags';

# check parameters passed
@ARGV = getOptions(
        "--output"
            => \$outputFile,
        "--dictionary"
            => $dictFiles,
        "--set-of-enum"
            => $setOfEnum,
        "--no-set-emulation"
            => sub{ $setOfEnum = [] },
        "--version"
            => sub{ VersionMessage() },
        "--quiet"
            => sub{ $errorLevel *= 2; },
        "--no-quiet"
            => sub{ $errorLevel /= 2; },
        "--error-level"
            => \$errorLevel,
        "--help"
            => sub{ HelpMessage() },
        "--check"
            => $outputOptions,
        "--show"
            => $outputOptions,
        # turn on check options
        "--check-all"
            => sub{ while ( my($k,$v) = each(%showMap) ) {
                        $showMap{$k} = 1;
                    }
                  },
        "--check-tag-exists"         => sub{ $showMap{'tag-exists'} = 1 },
        "--check-tag-exists-local"   => sub{ $showMap{'tag-exists-local'} = 1 },
        "--check-tag-deprecated"     => sub{ $showMap{'tag-deprecated'} = 1 },
        "--check-tags-grouped"       => sub{ $showMap{'tags-grouped'} = 1 },
        "--check-list-mandatory"     => sub{ $showMap{'list-mandatory'} = 1 },
        "--check-ref-list-mandatory" => sub{ $showMap{'ref-list-mandatory'} = 1 },
        "--check-values-enum"        => sub{ $showMap{'values-enum'} = 1 },
        "--check-values-enum-nocase" => sub{ $showMap{'values-enum'} = 1; $showMap{'values-enum-nocase'} = 1 },
        "--check-values-range"       => sub{ $showMap{'values-range'} = 1 },
        "--check-value-type"         => sub{ $showMap{'values-enum'} = 1; $showMap{'value-type'} = 1 },
        # turn off check options
        "--check-none"
            => sub{ while ( my($k,$v) = each(%showMap) ) {
                        $showMap{$k} = 0;
                    }
                  },
        "--do-not-check-tag-exists"         => sub{ $showMap{'tag-exists'} = 0 },
        "--do-not-check-tag-exists-local"   => sub{ $showMap{'tag-exists-local'} = 0 },
        "--do-not-check-tag-deprecated"     => sub{ $showMap{'tag-deprecated'} = 0 },
        "--do-not-check-tags-grouped"       => sub{ $showMap{'tags-grouped'} = 0 },
        "--do-not-check-list-mandatory"     => sub{ $showMap{'list-mandatory'} = 0 },
        "--do-not-check-ref-list-mandatory" => sub{ $showMap{'ref-list-mandatory'} = 0 },
        "--do-not-check-values-enum"        => sub{ $showMap{'values-enum'} = 0 },
        "--do-not-check-values-enum-nocase" => sub{ $showMap{'values-enum'} = 0 },
        "--do-not-check-values-range"       => sub{ $showMap{'values-range'} = 0 },
        "--do-not-check-value-type"         => sub{ $showMap{'value-type'} = 0 }
    );

if( defined($outputFile) ) {
    open( STDOUT, "> $outputFile" ) || die('Unable to open '
                        . $outputFile . ' for writing: ' . $! . '.');
}

for( @{$outputOptions} ) {
    my @options = split /,/;
    ITERATEOPTIONS: for( @options ) {
        m/^
            (
                [a-z\-_]* # option itself MUST be letters-only
                [a-z]
            )
            (
                [\-+]? # the option might be preceeded by '+' or '-' sign
                # the later meaning, that we do NOT want this to be printed
            )
        $/six;
        if( !defined $1 ) {
            print STDERR $0. ': Output option "' . $_ . '" is not'
                    . ' valid.'
                    . ' Options MUST contain only letters,'
                    . ' underscore "_" and minus "-" signs.' . "\n";
            next ITERATEOPTIONS;
        }
        my $opt = lc( $1 );
        if( !exists $showMap{$opt}
            && $opt ne 'all' ) {
            print STDERR $0. ': Output option '
                    . "'" . $1 . "'"
                    . ' is not '
                    . 'known. '
                    . 'Options should be one of these: ['
                    . join(', ', keys(%showMap))
                    . '].'
                    . "\n";
            next ITERATEOPTIONS;
        }
        if( $opt eq 'all' ) {
            my $setTo = 0;
            $setTo = 1 unless $2 eq '-';
            while ( my($k,$v) = each(%showMap) ) {
                $showMap{$k} = $setTo;
            }
            last ITERATEOPTIONS;
        }
        if( $2 eq '-' ) {
            $showMap{$opt} = 0;
        } else {
            $showMap{$opt} = 1;
        }
    }
}

my $anyTestIsTurnedOn = 0;
while( my($k, $v) = each %showMap ) {
    $anyTestIsTurnedOn = 1 if $v;
}
if( !$anyTestIsTurnedOn ) {
    print STDERR $0. ': No test is chosen to be performed. Exiting.'
        . "\n";
    exit( 0 );
}
undef $anyTestIsTurnedOn;

if( @$dictFiles )
{
    DICTFILE: for( @{$dictFiles} ) {
        my $parsed = $parser->Run( $_ );
        next DICTFILE if $parsed == 1;
        push( @$dictFilesParsed, $parsed );
        $$dictTags{$_} = getDict( $parsed );
        undef $parsed;
    }
    if( keys( %$dictTags ) == 0 ) {
        print STDERR $0 . ': '
                . join( ",", @$dictFiles )
                . ': No tags were defined in dictionaries.'
                . "\n";
        exit 1;
    }
} else {
    die "You must specify dictionary using '--dictionary'. Automatic "
            . "dictionary download is not implemeted yet.\n";
    my $dictIUCRURI = "ftp://ftp.iucr.org/pub/cif_core.dic";
}

# parse CIF files. If none is passed - display help message
if( !@ARGV ) {
	HelpMessage();
	exit( 1 );
}

for( @ARGV ) {
    push( @{$CIFfile}, $_ );
}

#
# start-iterate-trough-CIF-files
#    
CIFFILEANAL: for my $cifF ( @{$CIFfile} ) {
    my $data = $parser->Run( $cifF );
    # convert all tags to a "cannonical" form (the one used in the
    # CIFTags modules ;):
    canonicalize_all_names( $data );
    next CIFFILEANAL if ( !defined $data || $data == 1 );
    #
    # start-iterate-trough-CIF-file-data-blocks
    #    
    for my $block ( @$data ) {
        if( $quiet == 0 ) {
            showValidationMessage 64, '_debug', $cifF, $$block{name}, 
                    'analysis start';
        }
        #
        # hash tagsListedInLoops
        # If a tag (key is lowercased tag name) appears in this hash it 
        # means, that it must appear within loop.
        # Value is enum('yes', 'no'). Depending on this we know, whereas 
        # tag was correctly (i.e. together with other tags) defined 
        # within some loop.
        #
        my %tagsListedInLoops;
        #
        # hash baseNamesOfRefTags
        # A tag listed in this hash depends on some other loop_ tag, and
        # is correctly referenced (parent tag is defined within same 
        # loop). Value is enum('yes', 'no').
        #
        my %baseNamesOfRefTags;
        #
        # start-iterate-trough-CIF-values
        #
        for my $tagAnalysed ( @{$block->{tags}} ) {
            if(!defined $block->{types}{$tagAnalysed}) {
                showValidationMessage 64, '_debug',
                    $cifF, $$block{name},
                    "tag '" . $tagAnalysed . "' has no associated type"
                    . ' which, probably, means that error in CIFParser occured';
            }
            my $lc_tagAnalysed = lc $tagAnalysed;
            my $defined = 0;
            if( $showMap{'tag-exists-local'} == 0
                && $lc_tagAnalysed =~ m/^_\[local\]/ ) {
                ++$defined;
            }
            my $correctDataType = 0;
            #
            # start-iterate-through-dictionaries
            #
            while( my($dictF, $dictD) = each %$dictTags ) {
                #
                # if check tags
                #
                if( $showMap{'tag-exists'} ) {
                    if( exists $$dictD{$lc_tagAnalysed} ) {
                        $defined++;
                        showValidationMessage 64, 'tag-exists', $cifF, 
                            $$block{name}, "tag '" . $tagAnalysed . "'"
                            . ' do exist in dictionary ' . $dictF;
                    } else {
                        showValidationMessage 16, 'tag-exists', $cifF, 
                            $$block{name}, "tag '" . $tagAnalysed . "'"
                            . ' does not exist in dictionary ' . $dictF;
                    }
                }
                # end-if check tags
                
                #
                # if check tags deprecation (replacements)
                #
                if( $showMap{'tag-deprecated'} ) {
                    if(exists $dictD->{$lc_tagAnalysed}{values}{_related_item}) {
                        my $replaceWith = [];
                        for( my $i = 0;
                            $i < @{$dictD->{$lc_tagAnalysed}{values}{_related_item}};
                            $i++ )
                            {
                            if($dictD->{$lc_tagAnalysed}{values}{_related_function}[$i]
                                eq 'replace') {
                                push @{$replaceWith},
                                    $dictD->{$lc_tagAnalysed}{values}{_related_item}[$i];
                            }
                        }
                        if( @$replaceWith != 0 ) {
                            showValidationMessage 8, 'tag-deprecated',
                                $cifF, $$block{name},
                                "tag '" . $tagAnalysed . "' has been"
                                . ' replaced by tag(-s): ['
                                . join(', ', @$replaceWith)
                                . '] according to ' . $dictF;
                        }
                    }
                }
                # end-if check tags deprecation (replacements)
                
                # -----------------------------------------------------
                # -----------------------------------------------------
                # -----------------------------------------------------
                
                #
                # if check referenced list mandatory
                #
                if( $showMap{'ref-list-mandatory'} ) {
                    my $mandatoryRTag = getRelatedMandatory($dictD, 
                                                     $lc_tagAnalysed);
                    if( defined $mandatoryRTag
                        && !exists($baseNamesOfRefTags{$mandatoryRTag})
                        ) {
                        for my $loopAnalysed ( @{$block->{loops}} ) {
                            if( grep $_ eq $tagAnalysed, @{$loopAnalysed} ) {
                                if( grep lc($_) eq $mandatoryRTag, @{$loopAnalysed} ) {
                                    showValidationMessage 64,
                                        'ref-list-mandatory', $cifF,
                                        $$block{name},
                                        "tag '" . $mandatoryRTag
                                        . "' is mandatory in loop when"
                                        . ' tag(s) ['
                                        . join(', ', 
                                        @{$dictD->{$lc_tagAnalysed}{values}{_name}})
                                        . '] are defined'
                                        . ' according to ' . $dictF
                                        . ' and was found';
                                    $baseNamesOfRefTags{$mandatoryRTag} = 'yes';
                                    last;
                                } else {
                                    showValidationMessage 2,
                                        'ref-list-mandatory', $cifF,
                                        $$block{name},
                                        "tag '" . $mandatoryRTag
                                        . "' is mandatory in loop when"
                                        . ' tag(s) ['
                                        . join(', ', 
                                        @{$dictD->{$lc_tagAnalysed}{values}{_name}})
                                        . '] are defined'
                                        . ' according to ' . $dictF
                                        . ' but was not found';
                                    $baseNamesOfRefTags{$mandatoryRTag} = 'no';
                                    last;
                                }
                            }
                        }
                    }
                }
                # end-if check referenced list mandatory
                

                #
                # if group of tags must be presented within same loop
                #
                if( $showMap{'tags-grouped'} ) {
                    if( defined $dictD->{$lc_tagAnalysed}{values}{_name}
                        && defined $dictD->{$lc_tagAnalysed}{values}{_list}
                        && !defined $tagsListedInLoops{$lc_tagAnalysed}
                        && @{$dictD->{$lc_tagAnalysed}{values}{_name}} > 1
                        && $dictD->{$lc_tagAnalysed}{values}{_list}[0] eq 'yes' ) {
                        my $countItems = 
                            @{$dictD->{$lc_tagAnalysed}{values}{_name}};
                        my $allTagsFound = 0;
                        #
                        # iterate through loops array from CIFfile, 
                        # current data block.
                        # NOTE: $loopAnalysed is an array-ref
                        #
                        for my $loopAnalysed ( @{$block->{loops}} ) {
                            my @found;
                            my @notFound;
                            #
                            # iterate through tags list, that there
                            # marked as mandatory if at least one is
                            # defined.
                            # NOTE: $mandatoryTag is a scalar
                            #
                            for my $mandatoryTag ( 
                                @{$dictD->{$lc_tagAnalysed}{values}{_name}}
                            ) {
                                if( grep lc($_) eq $mandatoryTag, @{$loopAnalysed} ) {
                                    push @found, $mandatoryTag;
                                    $tagsListedInLoops{lc $mandatoryTag} = 'yes';
                                } else {
                                    push @notFound, lc($mandatoryTag);
                                }
                            }
                            if( @found > 0 ) {
                                if( @found == $countItems ) {
                                   $allTagsFound = 1;
                                    showValidationMessage 64, 
                                        'tags-grouped', $cifF,
                                        $$block{name},
                                        'tags ['
                                        . join(', ', 
                                            @{$dictD->{$lc_tagAnalysed}{values}{_name}})
                                        . '] must be in loop according'
                                       . ' to ' .$dictF
                                       . ' and were found'
                                        . ' within loop';
                                } else {
                                    for( @notFound ) {
                                        $tagsListedInLoops{$_} = 'no';
                                    }
                                    showValidationMessage 2, 
                                        'tags-grouped', $cifF,
                                        $$block{name},
                                        'tags ['
                                        . join(', ', 
                                            @{$dictD->{$lc_tagAnalysed}{values}{_name}})
                                        . '] must be in loop according'
                                        . ' to '
                                        . $dictF . ' but only ['
                                        . join(', ', @found)
                                        . '] were found';
                                }
                            }
                        }
                    }
                }
                # end-if group of tags must be presented within same loop
                
                #
                # if check list mandatory
                #
                if( $showMap{'list-mandatory'} ) {
                    if( exists $dictD->{$lc_tagAnalysed}{values}{_list_mandatory}
                        && $dictD->{$lc_tagAnalysed}{values}{_list_mandatory}[0]
                            eq 'yes' )
                        {
                        if( exists $block->{inloop}{$tagAnalysed} ) {
                            showValidationMessage 64, 'list-mandatory', 
                                $cifF, $$block{name},
                                "tag '" . $tagAnalysed . "' is loop"
                                . ' mandatory according to ' . $dictF
                                . ' and is in loop';
                        } else {
                            showValidationMessage 2, 'list-mandatory', 
                                $cifF, $$block{name},
                                "tag '" . $tagAnalysed . "' is loop"
                                . ' mandatory according to ' . $dictF
                                . ' but is not in loop';
                        }
                    }
                }
                # end-if check list mandatory
                
                # -----------------------------------------------------
                # -----------------------------------------------------
                # -----------------------------------------------------
                
                #
                # if check types of values
                #
                if( $showMap{'values-enum'} == 1
                    || $showMap{'values-range'} == 1 ) {
                my $range = {};
                my %rangeForPrint;
                if( exists $dictD->{$lc_tagAnalysed}{values}{_enumeration_range} ) {
                    ($$range{min}, $$range{max}) = split(/:/, 
                        $dictD->{$lc_tagAnalysed}{values}{_enumeration_range}[0],
                        2);
                    %rangeForPrint = %$range;
                    if( length($$range{min}) == 0 ) {
                        delete $$range{min};
                        $rangeForPrint{min} = '<any>';
                    }
                    if( length($$range{max}) == 0 ) {
                        delete $$range{max};
                        $rangeForPrint{max} = '<any>';
                    }
                }
                CIFVALUE: for my $tagIndex ( 0..$#{$block->{values}{$tagAnalysed}} ) {
                    my $tagValue = $block->{values}{$tagAnalysed}[$tagIndex];
                    next CIFVALUE if $tagValue eq '.' or $tagValue eq '?';
                    my $value = $tagValue;
                    #
                    # if check values in enumeration list
                    #
                    if( $showMap{'values-enum'} ) {
                        if( exists $dictD->{$lc_tagAnalysed}{values}{_enumeration} ) {
                            my $listEnumValuesForTag = join(', ',
                                    @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}}
                                    );
                            my $valueFoundInList = 0;
                            my $emulateSet = 0;
                            if(  grep lc($_) eq $lc_tagAnalysed,
                                    @{$setOfEnum} ) {
                                $emulateSet = 1;
                                my $setOfEnumValues = join '|',
                                    @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}};
                                $setOfEnumValues =~ s/\./\\./;
                                my $regexpSetOfEnumValues = 
                                                 qr/^($setOfEnumValues)+$/s;
                                if( $showMap{'values-enum-nocase'} ) {
                                    if( $value =~ 
                                        m/$regexpSetOfEnumValues/is ) {
                                        $valueFoundInList = 1;
                                    }
                                } else {
                                    if( $value =~ 
                                        m/$regexpSetOfEnumValues/s ) {
                                        $valueFoundInList = 1;
                                    }
                                }
                            } else {
                                if( $showMap{'values-enum-nocase'} ) {
                                    my $lcValue = lc $value;
                                    if( grep lc($_) eq $lcValue, 
                                         @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}} ) {
                                        $valueFoundInList = 1;
                                    }
                                } else {
                                    if( grep $_ eq $value, 
                                         @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}} ) {
                                        $valueFoundInList = 1;
                                    }
                                }
                            }

                            if( $valueFoundInList == 0 ) {
                                showValidationMessage 2, 'values-enum',
                                    $cifF, $$block{name},
                                    "tag '" . $tagAnalysed . "' value "
                                    . '"'
                                    . $value
                                    . '" should be one of these: ['
                                    . $listEnumValuesForTag
                                    . '] values';
                            } else {
                                my $message = "tag '" . $tagAnalysed
                                    . "' value "
                                    . '"'
                                    . $value
                                    . '" is one of these: ['
                                    . $listEnumValuesForTag
                                    . '] values';
                                if( $showMap{'values-enum-nocase'} ) {
                                    $message .= ' (case ignored)';
                                }
                                if( $emulateSet ) {
                                    $message .= ', enum was treated as set';
                                }
                                showValidationMessage 24, 'values-enum',
                                    $cifF, $$block{name},
                                    $message;
                                undef $message;
                            }
                        }
                    }
                    #
                    # end-if check values in enumeration list
                    #
                    
                    #
                    # if check values against enumeration_range
                    #
                    if( $showMap{'values-range'} ) {
                        if( %$range ) {
                            my $valueWOPrecision = $value;
                            if( $dictD->{$lc_tagAnalysed}{values}{_type}[0] 
                                 eq 'numb' ) {
                                if(defined $block->{types}{$tagAnalysed}) {
                                    if('FLOAT'  ne $block->{types}{$tagAnalysed}[$tagIndex]
                                       && 'INT' ne $block->{types}{$tagAnalysed}[$tagIndex]) {
                                        showValidationMessage 2, 'value-type',
                                            $cifF, $$block{name},
                                            "tag '" . $tagAnalysed . "' " .
                                            "value \"" . 
                                            $block->{values}{$tagAnalysed}[$tagIndex] .
                                            "\" " .
                                            "is of type "
                                            . "'"
                                            . $block->{types}{$tagAnalysed}[$tagIndex]
                                            . "' while it should be numeric, i.e. 'FLOAT', or 'INT'";
                                    } else {
                                        showValidationMessage 64, 'value-type',
                                            $cifF, $$block{name},
                                            "tag '" . $tagAnalysed . "' is of type "
                                            . "'"
                                            . $block->{types}{$tagAnalysed}[$tagIndex]
                                            . "' as expected, as it should be one of: 'FLOAT', 'INT'";
                                    }
                                }
                                $valueWOPrecision =~ s/\s*\(.*$//;
                            }
                            if( checkAgainstRange(
                            $dictD->{$lc_tagAnalysed}{values}{_type}[0],
                            $range, $valueWOPrecision) <= 0 ) {
                                showValidationMessage 2, 'values-range',
                                    $cifF, $$block{name},
                                    "tag '" . $tagAnalysed . "' value "
                                    . '"'
                                    . $value
                                    . '" should be in range ('
                                    .  $rangeForPrint{min}
                                    . ', ' . $rangeForPrint{max} . ')';
                            } else {
                                    showValidationMessage 64, 
                                        'values-range', $cifF, 
                                        $$block{name},
                                        "tag '" . $tagAnalysed . "'"
                                        . ' value '
                                        . '"'
                                        . $value
                                        . '" is in range ('
                                        . $rangeForPrint{min}
                                        . ', '
                                        . $rangeForPrint{max}
                                        . ')';
                            }
                        } else {
                            showValidationMessage 64, 'values-range', 
                                $cifF, $$block{name},
                                'there are no range restrictions'
                                . " for tag '"
                                . $tagAnalysed
                                . "', skipping range test";
                        }
                    }
                    #
                    # end-if check values against enumeration_range
                    #
                }
                }
                # end-if check types of values
                
                # -----------------------------------------------------
                # -----------------------------------------------------
                # -----------------------------------------------------
            }
            #
            # end-iterate-through-dictionaries
            #
            if( $showMap{'tag-exists'} == 1
                && $defined == 0 ) {
                showValidationMessage 2, 'tag-exists', $cifF, 
                    $$block{name}, "tag '" . $tagAnalysed . "'"
                    . ' was not found in dictionaries';
            }
            
        }
        #
        # end-iterate-trough-CIF-values
        #
    }
    #
    # end-iterate-trough-CIF-file-data-blocks
    #    
}
#
# end-iterate-trough-CIF-files
#    

#
# here goes all subroutines bodies
#

sub VersionMessage
{
	print <<END_M;
cif_check_dict (using CIFParser v.$CIFParser::version) v.$version
Copyright (C) 2007 ???
This is free software. You may redistribute copies of it under the terms of
the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
There is NO WARRANTY, to the extent permitted by law.

Written by Justas Butkus.
END_M
    exit 0;
}

sub HelpMessage
{
	print <<END_M;
NOTICE: this is a development version.
Any interfaces are a matter to change.
Please be careful not to include it in any public system, or carefully 
revise in case of updates.

Options available:
    --output cid_validate.log
        This meant - you can define some file, that is writable for 
        current user and this script output will be redirected to it.
        I.e. '--output output.log'
    --dictionary cif_core.dic
        Any valid CIF file, with CIF dictionary (according to DDL2).
        You can define any number of CIF dictionaries, in a way like 
        this:
        $0 --dictionary cif_core.dic --dictionary cod_core.dic
    --quiet
        Minimizes program output.
    --no-quiet
        Maximizes program output.
    --error-level 4
        Define verbosity of script.
        This is a subject to change. So far it is used for debugging 
        purposes to maximise program output.
        Default verbosity level is 4. It can go up as far as to 65536.
        Higher than 4 levels are intended for debugging purposes only.
    --version
        Prints version message and exits.
    --help
        Prints this message and exits.
    --set-of-enum
        If tag name is given to this parameter and tag specified has 
        some enumeration values to check against, they are treated as 
        set, i.e. more than one of enumeration values could be defined 
        for one single element. By default it is turned on for tag 
        '_atom_site_refinement_flags', which is documented as set, but 
        only in it's description.
    --no-set-emulation
        This parameter turns off all so far defined exceptions, that 
        emulates enumeration treating as set (see --set-of-enum).
    --check
        Provide a list of options, what tests should be performed.
        Please see list of options further.
    --show
        Alias for '--check'.
    --check-all
        Turn on all tests (see below).
    --check-tag-exists
        Turn on test 'tag-exists'.
        This test is ON by default.
        It tests, whereas tag is defined in dictionary.
    --check-tag-exists-local
        Turn on test 'tag-exists-local'.
        This test is OFF by default.
        This test enforces check of tags marked as local, i.e.
         _[local]_cod_depositor_comments.
        Otherwise these tags are ignored.
    --check-tag-deprecated
        Turn on test 'tag-deprecated'.
        This test is OFF by default.
        This test checks whereas tag was not replaced by new one.
    --check-tags-grouped
        Turn on test 'tags-grouped'.
        This test is OFF by default.
        This test checks, whereas list of tags must be together in loop.
        I.e. if you define '_atom_site_fract_x' values for
        '_atom_site_fract_y' and '_atom_site_fract_z' must be defined as
        well.
        It is turned off, because so far it might give too much
        false-warnings.
    --check-list-mandatory
        Turn on test 'list-mandatory'.
        This test is ON by default.
        This test checks whereas tag MUST be in loop. It means it can not
        be defined anywhere in data_ block, only within some loop.
    --check-ref-list-mandatory
        Turn on test 'ref-list-mandatory'.
        This test is OFF by default.
        This test is used to check, whereas there is some tag associated
        with any others, that must be present in loop. I.e. if you define
        '_atom_site_fract_x' tag '_atom_site_label' must be defined
        somewhere as well.
    --check-values-enum
        Turn on test 'values-enum'.
        This test is ON by default.
        This test is used to check, whereas tag values are restricted to
        some list and if yes - whereas they fit in. I.e. tag
        '_exptl_absorpt_correction_type' is restricted to values
        'analytical, cylinder, empirical, ...'.
    --check-values-enum-nocase
        Turn on tests 'values-enum-nocase' and 'values-enum'.
        This test is OFF by default.
        This is a test option, indicating that case must be ignored, while
        checking them against list (see 'values-enum'). This option is
        only actual if values-enum test is ON. I.e. '_atom_site_adp_type'
        is restricted to values ('Uani', 'Uiso', 'Uovl', ...) and 'UANI' 
        would be incorrect, if values-enum-nocase is turned off.
    --check-values-range
        Turn on test 'values-range'.
        This test is ON by default.
        The test is used to check, whereas some boundaries were defined.
        I.e. '_refine_ls_abs_structure_Flack' must be between '0.0' and
        '1.0'.
    --check-value-type
        Turn on tests 'value-type' and 'values-enum'.
        This test is ON by default.
        This test is used to check, if type implied by dictionary (i.e. numb)
        does match the type in file, as detected by CIFParser (i.e. FLOAT).
        So far applies only to nummeric types, as UQSTRING, as such, might be
        treated as numeric value by human and vice-versa.
    --check-none
        Turns of all tests.
    --do-not-check-tag-exists
        Turn off test 'tag-exists'.
        This test is ON by default.
        It tests, whereas tag is defined in dictionary.
    --do-not-check-tag-exists-local
        Turn off test 'tag-exists-local'.
        This test is OFF by default.
        This test enforces check of tags marked as local, i.e.
         _[local]_cod_depositor_comments.
        Otherwise these tags are ignored.
    --do-not-check-tag-deprecated
        Turn off test 'tag-deprecated'.
        This test is OFF by default.
        This test checks whereas tag was not replaced by new one.
    --do-not-check-tags-grouped
        Turn off test 'tags-grouped'.
        This test is OFF by default.
        This test checks, whereas list of tags must be together in loop.
        I.e. if you define '_atom_site_fract_x' values for
        '_atom_site_fract_y' and '_atom_site_fract_z' must be defined as
        well.
        It is turned off, because so far it might give too much
        false-warnings.
    --do-not-check-list-mandatory
        Turn off test 'list-mandatory'.
        This test is ON by default.
        This test checks whereas tag MUST be in loop. It means it can not
        be defined anywhere in data_ block, only within some loop.
    --do-not-check-ref-list-mandatory
        Turn off test 'ref-list-mandatory'.
        This test is OFF by default.
        This test is used to check, whereas there is some tag associated
        with any others, that must be present in loop. I.e. if you define
        '_atom_site_fract_x' tag '_atom_site_label' must be defined
        somewhere as well.
    --do-not-check-values-enum
        Turn off test 'values-enum'.
        This test is ON by default.
        This test is used to check, whereas tag values are restricted to
        some list and if yes - whereas they fit in. I.e. tag
        '_exptl_absorpt_correction_type' is restricted to values
        'analytical, cylinder, empirical, ...'.
    --do-not-check-values-enum-nocase
        Turn off test 'values-enum-nocase'.
        This test is OFF by default.
        This is a test option, indicating that case must be ignored, while
        checking them against list (see 'values-enum'). This option is
        only actual if values-enum test is ON. I.e. '_atom_site_adp_type'
        is restricted to values ('Uani', 'Uiso', 'Uovl', ...) and 'UANI' 
        would be incorrect, if values-enum-nocase is turned off.
    --do-not-check-values-range
        Turn off test 'values-range'.
        This test is ON by default.
        The test is used to check, whereas some boundaries were defined.
        I.e. '_refine_ls_abs_structure_Flack' must be between '0.0' and
        '1.0'.
    --do-not-check-value-type
        Turn off test 'value-type'.
        This test is ON by default.
        This test is used to check, if type implied by dictionary (i.e. numb)
        does match the type in file, as detected by CIFParser (i.e. FLOAT).
        So far applies only to nummeric types, as UQSTRING, as such, might be
        treated as numeric value by human and vice-versa.

Selecting tests, that should be performed:
    Option '--check' accepts comma separated list of test names.
    Tests are listed below, and any other value than that is not 
    accepted. NOTE that test names consists only of letters, minus sign 
    (i.e. '-') and underscore symbol (i.e. '_').
    Test name could be preceded by plus '+', or minus '-' sign, and by 
    this test could be turned on (in case of plus sign), or turned off 
    (in case of minus sign). NOTE: if you do not supply any of these 
    symbols, the validator expects it to be a plus sign and turns on the 
    test indicated.
    Some tests are turned on by default, but you could turn them off by 
    setting prefixing with minus in '--check' option.
    Special option is 'all'. If you put 'all-', then it turns OFF all 
    tests, if you put 'all+', or plain 'all' it turns ON all tests.
    NOTE: later declarations of '--check' will override previously 
    turned on/off tests.
    List of tests:
        o tag-exists - this test is ON by default. It is meant to check 
                    whereas tag DO exist in dictionary.
        o tag-exists-local - this test enforces check of tags marked as 
                    local, i.e. _[local]_cod_depositor_comments. 
                    Otherwise these tags are ignored.
        o tag-deprecated - this test is OFF by default. If turned on it 
                    checks whereas tag was not replaced by new one.
        o tags-grouped - this test is OFF by default. It is meant to 
                    check, whereas list of tags must be together in 
                    loop. I.e. if you define '_atom_site_fract_x' values 
                    for '_atom_site_fract_y' and '_atom_site_fract_z' 
                    must be defined as well.
                    It is turned off, because so far it might give too 
                    much false-warnings.
        o list-mandatory - this test is ON by default. It checks whereas 
                    tag MUST be in loop. It means it can not be defined 
                    anywhere in data_ block, only within some loop.
        o ref-list-mandatory - this test is OFF by default. It is used 
                    to check, whereas there is some tag associated with 
                    any others, that must be present in loop. I.e. if 
                    you define '_atom_site_fract_x' tag
                    '_atom_site_label' must be defined somewhere as 
                    well.
        o values-enum - this test is ON by default. The test checks, 
                    whereas tag values are restricted to some list and 
                    if yes - whereas they fit in. I.e. tag
                    '_exptl_absorpt_correction_type' is restricted to 
                    values 'analytical, cylinder, empirical, ...'.
        o values-enum-nocase - this is a test option, indicating that
                    case must be ignored, while checking them against 
                    list. This option is only actual if values-enum 
                    test is ON. I.e. '_atom_site_adp_type' is restricted 
                    to values ('Uani', 'Uiso', 'Uovl', ...) and 'UANI' 
                    would be incorrect, if values-enum-nocase is turned 
                    off.
        o values-range - this test is ON by default. The test is used to 
                    check, whereas some boundaries were defined. I.e. 
                    '_refine_ls_abs_structure_Flack' must be between 
                    '0.0' and '1.0'.
END_M
    exit 0;
}

sub showValidationMessage {
    my ($severity, $type, $file, $dataBlockName, $message)
        = (shift, shift, shift, shift, shift);
    if( $severity > $errorLevel ) {
        return 0;
    }
    if( $showMap{$type} == 0 ) {
        # if this return happens - there must be a bug left
        return 0;
    }
    my $output = $0 . ": ";
    if( defined $severity && $severity ) {
        $output .= $severity . ": ";
    }
    $output .= $file;
    if( defined $dataBlockName && $dataBlockName ) {
        $output .= " data_" . $dataBlockName;
    }
    $output .= ":";
    $output .= " " . $message;
    $output .= "\n";
    print $output;
}

sub getDict
{
	my $dictF = shift;
	my $tags = {};
	my $datan = 0;
   	while( $datan < @$dictF )
    {
        $datan++ and next if
            !exists $$dictF[$datan]{values}{_type};
        for ( @{$$dictF[$datan]{values}{_name}} ) {
            $$tags{lc $_} = $$dictF[$datan];
        }
        $datan++;
	}
	return $tags;
}

sub checkAgainstRange {
    my $type  = shift; # char or numb
    my $range = shift;
    my $value = shift;
    if( !exists $$range{min} &&
        !exists $$range{max} ) {
        return -1;
    }
    if( $type eq 'numb' ) {
        return checkAgainstRangeNumb( $range, $value );
    } else {
        return checkAgainstRangeChar( $range, $value );
    }
    return 0;
}

sub checkAgainstRangeNumb {
    my $range = shift;
    my $value = shift;
    if( ! Scalar::Util::looks_like_number($value) ) {
        return 0;
    }
    if(
        ( !exists $$range{max} || $value <= $$range{max} )
        &&
        ( !exists $$range{min} || $value >= $$range{min} )
    ) {
        return 1;
    }
    return 0;
}

sub checkAgainstRangeChar {
    my $range = shift;
    my $value = shift;
    if(
        ( !exists $$range{max} || $value le $$range{max} )
        &&
        ( !exists $$range{min} || $value ge $$range{min} )
    ) {
        return 1;
    }
    return 0;
}

sub getRelatedMandatory {
    my $dict = shift;
    my $tag = shift;
    $tag = lc $tag;
    my $reccurentCall = shift;
    my $requeryTag = undef;
    if( !exists $dict->{$tag} ) {
        return undef;
    }
    if( defined $reccurentCall
        && exists $dict->{$tag}{values}{_list_mandatory}
        && $dict->{$tag}{values}{_list_mandatory}[0] eq 'yes' ) {
        return $tag;
    }
    if( exists $dict->{$tag}{values}{_list_reference} ) {
        $requeryTag = $dict->{$tag}{values}{_list_reference}[0];
    }
    if( !defined $requeryTag ) {
        return undef;
    }
    return getRelatedMandatory $dict, $requeryTag, 1;
}
