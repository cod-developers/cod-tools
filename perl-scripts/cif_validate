#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;

#------------------------------------------------------------------------------
#$Author: $
#$Date: $
#$Revision: $
#$URL: $
#------------------------------------------------------------------------------
#*
#  Parse CIF file(s) and CIF dictionary(ies).
#  Check CIF file against CIF dictionaries.
#**

#
# here we link libraries
#
use strict;
use warnings;
use Scalar::Util;
use lib "./lib/perl5";
use lib "./CIFParser";
use CIFParser;
use ShowStruct;
use SOptions;

#
# here we define variables
#	first - constant values
#	then  - common variables
#
my $version = 0.1;

my $CIFfile = ();
my $CIFtags;
my $outputFile;
my $dictFiles = [];
my $dictFilesParsed = [];
my $dictTags = {};
my $quiet = 0;
my $errorLevel = 2;
my $parser = new CIFParser;
#
# We read user requested options into an array-ref in this case user can 
# define '--check' many times with different or same options, that are 
# parsed later.
#
my $outputOptions = [];
#
# Errors reporting and CIF validation is performed according to this 
# hash entries.
# All possible options MUST be listed here, because no checking whereas 
# option exists will be made (it MUST be NOT necessary).
# NOTE: please update 'HelpMessage' subroutine when adding new option, 
# so that user would know what options are possible.
# TODO: 'errorLevel' and 'quiet' options must be removed later in 
# accordance to this option. Some 'debug' option might be created, to 
# report more information than it is necessary to understand validation 
# errors.
#
my %showMap = (
        #
        # some private tags
        '_debug'             => 1,
        #
        # tag name checking related options
        'tag-exsits'         => 1,
        'tag-deprecated'     => 0,
        #
        # loop_ checking related options
        'tags-grouped'       => 0,
        'list-mandatory'     => 1,
        'ref-list-mandatory' => 0,
        #
        # value checking related options
        'values-enum'        => 1,
        'values-range'       => 1
    );

#
# here we declare subroutines
#

# subroutine to print module version and copyright notice
sub VersionMessage;

# subroutine to print help on module usage
sub HelpMessage;

# subroutine to print validation message (for SPOT purposes)
# list of arguments:
#     1. severity level (# ../doc/error-levels.txt)
#     2. CIF file analysed
#     3. CIF data block analysed
#     4. error message experienced
sub showValidationMessage;

# subroutine to extract tags from dictionary (parsed using CIFParser)
# it takes reference to CIFParser output
# returns hash of tags and related references to parsed data blocks
sub getDict;

# subroutine to check value against range (defined in dictionary)
# Arguments:
#   1. type of value (numb or char);
#   2. reference to range as $$range{min} and $$range{max};
#   3. value, that must be checked.
sub checkAgainstRange;

# subroutine to check number value against range (defined in dictionary)
# Arguments:
#   1. reference to range as $$range{min} and $$range{max};
#   2. value, that must be checked.
sub checkAgainstRangeNumb;

# subroutine to check character value against range (defined in dictionary)
# Arguments:
#   1. reference to range as $$range{min} and $$range{max};
#   2. value, that must be checked.
sub checkAgainstRangeChar;

# subroutine to return name of closest (according to dictionary) 
#     mandatory tag, if applicable. Return undef, if no mandatory tag is 
#     related to tag analysed
# Arguments:
#   1. reference to dictionary
#   2. lowercased name of currently analysed tag
sub getRelatedMandatory;

#
# main program code
#

# check parameters passed
@ARGV = getOptions(
        "--output"
            => \$outputFile,
        "--dictionary"
            => $dictFiles,
        "--version"
            => sub{ VersionMessage() },
        "--quiet"
            => sub{ $errorLevel *= 2; },
        "--no-quiet"
            => sub{ $errorLevel /= 2; },
        "--error-level"
            => \$errorLevel,
        "--help"
            => sub{ HelpMessage() },
        "--check"
            => $outputOptions,
        "--show"
            => $outputOptions
    );

if( defined($outputFile) ) {
    open( STDOUT, "> $outputFile" ) || die('Unable to open '
                        . $outputFile . ' for writing: ' . $! . '.');
}

for( @{$outputOptions} ) {
    my @options = split /,/;
    ITERATEOPTIONS: for( @options ) {
        m/^
            (
                [a-z\-_]* # option itself MUST be letters-only
                [a-z]
            )
            (
                [\-+]? # the option might be preceeded by '+' or '-' sign
                # the later meaning, that we do NOT want this to be printed
            )
        $/six;
        if( !defined $1 ) {
            print STDERR $0. ': Output option "' . $_ . '" is not'
                    . ' valid.'
                    . ' Options MUST contain only letters,'
                    . ' underscore "_" and minus "-" signs.' . "\n";
            next ITERATEOPTIONS;
        }
        my $opt = lc( $1 );
        if( !exists $showMap{$opt}
            && $opt ne 'all' ) {
            print STDERR $0. ': Output option '
                    . "'" . $1 . "'"
                    . ' is not '
                    . 'known. '
                    . 'Options should be one of these: ['
                    . join(', ', keys(%showMap))
                    . '].'
                    . "\n";
            next ITERATEOPTIONS;
        }
        if( $opt eq 'all' ) {
            my $setTo = 0;
            $setTo = 1 unless $2 eq '-';
            while ( my($k,$v) = each(%showMap) ) {
                $showMap{$k} = $setTo;
            }
            last ITERATEOPTIONS;
        }
        if( $2 eq '-' ) {
            $showMap{$opt} = 0;
        } else {
            $showMap{$opt} = 1;
        }
    }
}

my $anyTestIsTurnedOn = 0;
while( my($k, $v) = each %showMap ) {
    $anyTestIsTurnedOn = 1 if $v;
}
if( !$anyTestIsTurnedOn ) {
    print STDERR $0. ': No test is chosen to be performed. Exiting.'
        . "\n";
    exit( 0 );
}
undef $anyTestIsTurnedOn;

if( @$dictFiles )
{
    DICTFILE: for( @{$dictFiles} ) {
        my $parsed = $parser->Run( $_ );
        next DICTFILE if $parsed == 1;
        push( @$dictFilesParsed, $parsed );
        $$dictTags{$_} = getDict( $parsed );
        undef $parsed;
    }
    if( keys( %$dictTags ) == 0 ) {
        print STDERR $0 . ': '
                . join( ",", @$dictFiles )
                . ': No tags were defined in dictionaries.'
                . "\n";
        exit 1;
    }
} else {
    die "You must specify dictionary using '--dictionary'. Automatic "
            . "dictionary download is not implemeted yet.\n";
    my $dictIUCRURI = "ftp://ftp.iucr.org/pub/cif_core.dic";
}

# parse CIF files. If none is passed - display help message
if( !@ARGV ) {
	HelpMessage();
	exit( 1 );
}

for( @ARGV ) {
    push( @{$CIFfile}, $_ );
}

#
# start-iterate-trough-CIF-files
#    
CIFFILEANAL: for my $cifF ( @{$CIFfile} ) {
    my $data = $parser->Run( $cifF );
    next CIFFILEANAL if $data == 1;
    #
    # start-iterate-trough-CIF-file-data-blocks
    #    
    for my $block ( @$data ) {
        if( $quiet == 0 ) {
            showValidationMessage 64, '_debug', $cifF, $$block{name}, 
                    'analysis start';
        }
        #
        # hash tagsListedInLoops
        # If a tag (key is lowercased tag name) appears in this hash it 
        # means, that it must appear within loop.
        # Value is enum('yes', 'no'). Depending on this we know, whereas 
        # tag was correctly (i.e. together with other tags) defined 
        # within some loop.
        #
        my %tagsListedInLoops;
        #
        # hash baseNamesOfRefTags
        # A tag listed in this hash depends on some other loop_ tag, and
        # is correctly referenced (parent tag is defined within same 
        # loop). Value is enum('yes', 'no').
        #
        my %baseNamesOfRefTags;
        #
        # start-iterate-trough-CIF-values
        #
        for my $tagAnalysed ( @{$block->{tags}} ) {
            my $lc_tagAnalysed = lc $tagAnalysed;
            my $defined = 0;
            my $correctDataType = 0;
            #
            # start-iterate-through-dictionaries
            #
            while( my($dictF, $dictD) = each %$dictTags ) {
                #
                # if check tags
                #
                if( $showMap{'tag-exsits'} ) {
                    if( exists $$dictD{$lc_tagAnalysed} ) {
                        $defined++;
                        showValidationMessage 64, 'tag-exsits', $cifF, 
                            $$block{name}, "tag '" . $tagAnalysed . "'"
                            . ' do exist in dictionary ' . $dictF;
                    } else {
                        showValidationMessage 16, 'tag-exsits', $cifF, 
                            $$block{name}, "tag '" . $tagAnalysed . "'"
                            . ' does not exist in dictionary ' . $dictF;
                    }
                }
                # end-if check tags
                
                #
                # if check tags deprecation (replacements)
                #
                if( $showMap{'tag-deprecated'} ) {
                    if(exists $dictD->{$lc_tagAnalysed}{values}{_related_item}) {
                        my $replaceWith = [];
                        for( my $i = 0;
                            $i < @{$dictD->{$lc_tagAnalysed}{values}{_related_item}};
                            $i++ )
                            {
                            if($dictD->{$lc_tagAnalysed}{values}{_related_function}[$i]
                                eq 'replace') {
                                push @{$replaceWith},
                                    $dictD->{$lc_tagAnalysed}{values}{_related_item}[$i];
                            }
                        }
                        if( @$replaceWith != 0 ) {
                            showValidationMessage 8, 'tag-deprecated',
                                $cifF, $$block{name},
                                "tag '" . $tagAnalysed . "' has been"
                                . ' replaced by tag(-s): ['
                                . join(', ', @$replaceWith)
                                . '] according to ' . $dictF;
                        }
                    }
                }
                # end-if check tags deprecation (replacements)
                
                # -----------------------------------------------------
                # -----------------------------------------------------
                # -----------------------------------------------------
                
                #
                # if check referenced list mandatory
                #
                if( $showMap{'ref-list-mandatory'} ) {
                    my $mandatoryRTag = getRelatedMandatory($dictD, 
                                                     $lc_tagAnalysed);
                    if( defined $mandatoryRTag
                        && !exists($baseNamesOfRefTags{$dictD->{$lc_tagAnalysed}{name}})
                        ) {
                        for my $loopAnalysed ( @{$block->{loops}} ) {
                            if( grep $_ eq $tagAnalysed, @{$loopAnalysed} ) {
                                if( grep lc($_) eq $mandatoryRTag, @{$loopAnalysed} ) {
                                    showValidationMessage 64,
                                        'ref-list-mandatory', $cifF,
                                        $$block{name},
                                        "tag '" . $mandatoryRTag
                                        . "' is mandatory in loop when"
                                        . ' tag(s) ['
                                        . join(', ', 
                                        @{$dictD->{$lc_tagAnalysed}{values}{_name}})
                                        . '] are defined'
                                        . ' according to ' . $dictF
                                        . ' and was found';
                                    $baseNamesOfRefTags{$dictD->{$lc_tagAnalysed}{name}}
                                        = 'yes';
                                } else {
                                    showValidationMessage 2,
                                        'ref-list-mandatory', $cifF,
                                        $$block{name},
                                        "tag '" . $mandatoryRTag
                                        . "' is mandatory in loop when"
                                        . ' tag(s) ['
                                        . join(', ', 
                                        @{$dictD->{$lc_tagAnalysed}{values}{_name}})
                                        . '] are defined'
                                        . ' according to ' . $dictF
                                        . ' but was not found';
                                    $baseNamesOfRefTags{$dictD->{$lc_tagAnalysed}{name}}
                                        = 'no';
                                }
                            }
                        }
                    }
                }
                # end-if check referenced list mandatory
                

                #
                # if group of tags must be presented within same loop
                #
                if( $showMap{'tags-grouped'} ) {
                    if( defined $dictD->{$lc_tagAnalysed}{values}{_name}
                        && defined $dictD->{$lc_tagAnalysed}{values}{_list}
                        && !defined $tagsListedInLoops{$lc_tagAnalysed}
                        && @{$dictD->{$lc_tagAnalysed}{values}{_name}} > 1
                        && $dictD->{$lc_tagAnalysed}{values}{_list}[0] eq 'yes' ) {
                        my $countItems = 
                            @{$dictD->{$lc_tagAnalysed}{values}{_name}};
                        my $allTagsFound = 0;
                        #
                        # iterate through loops array from CIFfile, 
                        # current data block.
                        # NOTE: $loopAnalysed is an array-ref
                        #
                        for my $loopAnalysed ( @{$block->{loops}} ) {
                            my @found;
                            my @notFound;
                            #
                            # iterate through tags list, that there
                            # marked as mandatory if at least one is
                            # defined.
                            # NOTE: $mandatoryTag is a scalar
                            #
                            for my $mandatoryTag ( 
                                @{$dictD->{$lc_tagAnalysed}{values}{_name}}
                            ) {
                                if( grep lc($_) eq $mandatoryTag, @{$loopAnalysed} ) {
                                    push @found, $mandatoryTag;
                                    $tagsListedInLoops{lc $mandatoryTag} = 'yes';
                                } else {
                                    push @notFound, lc($mandatoryTag);
                                }
                            }
                            if( @found > 0 ) {
                                if( @found == $countItems ) {
                                   $allTagsFound = 1;
                                    showValidationMessage 64, 
                                        'tags-grouped', $cifF,
                                        $$block{name},
                                        'tags ['
                                        . join(', ', 
                                            @{$dictD->{$lc_tagAnalysed}{values}{_name}})
                                        . '] must be in loop according'
                                       . ' to ' .$dictF
                                       . ' and were found'
                                        . ' within loop';
                                } else {
                                    for( @notFound ) {
                                        $tagsListedInLoops{$_} = 'no';
                                    }
                                    showValidationMessage 2, 
                                        'tags-grouped', $cifF,
                                        $$block{name},
                                        'tags ['
                                        . join(', ', 
                                            @{$dictD->{$lc_tagAnalysed}{values}{_name}})
                                        . '] must be in loop according'
                                        . ' to '
                                        . $dictF . ' but only ['
                                        . join(', ', @found)
                                        . '] were found';
                                }
                            }
                        }
                    }
                }
                # end-if group of tags must be presented within same loop
                
                #
                # if check list mandatory
                #
                if( $showMap{'list-mandatory'} ) {
                    if( exists $dictD->{$lc_tagAnalysed}{values}{_list_mandatory}
                        && $dictD->{$lc_tagAnalysed}{values}{_list_mandatory}[0]
                            eq 'yes' )
                        {
                        if( exists $block->{inloop}{$tagAnalysed} ) {
                            showValidationMessage 64, 'list-mandatory', 
                                $cifF, $$block{name},
                                "tag '" . $tagAnalysed . "' is loop"
                                . ' mandatory according to ' . $dictF
                                . ' and is in loop';
                        } else {
                            showValidationMessage 2, 'list-mandatory', 
                                $cifF, $$block{name},
                                "tag '" . $tagAnalysed . "' is loop"
                                . ' mandatory according to ' . $dictF
                                . ' but is not in loop';
                        }
                    }
                }
                # end-if check list mandatory
                
                # -----------------------------------------------------
                # -----------------------------------------------------
                # -----------------------------------------------------
                
                #
                # if check types of values
                #
                if( $showMap{'values-enum'} == 1
                    || $showMap{'values-range'} == 1 ) {
                my $range = {};
                my %rangeForPrint;
                if( exists $dictD->{$lc_tagAnalysed}{values}{_enumeration_range} ) {
                    ($$range{min}, $$range{max}) = split(/:/, 
                        $dictD->{$lc_tagAnalysed}{values}{_enumeration_range}[0],
                        2);
                    %rangeForPrint = %$range;
                    if( length($$range{min}) == 0 ) {
                        delete $$range{min};
                        $rangeForPrint{min} = '<any>';
                    }
                    if( length($$range{max}) == 0 ) {
                        delete $$range{max};
                        $rangeForPrint{max} = '<any>';
                    }
                }
                CIFVALUE: for my $tagValue ( @{$block->{values}{$tagAnalysed}} ) {
                    next CIFVALUE if $tagValue eq '?';
                    my $value = $tagValue;
                    #
                    # if check values in enumeration list
                    #
                    if( $showMap{'values-enum'} ) {
                        if( exists $dictD->{$lc_tagAnalysed}{values}{_enumeration} ) {
                            my $listEnumValuesForTag = join(', ',
                                    @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}}
                                    );
                            if( !grep $_ eq $value, 
                                 @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}} ) {
                                showValidationMessage 2, 'values-enum',
                                    $cifF, $$block{name},
                                    "tag '" . $tagAnalysed . "' value "
                                    . '"'
                                    . $value
                                    . '" should be one of these: ['
                                    . $listEnumValuesForTag
                                    . '] values';
                            } else {
                                showValidationMessage 64, 'values-enum',
                                    $cifF, $$block{name},
                                    "tag '" . $tagAnalysed . "' value "
                                    . '"'
                                    . $value
                                    . '" is one of these: ['
                                    . $listEnumValuesForTag
                                    . '] values';
                            }
                        }
                    }
                    #
                    # end-if check values in enumeration list
                    #
                    
                    #
                    # if check values against enumeration_range
                    #
                    if( $showMap{'values-range'} ) {
                        if( %$range ) {
                            my $valueWOPrecision = $value;
                            if( $dictD->{$lc_tagAnalysed}{values}{_type}[0] 
                                 eq 'numb' ) {
                                $valueWOPrecision =~ s/\s*\(.*$//;
                            }
                            if( checkAgainstRange(
                            $dictD->{$lc_tagAnalysed}{values}{_type}[0],
                            $range, $valueWOPrecision) <= 0 ) {
                                showValidationMessage 2, 'values-range',
                                    $cifF, $$block{name},
                                    "tag '" . $tagAnalysed . "' value "
                                    . '"'
                                    . $value
                                    . '" should be in range ('
                                    .  $rangeForPrint{min}
                                    . ', ' . $rangeForPrint{max} . ')';
                            } else {
                                    showValidationMessage 64, 
                                        'values-range', $cifF, 
                                        $$block{name},
                                        "tag '" . $tagAnalysed . "'"
                                        . ' value '
                                        . '"'
                                        . $value
                                        . '" is in range ('
                                        . $rangeForPrint{min}
                                        . ', '
                                        . $rangeForPrint{max}
                                        . ')';
                            }
                        } else {
                            showValidationMessage 64, $cifF,
                                $$block{name},
                                'there are no range restrictions'
                                . " for tag '"
                                . $tagAnalysed
                                . "', skipping range test";
                        }
                    }
                    #
                    # end-if check values against enumeration_range
                    #
                }
                }
                # end-if check types of values
                
                # -----------------------------------------------------
                # -----------------------------------------------------
                # -----------------------------------------------------
            }
            #
            # end-iterate-through-dictionaries
            #
            if( $showMap{'tag-exsits'} == 1
                && $defined == 0 ) {
                showValidationMessage 2, 'tag-exsits', $cifF, 
                    $$block{name}, "tag '" . $tagAnalysed . "'"
                    . ' was not found in dictionaries';
            }
            
        }
        #
        # end-iterate-trough-CIF-values
        #
    }
    #
    # end-iterate-trough-CIF-file-data-blocks
    #    
}
#
# end-iterate-trough-CIF-files
#    

#
# here goes all subroutines bodies
#

sub VersionMessage
{
	print <<END_M;
cif_check_dict (using CIFParser v.$CIFParser::version) v.$version
Copyright (C) 2007 ???
This is free software. You may redistribute copies of it under the terms of
the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
There is NO WARRANTY, to the extent permitted by law.

Written by Justas Butkus.
END_M
    exit 0;
}

sub HelpMessage
{
	print <<END_M;
NOTICE: this is a development version.
Any interfaces are a matter to change.
Please be careful not to include it in any public system, or carefully 
revise in case of updates.

Options available:
    --output <file>
        This meant - you can define some file, that is writable for 
        current user and this script output will be redirected to it.
        I.e. '--output output.log'
    --dictionary <cif_file>
        Any valid CIF file, with CIF dictionary (according to DDL2).
        You can define any number of CIF dictionaries, in a way like 
        this:
        $0 --dictionary cif_core.dic --dictionary cod_core.dic
    --quiet
        Minimizes program output.
    --no-quiet
        Maximizes program output.
    --error-level xx
        Define verbosity of script.
        This is a subject to change. So far it is used for debugging 
        purposes to maximise program output.
    --version
        Prints version message and exits.
    --help
        Prints this message and exits.
    --check
        Provide a list of options, what tests should be performed.
        Please see list of options further.
    --show
        Alias for '--check'.

Selecting tests, that should be performed:
    Option '--check' accepts comma separated list of test names.
    Tests are listed below, and any other value than that is not 
    accepted. NOTE that test names consists only of letters, minus sign 
    (i.e. '-') and underscore symbol (i.e. '_').
    Test name could be preceded by plus '+', or minus '-' sign, and by 
    this test could be turned on (in case of plus sign), or turned off 
    (in case of minus sign). NOTE: if you do not supply any of these 
    symbols, the validator expects it to be a plus sign and turns on the 
    test indicated.
    Some tests are turned on by default, but you could turn them off by 
    setting prefixing with minus in '--check' option.
    Special option is 'all'. If you put 'all-', then it turns OFF all 
    tests, if you put 'all+', or plain 'all' it turns ON all tests.
    NOTE: later declarations of '--check' will override previously 
    turned on/off tests.
    List of tests:
        o tag-exsits - this test is ON by default. It is meant to check 
                    whereas tag DO exist in dictionary.
        o tag-deprecated - this test is OFF by default. If turned on it 
                    checks whereas tag was not replaced by new one.
        o tags-grouped - this test is OFF by default. It is meant to 
                    check, whereas list of tags must be together in 
                    loop. I.e. if you define '_atom_site_fract_x' values 
                    for '_atom_site_fract_y' and '_atom_site_fract_z' 
                    must be defined as well.
                    It is turned off, because so far it might give too 
                    much false-warnings.
        o list-mandatory - this test is ON by default. It checks whereas 
                    tag MUST be in loop. It means it can not be defined 
                    anywhere in data_ block, only within some loop.
        o ref-list-mandatory - this test is OFF by default. It is used 
                    to check, whereas there is some tag associated with 
                    any others, that must be present in loop. I.e. if 
                    you define '_atom_site_aniso_U_12' tag 
                    '_atom_site_label' must be defined somewhere as 
                    well.
        o values-enum - this test is ON by default. The test checks, 
                    whereas tag values are restricted to some list and 
                    if yes - whereas they fit in. I.e. tag
                    '_exptl_absorpt_correction_type' is restricted to 
                    values 'analytical, cylinder, empirical, ...'.
        o values-range - this test is ON by default. The test is used to 
                    check, whereas some boundaries were defined. I.e. 
                    '_refine_ls_abs_structure_Flack' must be between 
                    '0.0' and '1.0'.
END_M
    exit 0;
}

sub showValidationMessage {
    my ($severity, $type, $file, $dataBlockName, $message)
        = (shift, shift, shift, shift, shift);
    if( $severity > $errorLevel ) {
        return 0;
    }
    if( $showMap{$type} == 0 ) {
        # if this return happens - there must be a bug left
        return 0;
    }
    my $output = $0 . ": ";
    if( defined $severity && $severity ) {
        $output .= $severity . ": ";
    }
    $output .= $file;
    if( defined $dataBlockName && $dataBlockName ) {
        $output .= " data_" . $dataBlockName;
    }
    $output .= ":";
    $output .= " " . $message;
    $output .= "\n";
    print $output;
}

sub getDict
{
	my $dictF = shift;
	my $tags = {};
	my $datan = 0;
   	while( $datan < @$dictF )
    {
        $datan++ and next if
            !exists $$dictF[$datan]{values}{_type};
        for ( @{$$dictF[$datan]{values}{_name}} ) {
            $$tags{lc $_} = $$dictF[$datan];
        }
        $datan++;
	}
	return $tags;
}

sub checkAgainstRange {
    my $type  = shift; # char or numb
    my $range = shift;
    my $value = shift;
    if( !exists $$range{min} &&
        !exists $$range{max} ) {
        return -1;
    }
    if( $type eq 'numb' ) {
        return checkAgainstRangeNumb( $range, $value );
    } else {
        return checkAgainstRangeChar( $range, $value );
    }
    return 0;
}

sub checkAgainstRangeNumb {
    my $range = shift;
    my $value = shift;
    if( ! Scalar::Util::looks_like_number($value) ) {
        return 0;
    }
    if(
        ( !exists $$range{max} || $value <= $$range{max} )
        &&
        ( !exists $$range{min} || $value >= $$range{min} )
    ) {
        return 1;
    }
    return 0;
}

sub checkAgainstRangeChar {
    my $range = shift;
    my $value = shift;
    if(
        ( !exists $$range{max} || $value le $$range{max} )
        &&
        ( !exists $$range{min} || $value ge $$range{min} )
    ) {
        return 1;
    }
    return 0;
}

sub getRelatedMandatory {
    my $dict = shift;
    my $tag = shift;
    $tag = lc $tag;
    my $reccurentCall = shift;
    my $requeryTag = undef;
    if( !exists $dict->{$tag} ) {
        return undef;
    }
    if( defined $reccurentCall
        && exists $dict->{$tag}{values}{_list_mandatory}
        && $dict->{$tag}{values}{_list_mandatory}[0] eq 'yes' ) {
        return $tag;
    }
    if( exists $dict->{$tag}{values}{_list_link_parent} ) {
        $requeryTag = $dict->{$tag}{values}{_list_link_parent}[0];
    }
    if( exists $dict->{$tag}{values}{_list_reference} ) {
        $requeryTag = $dict->{$tag}{values}{_list_reference}[0];
    }
    if( !defined $requeryTag ) {
        return undef;
    }
    return getRelatedMandatory $dict, $requeryTag, 1;
}
