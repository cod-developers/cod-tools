#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;

#------------------------------------------------------------------------------
#$Author: $
#$Date: $
#$Revision: $
#$URL: $
#------------------------------------------------------------------------------
#*
#  Parse CIF file(s) and CIF dictionary(ies).
#  Check CIF file against CIF dictionaries.
#**

#
# here we link libraries
#
use strict;
use warnings;
use Scalar::Util;
use lib "./lib/perl5";
use lib "./CIFParser";
use CIFParser;
use ShowStruct;
use SOptions;
use Getopt::Long;

#
# here we define variables
#	first - constant values
#	then  - common variables
#
my $version = 0.1;

my $CIFfile = ();
my $CIFtags;
my $outputFile;
my $dictFiles = [];
my $dictFilesParsed = [];
my $dictTags = {};
my $quiet = 0;
my $errorLevel = 2;
my $parser = new CIFParser;

#
# here we declare subroutines
#

# subroutine to print module version and copyright notice
sub VersionMessage;

# subroutine to print help on module usage
sub HelpMessage;

# subroutine to print validation message (for SPOT purposes)
# list of arguments:
#     1. severity level (# ../doc/error-levels.txt)
#     2. CIF file analysed
#     3. CIF data block analysed
#     4. error message experienced
sub showValidationMessage;

# subroutine to extract tags from dictionary (parsed using CIFParser)
# it takes reference to CIFParser output
# returns hash of tags and related references to parsed data blocks
sub getDict;

# subroutine to check value against range (defined in dictionary)
# Arguments:
#   1. type of value (numb or char);
#   2. reference to range as $$range{min} and $$range{max};
#   3. value, that must be checked.
sub checkAgainstRange;

# subroutine to check number value against range (defined in dictionary)
# Arguments:
#   1. reference to range as $$range{min} and $$range{max};
#   2. value, that must be checked.
sub checkAgainstRangeNumb;

# subroutine to check character value against range (defined in dictionary)
# Arguments:
#   1. reference to range as $$range{min} and $$range{max};
#   2. value, that must be checked.
sub checkAgainstRangeChar;

#
# main program code
#

# check parameters passed
@ARGV = getOptions(
        "--output"
            => \$outputFile,
        "--dictionary"
            => $dictFiles,
        "--version"
            => sub{ VersionMessage() },
        "--quiet"
            => sub{ $quiet = 1; },
        "--no-quiet"
            => sub{ $quiet = 0; },
        "--error-level"
            => \$errorLevel,
        "--help"
            => sub{ HelpMessage() }
    );

if( defined($outputFile) ) {
    open( STDOUT, "> $outputFile" ) || die('Unable to open '
                        . $outputFile . ' for writing: ' . $! . '.');
}

if( @$dictFiles )
{
    DICTFILE: for( @{$dictFiles} ) {
        my $parsed = $parser->Run( $_ );
        next DICTFILE if $parsed == 1;
        push( @$dictFilesParsed, $parsed );
        $$dictTags{$_} = getDict( $parsed );
        undef $parsed;
    }
    if( keys( %$dictTags ) == 0 ) {
        print STDERR $0 . ': '
                . join( ",", @$dictFiles )
                . ': No tags were defined in dictionaries.'
                . "\n";
        exit 1;
    }
} else {
    die "You must specify dictionary using '--dictionary'. Automatic "
            . "dictionary download is not implemeted yet.\n";
    my $dictIUCRURI = "ftp://ftp.iucr.org/pub/cif_core.dic";
}

# parse CIF files. If none is passed - display help message
if( !@ARGV ) {
	HelpMessage();
	exit( 1 );
}

for( @ARGV ) {
    push( @{$CIFfile}, $_ );
}

#
# start-iterate-trough-CIF-files
#    
CIFFILEANAL: for my $cifF ( @{$CIFfile} ) {
    my $data = $parser->Run( $cifF );
    next CIFFILEANAL if $data == 1;
    #
    # start-iterate-trough-CIF-file-data-blocks
    #    
    for my $block ( @$data ) {
        if( $quiet == 0 ) {
            showValidationMessage 64, $cifF, $$block{name}, 
                    'analysis start';
        }
        my %tagsListedInLoops;
        #
        # start-iterate-trough-CIF-values
        #
        for my $tagAnalysed ( @{$block->{tags}} ) {
            my $lc_tagAnalysed = lc $tagAnalysed;
            my $defined = 0;
            my $correctDataType = 0;
            #
            # start-iterate-through-dictionaries
            #
            while( my($dictF, $dictD) = each %$dictTags ) {
                #
                # if check tags
                #
                if( exists $$dictD{$lc_tagAnalysed} ) {
                    $defined++;
                    if( $quiet == 0 ) {
                        showValidationMessage 64, $cifF, 
                            $$block{name}, "tag '" . $tagAnalysed . "'"
                            . ' do exist in dictionary ' . $dictF;
                    }
                } else {
                    if( $quiet == 0 ) {
                        showValidationMessage 16, $cifF, 
                            $$block{name}, "tag '" . $tagAnalysed . "'"
                            . ' does not exist in dictionary ' . $dictF;
                    }
                }
                # end-if check tags
                
                #
                # if check tags deprecation (replacements)
                #
                if( exists $dictD->{$lc_tagAnalysed}{values}{_related_item} ) {
                    my $replaceWith = [];
                    for( my $i = 0;
                            $i < @{$dictD->{$lc_tagAnalysed}{values}{_related_item}};
                            $i++ )
                        {
                        if( $dictD->{$lc_tagAnalysed}{values}{_related_function}[$i]
                             eq 'replace' ) {
                            push @{$replaceWith},
                                $dictD->{$lc_tagAnalysed}{values}{_related_item}[$i];
                        }
                    }
                    if( @$replaceWith != 0 ) {
                        showValidationMessage 8, $cifF, $$block{name},
                            "tag '" . $tagAnalysed . "' has been"
                            . ' replaced by tag(-s): ['
                            . join(', ', @$replaceWith)
                            . '] according to ' . $dictF;
                    }
                }
                # end-if check tags deprecation (replacements)
                
                # -----------------------------------------------------
                # -----------------------------------------------------
                # -----------------------------------------------------
                
                #
                # if group of tags must be presented within same loop
                #
                if( defined $dictD->{$lc_tagAnalysed}{values}{_name}
                    && defined $dictD->{$lc_tagAnalysed}{values}{_list}
                    && !defined $tagsListedInLoops{$lc_tagAnalysed}
                    && @{$dictD->{$lc_tagAnalysed}{values}{_name}} > 1
                    && $dictD->{$lc_tagAnalysed}{values}{_list}[0] eq 'yes' ) {
                    my $countItems = 
                        @{$dictD->{$lc_tagAnalysed}{values}{_name}};
                    my $allTagsFound = 0;
                    #
                    # iterate through loops array from CIFfile, current 
                    # data block.
                    # NOTE: $loopAnalysed is an array-ref
                    #
                    for my $loopAnalysed ( @{$block->{loops}} ) {
                        my @found;
                        my @notFound;
                        #
                        # iterate through tags list, that there marked 
                        # as mandatory if at least one is defined.
                        # NOTE: $mandatoryTag is a scalar
                        #
                        for my $mandatoryTag ( 
                            @{$dictD->{$lc_tagAnalysed}{values}{_name}}
                        ) {
                            if( grep $_ eq $mandatoryTag, @{$loopAnalysed} ) {
                                push @found, $mandatoryTag;
                                $tagsListedInLoops{lc $mandatoryTag} = 'yes';
                            } else {
                                push @notFound, lc($mandatoryTag);
                            }
                        }
                        if( @found > 0 ) {
                            if( @found == $countItems ) {
                               $allTagsFound = 1;
                                showValidationMessage 64, $cifF,
                                    $$block{name},
                                    'tags ['
                                    . join(', ', 
                                        @{$dictD->{$lc_tagAnalysed}{values}{_name}})
                                    . '] must be in loop according to '
                                    . $dictF . ' and were found'
                                    . ' within loop';
                            } else {
                                for( @notFound ) {
                                    $tagsListedInLoops{$_} = 'no';
                                }
                                showValidationMessage 2, $cifF,
                                    $$block{name},
                                    'tags ['
                                    . join(', ', 
                                        @{$dictD->{$lc_tagAnalysed}{values}{_name}})
                                    . '] must be in loop according to '
                                    . $dictF . ' but only ['
                                    . join(', ', @found)
                                    . '] were found';
                            }
                        }
                    }
                }
                # end-if group of tags must be presented within same loop
                
                #
                # if check list mandatory
                #
                if( exists $dictD->{$lc_tagAnalysed}{values}{_list_mandatory}
                    && $dictD->{$lc_tagAnalysed}{values}{_list_mandatory}[0]
                        eq 'yes' )
                    {
                    if( exists $block->{inloop}{$tagAnalysed} ) {
                        showValidationMessage 64, $cifF, $$block{name},
                            "tag '" . $tagAnalysed . "' is loop"
                            . ' mandatory according to ' . $dictF
                            . ' and is in loop';
                    } else {
                        showValidationMessage 2, $cifF, $$block{name},
                            "tag '" . $tagAnalysed . "' is loop"
                            . ' mandatory according to ' . $dictF
                            . ' but is not in loop';
                    }
                }
                # end-if check list mandatory
                
                # -----------------------------------------------------
                # -----------------------------------------------------
                # -----------------------------------------------------
                
                #
                # if check types of values
                #
                my $range = {};
                my %rangeForPrint;
                if( exists $dictD->{$lc_tagAnalysed}{values}{_enumeration_range} ) {
                    ($$range{min}, $$range{max}) = split(/:/, 
                        $dictD->{$lc_tagAnalysed}{values}{_enumeration_range}[0],
                        2);
                    %rangeForPrint = %$range;
                    if( length($$range{min}) == 0 ) {
                        delete $$range{min};
                        $rangeForPrint{min} = '<any>';
                    }
                    if( length($$range{max}) == 0 ) {
                        delete $$range{max};
                        $rangeForPrint{max} = '<any>';
                    }
                }
                CIFVALUE: for my $tagValue ( @{$block->{values}{$tagAnalysed}} ) {
                    next CIFVALUE if $tagValue eq '?';
                    my $value = $tagValue;
                    #
                    # if check values in enumeration list
                    #
                    if( exists $dictD->{$lc_tagAnalysed}{values}{_enumeration} ) {
                        my $listEnumValuesForTag = join(', ',
                                @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}}
                                    );
                        if( !grep $_ eq $value, @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}} ) {
                            showValidationMessage 2,
                                $cifF, $$block{name},
                                "tag '" . $tagAnalysed . "' value "
                                . '"'
                                . $value
                                . '" should be one of these: ['
                                . $listEnumValuesForTag
                                . '] values';
                        } else {
                            if( $quiet == 0 ) {
                            showValidationMessage 64,
                                $cifF, $$block{name},
                                "tag '" . $tagAnalysed . "' value "
                                . '"'
                                . $value
                                . '" is one of these: ['
                                . $listEnumValuesForTag
                                . '] values';
                            }
                        }
                    }
                    #
                    # end-if check values in enumeration list
                    #
                    
                    #
                    # if check values against enumeration_range
                    #
                    if( %$range ) {
                        my $valueWOPrecision = $value;
                        if( $dictD->{$lc_tagAnalysed}{values}{_type}[0] 
                             eq 'numb' ) {
                            $valueWOPrecision =~ s/\s*\(.*$//;
                        }
                        if( checkAgainstRange(
                        $dictD->{$lc_tagAnalysed}{values}{_type}[0],
                        $range, $valueWOPrecision) <= 0 ) {
                            showValidationMessage 2,
                                $cifF, $$block{name},
                                "tag '" . $tagAnalysed . "' value "
                                . '"'
                                . $value
                                . '" should be in range ('
                                .  $rangeForPrint{min}
                                . ', ' . $rangeForPrint{max} . ')';

                        } else {
                            if( $quiet == 0 ) {
                                showValidationMessage 64, $cifF, 
                                    $$block{name},
                                    "tag '" . $tagAnalysed . "' value "
                                    . '"'
                                    . $value
                                    . '" is in range ('
                                    . $rangeForPrint{min}
                                    . ', ' . $rangeForPrint{max} . ')';
                            }
                        }
                    } else {
                        if( $quiet == 0 ) {
                            showValidationMessage 64, $cifF,
                                $$block{name},
                                'there are no range restrictions'
                                . " for tag '"
                                . $tagAnalysed
                                . "', skipping range test";
                        }
                    }
                    #
                    # end-if check values against enumeration_range
                    #
                }
                # end-if check types of values
                
                # -----------------------------------------------------
                # -----------------------------------------------------
                # -----------------------------------------------------
                
                #
                # if check enumerator values
                #
                
                # end-if check enumerator values
            }
            #
            # end-iterate-through-dictionaries
            #
            if( $defined == 0 ) {
                showValidationMessage 2, $cifF, 
                    $$block{name}, "tag '" . $tagAnalysed . "'"
                    . ' was not found in dictionaries';
            }
            
        }
        #
        # end-iterate-trough-CIF-values
        #
    }
    #
    # end-iterate-trough-CIF-file-data-blocks
    #    
}
#
# end-iterate-trough-CIF-files
#    

#
# here goes all subroutines bodies
#

sub VersionMessage
{
	print <<END_M;
cif_check_dict (using CIFParser v.$CIFParser::version) v.$version
Copyright (C) 2007 ???
This is free software. You may redistribute copies of it under the terms of
the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
There is NO WARRANTY, to the extent permitted by law.

Written by Justas Butkus.
END_M
}

sub HelpMessage
{
	print <<END_M;
I hope you know, what you are doing.
If not - feel recommended to wait until release of production version.
END_M
}

sub showValidationMessage {
    my ($severity, $file, $dataBlockName, $message)
        = (shift, shift, shift, shift);
    if( $severity > $errorLevel ) {
        return 0;
    }
    my $output = $0 . ": ";
    if( defined $severity && $severity ) {
        $output .= $severity . ": ";
    }
    $output .= $file;
    if( defined $dataBlockName && $dataBlockName ) {
        $output .= " data_" . $dataBlockName;
    }
    $output .= ":";
    $output .= " " . $message;
    $output .= "\n";
    print $output;
}

sub getDict
{
	my $dictF = shift;
	my $tags = {};
	my $datan = 0;
   	while( $datan < @$dictF )
    {
        $datan++ and next if
            !exists $$dictF[$datan]{values}{_type};
        for ( @{$$dictF[$datan]{values}{_name}} ) {
            $$tags{lc $_} = $$dictF[$datan];
        }
        $datan++;
	}
	return $tags;
}

sub checkAgainstRange {
    my $type  = shift; # char or numb
    my $range = shift;
    my $value = shift;
    if( !exists $$range{min} &&
        !exists $$range{max} ) {
        return -1;
    }
    if( $type eq 'numb' ) {
        return checkAgainstRangeNumb( $range, $value );
    } else {
        return checkAgainstRangeChar( $range, $value );
    }
    return 0;
}

sub checkAgainstRangeNumb {
    my $range = shift;
    my $value = shift;
    if( ! Scalar::Util::looks_like_number($value) ) {
        return 0;
    }
    if(
        ( !exists $$range{max} || $value <= $$range{max} )
        &&
        ( !exists $$range{min} || $value >= $$range{min} )
    ) {
        return 1;
    }
    return 0;
}

sub checkAgainstRangeChar {
    my $range = shift;
    my $value = shift;
    if(
        ( !exists $$range{max} || $value le $$range{max} )
        &&
        ( !exists $$range{min} || $value ge $$range{min} )
    ) {
        return 1;
    }
    return 0;
}
