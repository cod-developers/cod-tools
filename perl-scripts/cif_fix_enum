#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;

#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Fixes enumeration values in CIF file against CIF dictionaries.
#**

use strict;
use warnings;
use lib "./lib/perl5";
use lib "./CIFParser";
use CIFDictTags;
use CIFCODTags;
use CIFParser;
use CIFTagCanonicalNames;
use ShowStruct;
use SOptions;
use CIFTagPrint;
use CIFTagManage;
use SUsage;

my $dictParsed = [];
my $parser = new CIFParser;
my @dictionaries = ();
my %dictTags;
my %tagDicts;

my $Id = '$Id$';
my $keep_tag_order = 0;

#*Usage:
#*      cif_fix_enum [options] COD-cif-dir/
#*
#*Options:
#*     --dictionary cif_core.dic
#*        Any valid CIF file, with CIF dictionary (according to DDL2).
#*        You can define any number of CIF dictionaries, in a way like
#*        this:
#*        $0 --dictionary cif_core.dic --dictionary cod_core.dic
#*     --add-dictionary cif_core.dic
#*        You can add CIF dictionary, in a way like
#*        this:
#*        $0 --add-dictionary cif_core.dic
#*     --clear-dictionaries
#*        You can clear all dictionaries used for checking
#*        CIF file, in a way like this:
#*        $0 --clear-dictionary
#*
#**

@ARGV = getOptions(
    "--keep-tag-order"
    => sub { $keep_tag_order = 1; },
    "--sort-tags"
    => sub { $keep_tag_order = 0; },
    "-d,--dictionary"
    => sub{@dictionaries = ( &get_value )},
    "-D,--add-dictionaries"
    => \@dictionaries,
    "--clear-dictionaries"
    => sub{ @dictionaries = () },
    );

for my $dict_file_name ( @dictionaries ) {
    my $parser = new CIFParser;
    my $data = $parser->Run( $dict_file_name );

        if( defined $parser->YYData->{ERRCOUNT} &&
        $parser->YYData->{ERRCOUNT} > 0 ) {
        print STDERR "$0: $dict_file_name: ",
        $parser->YYData->{ERRCOUNT},
        " error(s) encountered while parsing CIF dictionary\n";
        ## exit -1;
        next;
	}

        canonicalize_all_names( $data );

        my( $dict_name , $dict_version , $dict_update );
        for my $dataset ( @$data ) {
            next unless $dataset->{name} eq 'on_this_dictionary' &&
                         exists $dataset->{values};
            my $values = $dataset->{values};
            die( "$0: $dict_file_name $dataset->{name}: dictionary " .
                 "'$dict_file_name' " .
                 "data_$dataset->{name} does not contain data" )
                unless defined $values;
            $dict_name = $values->{_dictionary_name};
            $dict_version = $values->{_dictionary_version};
            $dict_update = $values->{_dictionary_update};
            last;
        }
    for my $dataset ( @$data ) {
        my $values = $dataset->{values};
        my $values_name = $values->{_name};
        my $values_enum = $values->{_enumeration};
        if( (defined $values_name) && (defined $values_enum) ) {
            my @enums = @$values_enum;
            my @tag_names = @$values_name;;
            foreach( @tag_names ) {
		if( !defined $tagDicts{$_} ) {
		    $dictTags{$_} = \@enums;
                    $tagDicts{$_} = [
			$dict_file_name,
			join( ', ', @$dict_name ),
                        join( ', ', @$dict_version ),
                        join( ', ', @$dict_update )  ];
                } else {
		    print STDERR
                    "$0: WARNING, '$_' " .
                    "tag is already defined by " .
                    "'$dict_file_name' dictionary.\n";
                }
            }
        }
    }
}

sub insert_report_to_comments {
    my ($dataset, $insert_reports) = @_;
    if ( @$insert_reports > 0 ) {
        my $comments_tag = '_cod_depositor_comments';
        my $values = $dataset->{values};
        my $reports_value = join("\n\n",@$insert_reports);
        my $message =
	    "The following automatic conversions were performed:\n" .
            join( "\n", map { "" . $_ }
            CIFTagPrint::fold( 75, " +", " ", $reports_value ));

        if( exists $values->{$comments_tag} ) {
            $values->{$comments_tag}[0] .= "\n\n" . $message;
        } else {
            $values->{$comments_tag}[0] = "\n" . $message;
        }
        my $signature = $Id;
        $signature =~ s/^\$|\$$//g;
        $values->{$comments_tag}[0] .=
            "\n\n" . "Automatic conversion script" .
            "\n" . $signature;
    }
}

sub replacement_candidates($$) {
        my( $cif_value, $dict_value_list ) = @_;
        my @candidate_list = ();
        my @candidates = ();
        foreach my $dict_tag_value ( @{$dict_value_list} ) {
            if( $cif_value eq $dict_tag_value ) {
                @candidate_list = ();
                last;
            }
            if( $cif_value =~ /^\s+$dict_tag_value|$dict_tag_value\s+$/i ) {
                push( @candidates , $dict_tag_value );
                next;
            }

            my $test_dict_value = $dict_tag_value;
            $test_dict_value =~ s/[-_\s]//g;
            my $test_cif_value = $cif_value;
            $test_cif_value =~ s/[-_\s]//g;

            if( lc $test_cif_value eq lc $test_dict_value ) {
                push( @candidates , $dict_tag_value );
                next;
            }
            if( lc $cif_value eq lc $dict_tag_value ) {
                push( @candidates , $dict_tag_value );
                next;
            } else {
                push( @candidate_list , $dict_tag_value );
                next;
            }
        }
        if( scalar( @candidates ) == 1 ) {
            @candidate_list = @candidates;
        } else {
            push( @candidate_list, @candidates );
        }
        return @candidate_list
}

sub generate_comment_reports(\%) {
    my %comment_reports = %{ $_[0] };
    my @reports;
    my $report_msg;
    foreach( keys %comment_reports  ) {
	if( $comment_reports{$_} == 1 ) {
	    my( $tag, $old_val, $new_val,
	        $dic_file, $dic_name,
		$dic_version, $dic_date ) = 
		  split( '@@', $_ );
	    $report_msg =
		"'$tag' value '$old_val' " .
		"changed to '$new_val' " .
		"according to '$dic_file' " .
		"dictionary " .
		"named '$dic_name' " .
		"version $dic_version " .
		"from $dic_date.";
	} else {
	    my $count = $comment_reports{$_};
	    my $times = 
		( $count =~ /^(\d*[02-9])?1$/ ) ? "time" : "times";
	    my( $tag, $old_val, $new_val,
	        $dic_file, $dic_name,
		$dic_version, $dic_date ) = 
		  split( '@@', $_ );
	    $report_msg =
		"'$tag' value '$old_val' " .
		"changed to '$new_val' " .
		"($count $times) ".
		"according to '$dic_file' " .
		"dictionary " .
		"named '$dic_name' " .
		"version $dic_version " .
		"from $dic_date.";    
	}
	push( @reports, $report_msg );
    }
    return @reports;
}

sub generate_warning_reports(\%) {
    my %warning_reports = %{ $_[0] };
    my @warnings;
    my $warning_msg;
    foreach( keys %warning_reports ) {
	if( $warning_reports{$_} == 1 ) {
	    my( $tag, $tag_value, $dict_values,
	        $dic_file, $dic_name,
		$dic_version, $dic_date ) = 
		  split( '@@', $_ );
	    $warning_msg = 
		"'$tag' value '$tag_value' " .
                "should be one of these: [" .
		"$dict_values ] " .
		"according to '$tagDicts{$tag}[0]' " .
                "dictionary " .
                "named '$tagDicts{$tag}[1]' " .
                "version $tagDicts{$tag}[2] " .
                "from $tagDicts{$tag}[3].";
	} else {
	    my $count = $warning_reports{$_};
	    my $times = 
		( $count =~ /^(\d*[02-9])?1$/ ) ? "time" : "times";
	    my( $tag, $tag_value, $dict_values,
	        $dic_file, $dic_name,
		$dic_version, $dic_date ) = 
		  split( '@@', $_ );
	    $warning_msg =
		"'$tag' values '$tag_value' " .
                "should be one of these: [" .
		"$dict_values ] " .
		"(repeated $count $times) " .
		"according to '$tagDicts{$tag}[0]' " .
                "dictionary " .
                "named '$tagDicts{$tag}[1]' " .
                "version $tagDicts{$tag}[2] " .
                "from $tagDicts{$tag}[3].";
	}
	push( @warnings, $warning_msg );
    }
    return @warnings;
}    
			    



my @dictionary_tags = ( @CIFDictTags::tag_list, @CIFCODTags::tag_list );
my %dictionary_tags = map { $_, $_ } @dictionary_tags;

@ARGV = ("-") unless @ARGV;
for my $filename ( @ARGV ) {
    my $parser = new CIFParser;
    my $data = $parser->Run( $filename );

    if( defined $parser->YYData->{ERRCOUNT} &&
        $parser->YYData->{ERRCOUNT} > 0 ) {
        print STDERR "$0: $filename: ",
        $parser->YYData->{ERRCOUNT},
        " error(s) encountered while parsing CIF file\n";
        ## exit -1;
        next
    }
    my %reports;
    my %warnings;
    canonicalize_all_names( $data );
    for my $dataset (@$data) {
	my $report_msg;
	my @insert_reports = ();
	my @warning = ();
        my $values = $dataset->{values};
        my $tags = $dataset->{tags};
        foreach my $tag ( @$tags ) {
	    if( defined $values->{$tag} ) {
		foreach my $tag_value ( @{$values->{$tag}} ) {
		    if( $tag_value =~ /^\.|\?$/ ) {
			next;
		    }
                    if( exists $dictTags{$tag} ) {
                        my @replacement_list =
			  replacement_candidates
                            ( $tag_value , $dictTags{$tag} );
                        if(! @replacement_list ) {
			    next;
                        } elsif( scalar( @replacement_list ) == 1 ) {
			    my $new_value = shift( @replacement_list );
			    my $old_value = $tag_value;
			    $tag_value = $new_value;
			    my $report_key = 
				$tag .'@@'. $old_value .'@@' .
				$new_value .'@@'. 
				$tagDicts{$tag}[0] .'@@'. 
				$tagDicts{$tag}[1] .'@@'.
				$tagDicts{$tag}[2] .'@@'.
				$tagDicts{$tag}[3] .'@@';
			    if(! exists $reports{$report_key} ) {
				$reports{$report_key} = 0;
			    }
			    $reports{$report_key} ++;
			} else {
			    my $dict_values = 
				join( ", " , @replacement_list );
			    my $warning_key = 
				$tag .'@@'. $tag_value .'@@' .
				$dict_values .'@@' .
				$tagDicts{$tag}[0] .'@@'. 
				$tagDicts{$tag}[1] .'@@'.
				$tagDicts{$tag}[2] .'@@'.
				$tagDicts{$tag}[3] .'@@';
			    if(! exists $warnings{$warning_key} ) {
				$warnings{$warning_key} = 0;
			    }
			    $warnings{$warning_key} ++;
			}
		    }
		}
		
		# call warnings
		# call notes
	    }
	}
	@insert_reports = generate_comment_reports( %reports );
	insert_report_to_comments( $dataset, \@insert_reports );
	foreach( @insert_reports ) {
	    print STDERR "$0: $filename: NOTE, $_\n";
	    next;
	}
	@warning = generate_warning_reports( %warnings );
	foreach( @warning ){
	    print STDERR "$0: $filename: WARNING, $_\n";
	    next;
	}
        print_cif( $dataset, {
	    exclude_misspelled_tags => 0,
            preserve_loop_order => 1,
            fold_long_fields => 0,
            dictionary_tags => \%dictionary_tags,
            dictionary_tag_list => \@dictionary_tags,
            keep_tag_order => $keep_tag_order,
        });
    }
}
