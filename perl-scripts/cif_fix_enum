#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;

#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Fixes enumeration values in CIF file against CIF dictionaries.
#**

use strict;
use warnings;
use lib "./lib/perl5";
use lib "./CIFParser";
use CIFDictTags;
use CIFCODTags;
use CIFParser;
use CIFTagCanonicalNames;
use ShowStruct;
use SOptions;
use CIFTagPrint;
use CIFTagManage;
use SUsage;

my $dictParsed = [];
my $parser = new CIFParser;
my @dictionaries = ();
my %dictTags;
my %tagDicts;

my $Id = '$Id$';
my $keep_tag_order = 0;

my %default_enums = (
    '_atom_site_adp_type'                    => [ "Uani", "Uiso", "Uovl", "Umpe", 
                                                  "Bani", "Biso", "Bovl" ],
    '_atom_site_calc_flag'                   => [ "d", "calc", "c", "dum" ],
    '_atom_site_refinement_flags_adp'        => [ ".", "T", "U", "TU" ], 
    '_atom_site_refinement_flags_occupancy'  => [ ".", "P" ],
    '_atom_site_refinement_flags_posn'       => [ ".", "D", "G", "R", "S", "DG", 
                                                  "DR", "DS", "GR", "GS", "RS", 
                                                  "DGR", "DGS", "DRS", "GRS", "DGRS" ],
    '_atom_site_refinement_flags'            => [ ".", "S", "G", "R", "D", "T", "U", "P" ],
    '_atom_sites_solution_hydrogens'         => [ "difmap", "vecmap", "heavy", "direct", "geom", 
                                                  "disper", "isomor", "notdet", "dual", "other" ],
    '_atom_sites_solution_primary'           => [ "difmap", "vecmap", "heavy", "direct", "geom", 
                                                  "disper", "isomor", "notdet", "dual", "other" ],
    '_atom_sites_solution_secondary'         => [ "difmap", "vecmap", "heavy", "direct", "geom", 
                                                  "disper", "isomor", "notdet", "dual", "other" ],
    '_atom_site_thermal_displace_type'       => [ "Uani", "Uiso", "Uovl", "Umpe", 
                                                  "Bani", "Biso", "Bovl" ],
    '_chemical_absolute_configuration'       => [ "rm", "ad", "rmad", "syn", "unk", "." ],
    '_chemical_conn_bond_type'               => [ "sing", "doub", "trip", "quad", 
                                                  "arom", "poly", "delo", "pi" ],
    '_chemical_enantioexcess_bulk_technique' => [ "OA", "CD", "EC", "other" ],
    '_chemical_enantioexcess_crystal_technique' => [ "CD", "EC", "other" ],
    '_citation_coordinate_linkage'           => [ "no", "n", "yes", "y" ],
    '_diffrn_radiation_probe'                => [ "x-ray", "neutron", "electron", "gamma" ],
    '_diffrn_radiation_wavelength_determination' => [ "fundamental", "estimated", "refined" ],
    '_diffrn_radiation_xray_symbol'          => [ "K-L~3~", "K-L~2~", "K-M~3~", "K-L~2,3~" ],
    '_diffrn_refln_scan_mode_backgd'         => [ "st", "mo" ],
    '_diffrn_refln_scan_mode'                => [ "om", "ot", "q" ],
    '_diffrn_source_target'                  => [ "H", "He", "Li", "Be", "B", "C", "N", "O",
                                                  "F", "Ne", "Na", "Mg", "Al", "Si", "P", "S",
                                                  "Cl", "Ar", "K", "Ca", "Sc", "Ti", "V", "Cr",
                                                  "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "Ga",
                                                  "Ge", "As", "Se", "Br", "Kr", "Rb", "Sr", "Y",
                                                  "Zr", "Nb", "Mo", "Tc", "Ru", "Rh", "Pd", "Ag",
                                                  "Cd", "In", "Sn", "Sb", "Te", "I", "Xe", "Cs",
                                                  "Ba", "La", "Ce", "Pr", "Nd", "Pm", "Sm", "Eu",
                                                  "Gd", "Tb", "Dy", "Ho", "Er", "Tm", "Yb", "Lu",
                                                  "Hf", "Ta", "W", "Re", "Os", "Ir", "Pt", "Au", 
                                                  "Hg", "Tl", "Pb", "Bi", "Po", "At", "Rn", "Fr",
                                                  "Ra", "Ac", "Th", "Pa", "U", "Np", "Pu", "Am", 
                                                  "Cm", "Bk", "Cf", "Es", "Fm", "Md", "No", "Lr" ],
    '_exptl_absorpt_correction_type'         => [ "analytical", "cylinder", "empirical", "gaussian",
                                                  "integration", "multi-scan", "none", "numerical",
                                                  "psi-scan", "refdelf", "sphere" ],
    '_exptl_crystal_colour_lustre'           => [ "metallic", "dull", "clear" ],
    '_exptl_crystal_colour_modifier'         => [ "light", "dark", "whitish", "blackish", 
                                                  "grayish", "brownish", "reddish", "pinkish", 
                                                  "orangish", "yellowish", "greenish", "bluish" ],
    '_exptl_crystal_colour_primary'          => [ "colourless", "white", "black", "gray", 
                                                  "brown", "red", "pink", "orange", "yellow", 
                                                  "green", "blue", "violet" ],
    '_geom_angle_publ_flag'                  => [ "no", "n", "yes", "y" ],
    '_geom_bond_publ_flag'                   => [ "no", "n", "yes", "y" ],
    '_geom_contact_publ_flag'                => [ "no", "n", "yes", "y" ],  
    '_geom_hbond_publ_flag'                  => [ "no", "n", "yes", "y" ],
    '_geom_torsion_publ_flag'                => [ "no", "n", "yes", "y" ],
    '_publ_body_element'                     => [ "section", "subsection", "subsubsection",
                                                  "appendix", "footnote" ],
    '_publ_body_format'                      => [ "ascii", "cif", "latex", "rtf", 
                                                  "sgml", "tex", "troff" ],
    '_publ_manuscript_incl_extra_defn'       => [ "no", "n", "yes", "y" ],
    '_publ_requested_category'               => [ "FA", "FI", "FO", "FM", "CI",
                                                  "CO", "CM", "EI", "EO", "EM",
                                                  "QI", "QO", "QM", "AD", "SC" ],
    '_refine_ls_hydrogen_treatment'          => [ "refall", "refxyz", "refU", "noref",
                                                  "constr", "mixed", "undef" ],
    '_refine_ls_matrix_type'                 => [ "full", "fullcycle", "atomblock",
                                                  "userblock", "diagonal", "sparse" ],
    '_refine_ls_structure_factor_coef'       => [ "F", "Fsqd", "Inet" ],
    '_refine_ls_weighting_scheme'            => [ "sigma", "unit", "calc" ],
    '_refln_include_status'                  => [ "o", "<", "-", "x", "h", "l" ],
    '_refln_observed_status'                 => [ "o", "<", "-", "x", "h", "l" ],
    '_refln_refinement_status'               => [ "incl", "excl", "extn" ],
    '_space_group_crystal_system'            => [ "triclinic", "monoclinic", "orthorhombic", 
                                                  "tetragonal", "trigonal", "hexagonal", "cubic" ],
    '_symmetry_cell_setting'                 => [ "triclinic", "monoclinic", "orthorhombic",
                                                  "tetragonal", "rhombohedral", "trigonal", 
                                                  "hexagonal", "cubic" ],
    );
my $default_enums = \%default_enums;

#*Usage:
#*      cif_fix_enum [options] COD-cif-dir/
#*
#*Options:
#*     --dictionary cif_core.dic
#*        Any valid CIF file, with CIF dictionary (according to DDL2).
#*        You can define any number of CIF dictionaries, in a way like
#*        this:
#*        $0 --dictionary cif_core.dic --dictionary cod_core.dic
#*     --add-dictionary cif_core.dic
#*        You can add CIF dictionary, in a way like
#*        this:
#*        $0 --add-dictionary cif_core.dic
#*     --clear-dictionaries
#*        You can clear all dictionaries used for checking
#*        CIF file, in a way like this:
#*        $0 --clear-dictionary
#*
#**

@ARGV = getOptions(
    "--keep-tag-order"
    => sub { $keep_tag_order = 1; },
    "--sort-tags"
    => sub { $keep_tag_order = 0; },
    "-d,--dictionary"
    => sub{ @dictionaries = &get_value; },
    "-D,--add-dictionaries" 
    => sub{ push( @dictionaries, &get_value ); },
    "--clear-dictionaries"
    => sub{ @dictionaries = (); },
    );

if( @dictionaries ) {
    for my $dict_file_name ( @dictionaries ) {
        my $parser = new CIFParser;
        my $data = $parser->Run( $dict_file_name );
        
        if( defined $parser->YYData->{ERRCOUNT} &&
            $parser->YYData->{ERRCOUNT} > 0 ) {
            print STDERR "$0: $dict_file_name: ",
            $parser->YYData->{ERRCOUNT},
            " error(s) encountered while parsing CIF dictionary\n";
            ## exit -1;
            next;
        }
        
        canonicalize_all_names( $data );
        
        my( $dict_name , $dict_version , $dict_update );
        for my $dataset ( @$data ) {
            next unless $dataset->{name} eq 'on_this_dictionary' &&
                exists $dataset->{values};
            my $values = $dataset->{values};
            die( "$0: $dict_file_name $dataset->{name}: dictionary " .
                 "'$dict_file_name' " .
                 "data_$dataset->{name} does not contain data" )
            unless defined $values;
            $dict_name = $values->{_dictionary_name};
            $dict_version = $values->{_dictionary_version};
            $dict_update = $values->{_dictionary_update};
            last;
        }
        for my $dataset ( @$data ) {
            my $values = $dataset->{values};
            my $values_name = $values->{_name};
            my $values_enum = $values->{_enumeration};
            if( (defined $values_name) && (defined $values_enum) ) {
                my @enums = @$values_enum;
                my @tag_names = @$values_name;
                foreach( @tag_names ) {
                    if( !defined $tagDicts{$_} ) {
                        $dictTags{$_} = \@enums;
                        $tagDicts{$_} = [
                            $dict_file_name,
                            defined $dict_name ?
                            join( ', ', @$dict_name ) : undef,
                            defined $dict_version ?
                            join( ', ', @$dict_version ) : undef,
                            defined $dict_update ?
                            join( ', ', @$dict_update ) : undef
                            ];
                    } else {
                        print STDERR
                            "$0: WARNING, '$_' " .
                            "tag is already defined by " .
                            "'$dict_file_name' dictionary.\n";
                    }
                }
            }
        }
    }
} else {
    my $dict_file_name = 'the built-in table from CIF Core'; 
    my $dict_name = 'cif_core.dic';
    my $dict_version = '2.4.1';
    my $dict_update = '2010-06-29';
    foreach my $tag( keys %default_enums ) {
        my $enums = $default_enums{$tag};
        $dictTags{$tag} = $enums;        
        $tagDicts{$tag} = [ $dict_file_name, $dict_name, 
                            $dict_version, $dict_update ];
    }
}

# to print out all tags and its enum values from the given dictionary
#foreach( keys %dictTags ) {
#    print "'$_' => [ ";
#    foreach( @{ $dictTags{$_} } ){
#        print '"' . $_ . '"' .', ';
#    }
#    print "\n";
#}
#exit 0;

sub insert_report_to_comments {
    my ($dataset, $insert_reports) = @_;
    if ( @$insert_reports > 0 ) {
        my $comments_tag = '_cod_depositor_comments';
        my $values = $dataset->{values};
        my $reports_value = join("\n\n",@$insert_reports);
        my $title =
	    "The following automatic conversions were performed:\n" .
            join( "\n", map { "" . $_ }
                  CIFTagPrint::fold( 75, " +", " ", $reports_value ));
        
        if( exists $values->{$comments_tag} ) {
            $values->{$comments_tag}[0] .= "\n\n" . $title;
        } else {
            $values->{$comments_tag}[0] = "\n" . $title;
        }
        my $signature = $Id;
        $signature =~ s/^\$|\$$//g;
        $values->{$comments_tag}[0] .=
            "\n\n" . "Automatic conversion script" .
            "\n" . $signature;
    }
}

sub replacement_candidates($$) {
    my( $cif_value, $dict_value_list ) = @_;
    my @candidate_list = ();
    foreach my $dict_tag_value ( @{$dict_value_list} ) {
        if( $cif_value eq $dict_tag_value ) {
            return ();
        }
        my $test_dict_value = $dict_tag_value;
        $test_dict_value =~ s/[-_\s]//g;
        my $test_cif_value = $cif_value;
        $test_cif_value =~ s/[-_\s]//g;
        
        if( lc $test_cif_value eq lc $test_dict_value ) {
            push( @candidate_list, $dict_tag_value );
            next;
        }
        if( lc $cif_value eq lc $dict_tag_value ) {
            push( @candidate_list, $dict_tag_value );
            next;
        }
    }
    if( scalar( @candidate_list ) == 1 ) {
        return @candidate_list;
    } else {
        return @{$dict_value_list};
    }
}

sub make_count($$) {
    my %notes_warnings = %{ $_[0] };
    my @messages = @{ $_[1] };
    my @reports;
    foreach my $message( @messages ) {
	if(! exists $notes_warnings{$message} ) {
	    die( "$0: Error while counting " .
                 "'$message' audit message.\n"  );
	}
	if( exists $notes_warnings{$message}) {
            my $count = $notes_warnings{$message};
            my $times =
                ( $count =~ /^(\d*[02-9])?1$/ ) ? "time" : "times";
            if( $notes_warnings{$message} == 1 ) {
                $message .= ".";
            } else {
                $message .= " ($count $times).";
            }
            push( @reports, $message );
	}
    }
    return @reports;
}

my @dictionary_tags = ( @CIFDictTags::tag_list, @CIFCODTags::tag_list );
my %dictionary_tags = map { $_, $_ } @dictionary_tags;

@ARGV = ("-") unless @ARGV;
for my $filename ( @ARGV ) {
    my $parser = new CIFParser;
    my $data = $parser->Run( $filename );
    
    if( defined $parser->YYData->{ERRCOUNT} &&
        $parser->YYData->{ERRCOUNT} > 0 ) {
        print STDERR "$0: $filename: ",
        $parser->YYData->{ERRCOUNT},
        " error(s) encountered while parsing CIF file\n";
        ## exit -1;
        next
    }
    canonicalize_all_names( $data );
    for my $dataset (@$data) {
        my %reports;
	my @uniq_messages;
	my @insert_reports = ();
	my $values = $dataset->{values};
        my $tags = $dataset->{tags};
        foreach my $tag ( @$tags ) {
	    if( defined $values->{$tag} ) {
		foreach my $tag_value ( @{$values->{$tag}} ) {
		    if( $tag_value =~ /^\.|\?$/ ) {
			next;
		    }
                    if( exists $dictTags{$tag} ) {
                        my $message_key;
                        my @replacement_list =
                            replacement_candidates( $tag_value,
                                                    $dictTags{$tag} );
                        if(! @replacement_list ) {
			    next;
                        } elsif( scalar( @replacement_list ) == 1 ) {
			    my $new_value = shift( @replacement_list );
			    my $old_value = $tag_value;
			    $tag_value = $new_value;
			    $message_key =
				"NOTE, '$tag' value '$old_value' " .
				"changed to '$new_value' " .
				"according to $tagDicts{$tag}[0] " .
				"dictionary" .
				(defined $tagDicts{$tag}[1] ? 
                                 " named '$tagDicts{$tag}[1]'" : "") .
                                 (defined $tagDicts{$tag}[2] ? 
                                  " version $tagDicts{$tag}[2]" : "") .
                                  (defined $tagDicts{$tag}[3] ?
                                   " from $tagDicts{$tag}[3]" : "");
			} else {
			    my $dict_values =
				join( ", ", @replacement_list );
			    $message_key =
				"WARNING, '$tag' value '$tag_value' " .
				"should be one of these: [" .
				"$dict_values] " .
				"according to '$tagDicts{$tag}[0]' " .
				"dictionary" .
                                (defined $tagDicts{$tag}[1] ?
                                 " named '$tagDicts{$tag}[1]'" : "") .
                                 (defined $tagDicts{$tag}[2] ?
                                  " version $tagDicts{$tag}[2]" : "") .
                                  (defined $tagDicts{$tag}[3] ?
                                   " from $tagDicts{$tag}[3]" : "");
			}
			if(! exists $reports{$message_key} ) {
			    $reports{$message_key} = 0;
			    push( @uniq_messages, $message_key );
			}
			$reports{$message_key} ++;
		    }
		}
	    }
	}
	my @report_messages =
	    make_count( \%reports , \@uniq_messages );
	foreach my $report ( @report_messages ) {
	    print STDERR "$0: $filename: $report\n";
	    if( $report =~ /^(NOTE,\s+)(.+)$/ ) {
		my $comment_message = $2;
		push( @insert_reports, $comment_message );
	    }
	}
	insert_report_to_comments( $dataset, \@insert_reports );
        print_cif( $dataset, {
	    exclude_misspelled_tags => 0,
            preserve_loop_order => 1,
            fold_long_fields => 0,
            dictionary_tags => \%dictionary_tags,
            dictionary_tag_list => \@dictionary_tags,
            keep_tag_order => $keep_tag_order,
        });
    }
}
