#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;

#------------------------------------------------------------------------------
#$Author: adriana $
#$Date: 2010-05-30 08:18:18 +0300 (Sun, 30 May 2010) $
#$Revision: 1280 $
#$URL: svn://vartai.ibt.lt/cif-tools/trunk/perl-scripts/cif_fix_enum $
#------------------------------------------------------------------------------
#*
#  Fixes enumeration values in CIF file against CIF dictionaries.
#**

use strict;
use warnings;
use lib "./lib/perl5";
use lib "./CIFParser";
use CIFDictTags;
use CIFCODTags;
use CIFParser;
use CIFTagCanonicalNames;
use ShowStruct;
use SOptions;
use CIFTagPrint;
use CIFTagManage;
use SUsage;

my $dictParsed = [];
my $parser = new CIFParser;
my @dictionaries = ();
my %dictTags;
my %tagDicts;

my $Id = '$Id: cif_fix_enum 1280 2010-05-30 12:51:13Z adriana $';
my $keep_tag_order = 0;

#*Usage:
#*      cif_fix_enum [options] COD-cif-dir/
#*
#*Options:
#*     --dictionary cif_core.dic
#*        Any valid CIF file, with CIF dictionary (according to DDL2).
#*        You can define any number of CIF dictionaries, in a way like 
#*        this:
#*        $0 --dictionary cif_core.dic --dictionary cod_core.dic
#*     --add-dictionary cif_core.dic
#*        You can add CIF dictionary, in a way like 
#*        this:
#*        $0 --add-dictionary cif_core.dic
#*     --clear-dictionaries
#*        	  You can clear all dictionaries used for checking
#*        	  CIF file, in a way like this:
#*        	  $0 --clear-dictionary
#*
#**

@ARGV = getOptions(
    "--keep-tag-order" 
    => sub { $keep_tag_order = 1; },
    "--sort-tags"      
    => sub { $keep_tag_order = 0; },
    "-d,--dictionary"
    => sub{@dictionaries = ( &get_value )}, 
    "-D,--add-dictionaries"
    => \@dictionaries,
    "--clear-dictionaries"
    => sub{ @dictionaries = () },
    );

for my $dict_file_name ( @dictionaries ) {
    my $parser = new CIFParser;
    my $data = $parser->Run( $dict_file_name );
    
        if( defined $parser->YYData->{ERRCOUNT} &&
        $parser->YYData->{ERRCOUNT} > 0 ) {
        print STDERR "$0: $dict_file_name: ",
        $parser->YYData->{ERRCOUNT},
        " error(s) encountered while parsing CIF dictionary\n";
        ## exit -1;
        next;
    }
        
        canonicalize_all_names( $data );
        
        my $dict_name;
        my $dict_version;
        my $dict_update;
        for my $dataset ( @$data ) {
        	next unless $dataset->{name} eq 'on_this_dictionary' &&
        		 		exists $dataset->{values};
        	my $values = $dataset->{values};
        	die( "$0: $dict_file_name $dataset->{name}: dictionary " .
        		 "'$dict_file_name' " .
        		 "data_$dataset->{name} does not contain data" ) 
        		unless defined $values;
        	$dict_name = $values->{_dictionary_name};
        	$dict_version = $values->{_dictionary_version};
        	$dict_update = $values->{_dictionary_update};
        	last;
        }
        
    for my $dataset ( @$data ) {
        my $values = $dataset->{values};
        	my $values_name = $values->{_name};
        my $values_enum = $values->{_enumeration};
        if( (defined $values_name) && (defined $values_enum) ) {
            my @enums = @$values_enum;
            my @tag_names = @$values_name;;
            foreach( @tag_names ) {
        			if( !defined $tagDicts{$_} ) {
        			    $dictTags{$_} = \@enums;
        			    $tagDicts{$_} = [ 
        					$dict_file_name, 
        					@$dict_name, 
        					@$dict_version, 
        					@$dict_update  ];
        			} else {
        				print STDERR  
        					"$0: WARNING, '$_' " .
                        "tag is already defined by " . 
                        "'$dict_file_name' dictionary.\n";
        			}
            }
        }
    }
}

sub insert_report_to_comments {
    my ($dataset, $insert_reports) = @_;
    if ( @$insert_reports > 0 ) {
        my $comments_tag = '_cod_depositor_comments';
        my $values = $dataset->{values};
        my $reports_value = join("\n\n",@$insert_reports);
        my $message =
                "The following automatic conversions were performed:\n" .
                join( "\n", map { "" . $_ }
        	    CIFTagPrint::fold( 75, " +", " ", $reports_value ));

        if( exists $values->{$comments_tag} ) {
            $values->{$comments_tag}[0] .= "\n\n" . $message;
        } else {
            $values->{$comments_tag}[0] = "\n" . $message;
        	}
        my $signature = $Id;
        $signature =~ s/^\$|\$$//g;
        $values->{$comments_tag}[0] .= 
            "\n\n" . "Automatic conversion script" .
            "\n" . $signature;
    }
}

sub replacement_candidates($$)
{
        my( $cif_value, $dict_value_list ) = @_;
        my @candidate_list = ();
        my @lc_candidates = ();
        foreach my $dict_tag_value ( @{$dict_value_list} ) {
        	if( $cif_value eq $dict_tag_value ) {
        		@candidate_list = ();
        		last;
        	}
        	if( $cif_value =~ /^\s+$dict_tag_value|$dict_tag_value\s+$/i ) {
        		push( @lc_candidates , $dict_tag_value );
        		next;
        	}
        	if( lc $cif_value eq lc $dict_tag_value ) {
        		push( @lc_candidates , $dict_tag_value );
        		next;
        	} 
            #elsif( lc $cif_value ne lc $dict_tag_value )  {
        	#	push( @candidate_list , $dict_tag_value );
        	#	next;	
        	#}	
            if( $dict_tag_value =~ /^(\w+)[-](\w+)$/ ) {
                my $word = "$1" . "$2";
                if( $cif_value eq $word ) {
                    push( @lc_candidates , $dict_tag_value );
                    next;
                } elsif( $cif_value ne $word ) {
                    push( @candidate_list , $dict_tag_value );
                    next;
                } 
            } else {
                push( @candidate_list , $dict_tag_value );
                next;
            }
        }    
        if( scalar( @lc_candidates ) == 1 ) {
        	@candidate_list = @lc_candidates;
        } else {
        	push( @candidate_list, @lc_candidates );
        }
        return @candidate_list
}

my @dictionary_tags = ( @CIFDictTags::tag_list, @CIFCODTags::tag_list );
my %dictionary_tags = map { $_, $_ } @dictionary_tags;

@ARGV = ("-") unless @ARGV;
for my $filename ( @ARGV ) {
    my $parser = new CIFParser;
    my $data = $parser->Run( $filename );
    
    if( defined $parser->YYData->{ERRCOUNT} &&
        $parser->YYData->{ERRCOUNT} > 0 ) {
        print STDERR "$0: $filename: ",
        $parser->YYData->{ERRCOUNT},
        " error(s) encountered while parsing CIF file\n";
        ## exit -1;
        next
    }
    
    canonicalize_all_names( $data );
        for my $dataset (@$data) {
        	my @insert_reports = ();
        	my $values = $dataset->{values};
        	my $tags = $dataset->{tags};
        	foreach my $tag ( @$tags ) {
        		if( defined $values->{$tag} ) {
                foreach my $tag_value ( @{$values->{$tag}} ) {
        				if( $tag_value =~ /^\.|\?$/ ) {
        				    next;
        				}
        				if( exists $dictTags{$tag} ) {
        					my @replacement_list = 
        					  replacement_candidates
        					  	( $tag_value , $dictTags{$tag} );
        					if(! @replacement_list ) {
        						next;
        					} elsif( scalar( @replacement_list ) == 1 ) {
        						my $new_value = shift( @replacement_list );
        						my $report_msg = 
        							"'$tag' value '$tag_value' " .
        							"changed to '$new_value' " .
        							"according to '$tagDicts{$tag}[0]' " .
        							"dictionary " .
        							"named '$tagDicts{$tag}[1]' " .
        							"version $tagDicts{$tag}[2] " .
        							"from $tagDicts{$tag}[3].";
        						push (@insert_reports, $report_msg);
                                print STDERR 
        							"$0: $filename: NOTE, $report_msg\n";
        						$tag_value = $new_value;
        						next;
        					} else {
        						print STDERR  
        							"$0: $filename: WARNING, " .
        							"'$tag' value '$tag_value' " .
        							"should be one of these: [" .
                                    join( ", " , @replacement_list ) . "] " .
        							"according to '$tagDicts{$tag}[0]' " .
        							"dictionary " .
        							"named '$tagDicts{$tag}[1]' " .
        							"version $tagDicts{$tag}[2] " .
        							"from $tagDicts{$tag}[3].\n";
        						next;
        					}
        				}	
        			}
        		}
        	}
        	insert_report_to_comments( $dataset, \@insert_reports ); 
        	print_cif( $dataset, {
            exclude_misspelled_tags => 0,
            preserve_loop_order => 1,
            fold_long_fields => 0,
            dictionary_tags => \%dictionary_tags,
            dictionary_tag_list => \@dictionary_tags,
            keep_tag_order => $keep_tag_order,
        	});
        }
}
