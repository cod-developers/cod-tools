#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Compute the structure factors from CIF files.
#**

# The implementation in this programm follows the principles published
# in:

# (Yvon1977) Yvon, K.; Jeitschko, W. & ParthÃ©, E. it LAZY PULVERIX, a
# computer program, for calculating X-ray and neutron diffraction
# powder patterns Journal of Applied Crystallography, 1977, 10, 73-74
# http://dx.doi.org/10.1107/S0021889877012898

use strict;
use lib "./lib/perl5";
use lib "./CIFParser";
use lib "./CCIFParser";
use lib "./CIFTags";
use lib ".";
use File::Basename;
use CIFParser;
use CCIFParser;
use Spacegroups::SpacegroupNames;
use Spacegroups::SymopParse;
use Spacegroups::SymopLookup;
use SOptions;
use SUsage;

use Fractional;

my $use_parser = "c";
my $dump_xyz_coordinates = 0;

#* USAGE:
#*     $0 --options input1.cif input*.cif
#* 
#* OPTIONS:
#*    --use-perl-parser  Use development CIF parser written in Perl
#*    --use-c-parser     Use faster C/Yacc CIF parser (default)
#*
#*    --help,--usage         Print a short usage message (this message) and exit.
#**

@ARGV = getOptions( 
    "--use-perl-parser"  => sub{ $use_parser = "perl" },
    "--use-c-parser"     => sub{ $use_parser = "c" },

    "--options"          => sub { 
        print "$0: The '--options' option is a placehoder.\n";
        print "$0: It should be replaced by one of the following options:\n";
        ## SUsage::usage;
        open( SCRIPT, $0 ) or die $!;
        while( <SCRIPT> ) {
            if( /^#\*\s+OPTIONS:/../^#\*\*/ ) {
                s/^#\*\s+OPTIONS://;
                s/^#\*\*?\s+//;
                print;
            }
        }
        close( SCRIPT );
        exit
    },
    "--dump-xyz-coordinates"    => sub { $dump_xyz_coordinates = 1 },
    "--help,--usage"     => sub { SUsage::usage; exit },
);

#==============================================================================#
# Forward subroutine definitions:
sub mat_vect_mul( $$ );
sub get_unit_cell( $$ );


@ARGV = ( "-" ) unless @ARGV;

for my $filename (@ARGV) {

    my( $data, $error_count );

    if( $use_parser eq "perl" ) {
        my $parser = new CIFParser;

        $data = $parser->Run( $filename );

        if( defined $parser->YYData->{ERRCOUNT} ) {
            $error_count = $parser->YYData->{ERRCOUNT};
        }
    } else {
        ( $data, $error_count ) = CCIFParser::parse( $filename );
    }

    if( defined $error_count && $error_count > 0 ) {
        print STDERR "$0: ", $error_count,
        " error(s) encountered while parsing file '${filename}'\n";
        die;
    }

    if( !@$data || !defined $data->[0] || !defined $data->[0]{name} ) {
        warn( "file '$filename' seems to be empty" );
        next;
    }
    
    for my $datablock (@$data) {
        
        my @cell = get_unit_cell( $datablock, $filename );
        my $f2o = symop_ortho_from_fract( @cell );
        ## print "@{$f2o->[0]}\n";
        
        my $atoms = atoms_from_cif( $datablock, $f2o );
      
        if( $dump_xyz_coordinates ) { 
            print $#$atoms+1, "\n";
            print "$datablock->{name}\n";
            foreach my $atom (@$atoms) {
                printf "%2s %.5f %.5f %.5f\n", $atom->{chemical_type}, 
                @{$atom->{coordinates_ortho}};
                ## print ">>> $atom->{occupancy}\n";
                ## print ">>> $atom->{B_factor}\n";
                ## print ">>> $atom->{U_value_of_B_factor}\n";
                ## print $atom->{aniso_value_Uij}->[0] ? 
                ##    ">>> @{$atom->{aniso_value_Uij}}\n" : "Empty\n";               
            }
        }
    }
}


#===============================================================#
# Extract unit cell angles and lengths.
#
# Accepts
#     values - a hash where a data from the CIF file is stored
# Returns
#     cell - an array  with stored information.

sub get_unit_cell($$)
{
    my( $datablock, $filename ) = @_;

    my $values = $datablock->{values};
    my $dataname = $datablock->{name};

    my @cell;

    for my $cif_tag (qw(_cell_length_a
                        _cell_length_b
                        _cell_length_c
                        )) {
        push(@cell, $values->{$cif_tag}[0]);
        $cell[-1] =~ s/\(\d+\)$//;
    }

    for my $cif_tag (qw(_cell_angle_alpha
                        _cell_angle_beta
                        _cell_angle_gamma
                        )) {
        if( exists $values->{$cif_tag} ) {
            push( @cell, $values->{$cif_tag}[0] );
            $cell[-1] =~ s/\(\d+\)$//;
        } else {
            warning( $0, $filename, $dataname,
                     "cell angle '$cif_tag' not present -- " .
                     "taking default value 90 degress." );
            push( @cell, 90 );
        }
    }

    return @cell;
}

#===============================================================#
# Multiplies an ortho matrix with a vector.

# my $ortho = [
#     [ o11 o12 o13 ]
#     [ 0   o22 o23 ]
#     [ 0   0   o33 ]
# ]
#

sub mat_vect_mul($$)
{
    my($matrix, $vector) = @_;

    my @new_coordinates;

    for(my $i = 0; $i < @{$vector}; $i++)
    {
        $new_coordinates[$i] = 0;
        for(my $j = 0; $j < @{$vector}; $j++)
        {
            $new_coordinates[$i] += ${$matrix}[$i][$j] * ${$vector}[$j];
        }
    }

    if( @$vector == 3 && @$matrix == 4 ) {
        $new_coordinates[0] += $matrix->[0][3];
        $new_coordinates[1] += $matrix->[1][3];
        $new_coordinates[2] += $matrix->[2][3];
    }

    return wantarray ? @new_coordinates : \@new_coordinates;
}

#-------------------------------------------------------------------#
# Remove the standart deviation (standard uncertainties) components
# from input data; 
# Parameters: reference to an array with scalar
# values; for ex.: 0.21582(8) 
# Return: reference to an array without
# std. deviations; for ex.: 0.21582

sub remove_standard_uncertainties
{
    my ($input) = @_;
    return [ map { my $value = $_;
                   $value =~ s/\(\d+\)//; $value } @{$input} ];
}

#--------------------------------------------------------------------#
# Function of extracting atom information from the CIF file.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Returns:
# @atoms = (
#           # [0]
#           {
#               site_label => "O10",
#               chemical_type => "O",
#               coordinates_fract" => [0.1, 0.2, 0.3],
#           },
#           # [1]
#           {
#               site_label => "C11",
#               chemical_type => "C",
#               coordinates_fract" => [0.2, 0.25, 0.35],
#           },
#  );   

sub atoms_from_cif 
{ 
    my ($datablock, $f2o) = @_;
    my @atoms;
    my $datablock_values = $datablock->{values};
    my @xyz_arrays =
        ( remove_standard_uncertainties( 
              $datablock_values->{_atom_site_fract_x} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_fract_y} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_fract_z} ) );    
    my $occupancy = 
        remove_standard_uncertainties( 
            $datablock_values->{_atom_site_occupancy} );
    my $thermal_parameter_B = 
        remove_standard_uncertainties( 
            $datablock_values->{_atom_site_b_iso_or_equiv} );
    my $squared_displacement_U = 
        remove_standard_uncertainties( 
            $datablock_values->{_atom_site_u_iso_or_equiv} );
    my @anisotrophic_U_ij_values = 
        ( remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_11} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_22} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_33} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_23} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_13} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_12} ) );
    
    for my $i (0..$#{$datablock_values->{_atom_site_label}}) {
        my $fract_xyz = [ $xyz_arrays[0]->[$i],
                          $xyz_arrays[1]->[$i],
                          $xyz_arrays[2]->[$i] ];
        my $ortho_xyz = 
            mat_vect_mul( $f2o,  $fract_xyz );
        
        my %atom_info = ( 
            label => $datablock_values->{_atom_site_label}[$i],
            chemical_type => $datablock_values->{_atom_site_type_symbol}[$i],
            coordinates_fract => $fract_xyz,
            coordinates_ortho => $ortho_xyz,
            occupancy => $occupancy->[$i],
            B_factor => $thermal_parameter_B->[$i],
            U_value_of_B_factor => $squared_displacement_U->[$i],
            aniso_value_Uij => [ $anisotrophic_U_ij_values[0]->[$i],
                                 $anisotrophic_U_ij_values[1]->[$i],
                                 $anisotrophic_U_ij_values[2]->[$i],
                                 $anisotrophic_U_ij_values[3]->[$i],
                                 $anisotrophic_U_ij_values[4]->[$i],
                                 $anisotrophic_U_ij_values[5]->[$i] ]
            );
        $i++;
        push( @atoms, \%atom_info );
    }
    return \@atoms;
}
