#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Compute the structure factors from CIF files.
#**

# The implementation in this programm follows the principles published
# in:

# (Yvon1977) Yvon, K.; Jeitschko, W. & ParthÃ©, E. it LAZY PULVERIX, a
# computer program, for calculating X-ray and neutron diffraction
# powder patterns Journal of Applied Crystallography, 1977, 10, 73-74
# http://dx.doi.org/10.1107/S0021889877012898

use strict;
use lib "./lib/perl5";
use lib "./CIFParser";
use lib "./CCIFParser";
use lib "./CIFTags";
use lib ".";
use File::Basename;
use CIFParser;
use CCIFParser;
use Spacegroups::SpacegroupNames;
use Spacegroups::SymopParse;
use Spacegroups::SymopLookup;
use SOptions;
use SUsage;

use Fractional;

my $use_parser = "c";
my $dump_xyz_coordinates = 0;
my $dump_Cromer_Mann_parameters = 0;

#* USAGE:
#*     $0 --options input1.cif input*.cif
#* 
#* OPTIONS:
#*    --use-perl-parser  Use development CIF parser written in Perl
#*    --use-c-parser     Use faster C/Yacc CIF parser (default)
#*    --dump-xyz-coordinates Print a XYZ file 
#*    --dump-Cromer-Mann Print a Cromer-Mann coefficients from CIF file
#*
#*    --help,--usage         Print a short usage message (this message) and exit.
#**

@ARGV = getOptions( 
    "--use-perl-parser"  => sub{ $use_parser = "perl" },
    "--use-c-parser"     => sub{ $use_parser = "c" },

    "--options"          => sub { 
        print "$0: The '--options' option is a placehoder.\n";
        print "$0: It should be replaced by one of the following options:\n";
        ## SUsage::usage;
        open( SCRIPT, $0 ) or die $!;
        while( <SCRIPT> ) {
            if( /^#\*\s+OPTIONS:/../^#\*\*/ ) {
                s/^#\*\s+OPTIONS://;
                s/^#\*\*?\s+//;
                print;
            }
        }
        close( SCRIPT );
        exit
    },
    "--dump-xyz-coordinates"    => sub { $dump_xyz_coordinates = 1 },
    "--dump-Cromer-Mann"    => sub { $dump_Cromer_Mann_parameters = 1 },
    "--help,--usage"     => sub { SUsage::usage; exit },
);

#==============================================================================#
# Forward subroutine definitions:
sub mat_vect_mul( $$ );
sub get_unit_cell( $$ );


@ARGV = ( "-" ) unless @ARGV;

for my $filename (@ARGV) {

    my( $data, $error_count );

    if( $use_parser eq "perl" ) {
        my $parser = new CIFParser;

        $data = $parser->Run( $filename );

        if( defined $parser->YYData->{ERRCOUNT} ) {
            $error_count = $parser->YYData->{ERRCOUNT};
        }
    } else {
        ( $data, $error_count ) = CCIFParser::parse( $filename );
    }

    if( defined $error_count && $error_count > 0 ) {
        print STDERR "$0: ", $error_count,
        " error(s) encountered while parsing file '${filename}'\n";
        die;
    }

    if( !@$data || !defined $data->[0] || !defined $data->[0]{name} ) {
        warn( "file '$filename' seems to be empty" );
        next;
    }
    
    for my $datablock (@$data) {
        
        my @cell = get_unit_cell( $datablock, $filename );
        my $f2o = symop_ortho_from_fract( @cell );
        ## print "@{$f2o->[0]}\n";
        
        my $atoms = atoms_from_cif( $datablock, $f2o );
      
        if( $dump_xyz_coordinates ) { 
            print $#$atoms+1, "\n";
            print "$datablock->{name}\n";
            foreach my $atom (@$atoms) {
                printf "%2s %.5f %.5f %.5f\n", $atom->{chemical_type}, 
                @{$atom->{coordinates_ortho}};
                ## print ">>> $atom->{occupancy}\n";
                ## print ">>> $atom->{B_factor}\n";
                ## print ">>> $atom->{U_value_of_B_factor}\n";
                ## print $atom->{aniso_value_Uij}->[0] ? 
                ##    ">>> @{$atom->{aniso_value_Uij}}\n" : "Empty\n";   
                ##  print $atom->{Crommer_Mann_coefficients}[0] ? 
                ## "@{$atom->{Crommer_Mann_coefficients}}\n" : "Empty\n";
            }
        }
        
        if ( $dump_Cromer_Mann_parameters ) {
            print "$datablock->{name}\n";
            foreach my $atom (@$atoms) {
                print "$atom->{label} "."$atom->{chemical_type} ",
                    $atom->{Crommer_Mann_coefficients}[0] ? "@{$atom->{Crommer_Mann_coefficients}}\n" : "Empty\n";
            }
        }        
        if ( 0 ) {
            my $cell_parameters = get_unit_cell_parameters ( $datablock );
            print "$datablock->{name}\n";
            printf "%15s %0.5f %0.5f %0.5f %0.5f %0.5f %0.5f\n", "Direct cell    ", 
            @{$cell_parameters->{crystal_cell}};
            printf "%15s %0.5f %0.5f %0.5f %0.5f %0.5f %0.5f\n", "Reciprocal cell", 
            @{$cell_parameters->{reciprocal_cell}};
            printf "%15s %0.5f\n", "Volume         ", $cell_parameters->{cell_volume};
        }
    }
}


#===============================================================#
# Extract unit cell angles and lengths.
#
# Accepts
#     values - a hash where a data from the CIF file is stored
# Returns
#     cell - an array  with stored information.

sub get_unit_cell($$)
{
    my( $datablock, $filename ) = @_;

    my $values = $datablock->{values};
    my $dataname = $datablock->{name};

    my @cell;

    for my $cif_tag (qw(_cell_length_a
                        _cell_length_b
                        _cell_length_c
                        )) {
        push(@cell, $values->{$cif_tag}[0]);
        $cell[-1] =~ s/\(\d+\)$//;
    }

    for my $cif_tag (qw(_cell_angle_alpha
                        _cell_angle_beta
                        _cell_angle_gamma
                        )) {
        if( exists $values->{$cif_tag} ) {
            push( @cell, $values->{$cif_tag}[0] );
            $cell[-1] =~ s/\(\d+\)$//;
        } else {
            warning( $0, $filename, $dataname,
                     "cell angle '$cif_tag' not present -- " .
                     "taking default value 90 degress." );
            push( @cell, 90 );
        }
    }

    return @cell;
}

#===============================================================#
# Multiplies an ortho matrix with a vector.

# my $ortho = [
#     [ o11 o12 o13 ]
#     [ 0   o22 o23 ]
#     [ 0   0   o33 ]
# ]
#

sub mat_vect_mul($$)
{
    my($matrix, $vector) = @_;

    my @new_coordinates;

    for(my $i = 0; $i < @{$vector}; $i++)
    {
        $new_coordinates[$i] = 0;
        for(my $j = 0; $j < @{$vector}; $j++)
        {
            $new_coordinates[$i] += ${$matrix}[$i][$j] * ${$vector}[$j];
        }
    }

    if( @$vector == 3 && @$matrix == 4 ) {
        $new_coordinates[0] += $matrix->[0][3];
        $new_coordinates[1] += $matrix->[1][3];
        $new_coordinates[2] += $matrix->[2][3];
    }

    return wantarray ? @new_coordinates : \@new_coordinates;
}

#-------------------------------------------------------------------#
# Remove the standart deviation (standard uncertainties) components
# from input data; 
# Parameters: reference to an array with scalar
# values; for ex.: 0.21582(8) 
# Return: reference to an array without
# std. deviations; for ex.: 0.21582

sub remove_standard_uncertainties
{
    my ($input) = @_;
    return [ map { my $value = $_;
                   $value =~ s/\(\d+\)//; $value } @{$input} ];
}

#--------------------------------------------------------------------#
# Function of extracting atom information from the CIF file.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Returns:
# \@atoms = (
#           # [0]
#           {
#               site_label => "O10",
#               chemical_type => "O",
#               coordinates_fract" => [0.1, 0.2, 0.3],
#               coordinates_ortho => [10, 20.5, 25.2],
#               occupancy => 0.5,
#               B_factor => 0.78,
#               U_value_of_B_factor => 0.03,
#               aniso_value_Uij => [0.01, 0.002, 0.003,..,0.006] # 6 values,
#               Crommer_Mann_coefficients => [1.10, .., .., ] # 9 values;
# a1, a2, .., b1, b2.., b4, c.
#           },
#           # [1]
#           {
#               site_label => "C11",
#               chemical_type => "C",
#               coordinates_fract" => [0.2, 0.25, 0.35],
#           },
#  );   

sub atoms_from_cif 
{ 
    my ($datablock, $f2o) = @_;
    my @atoms;
    my $datablock_values = $datablock->{values};
    my @xyz_arrays =
        ( remove_standard_uncertainties( 
              $datablock_values->{_atom_site_fract_x} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_fract_y} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_fract_z} ) );    
    my $occupancy = 
        remove_standard_uncertainties( 
            $datablock_values->{_atom_site_occupancy} );
    
    my $Cromer_Mann_coefficients = get_Cromer_Mann_coefficients( $datablock );
    my $themal_coefficients = get_thermal( $datablock );
    
    for my $i (0..$#{$datablock_values->{_atom_site_label}}) {
        my $fract_xyz = [ $xyz_arrays[0]->[$i],
                          $xyz_arrays[1]->[$i],
                          $xyz_arrays[2]->[$i] ];
        my $ortho_xyz = 
            mat_vect_mul( $f2o,  $fract_xyz );
        
        my %atom_info = ( 
            label => $datablock_values->{_atom_site_label}[$i],
            chemical_type => $datablock_values->{_atom_site_type_symbol}[$i],
            coordinates_fract => $fract_xyz,
            coordinates_ortho => $ortho_xyz,
            occupancy => $occupancy->[$i]                     
            );
        # 
        %atom_info = (%atom_info, %{$Cromer_Mann_coefficients->[$i]});
        %atom_info = (%atom_info, %{$themal_coefficients->[$i]});
        push( @atoms, \%atom_info );
    }
    return \@atoms;
}

#--------------------------------------------------------------------#
# Function of extracting atoms Crommer-Mann coefficients the CIF file.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Returns:
# \@ = (
#           # [0]
#           {
#               Crommer_Mann_coefficients => [1.10, .., .., ] # 9 values;
# a1, a2, .., b1, b2.., b4, c.
#           },
#           # [1]
#           {
#               Crommer_Mann_coefficients => [1.10, .., .., ]
#           },
#  );   

sub get_Cromer_Mann_coefficients
{
    my ($datablock) = @_;
    my $datablock_values = $datablock->{values};
    my @atoms_aniso_coefficients;
    
    my $labels = $datablock_values->{_atom_site_label};
    my $chemical_type_of_aniso_propierties_loop = 
        $datablock_values->{_atom_type_symbol};
    my $Cromer_Mann_coefficients = 
        [ $datablock_values->{_atom_type_scat_cromer_mann_a1},
          $datablock_values->{_atom_type_scat_cromer_mann_a2},
          $datablock_values->{_atom_type_scat_cromer_mann_a3},
          $datablock_values->{_atom_type_scat_cromer_mann_a4},
          $datablock_values->{_atom_type_scat_cromer_mann_b1},
          $datablock_values->{_atom_type_scat_cromer_mann_b2},
          $datablock_values->{_atom_type_scat_cromer_mann_b3},
          $datablock_values->{_atom_type_scat_cromer_mann_b4},
          $datablock_values->{_atom_type_scat_cromer_mann_c} ];
    for my $i (0..$#{$labels}) {
        my $atom_chemical_type = 
            $datablock_values->{_atom_site_type_symbol}[$i];
        for my $y (0..$#{$chemical_type_of_aniso_propierties_loop}) {
            
            if ( $atom_chemical_type eq 
                 $chemical_type_of_aniso_propierties_loop->[$y] ) {
                my %thermal = (
                    Crommer_Mann_coefficients => [
                        $Cromer_Mann_coefficients->[0][$y],
                        $Cromer_Mann_coefficients->[1][$y],
                        $Cromer_Mann_coefficients->[2][$y],
                        $Cromer_Mann_coefficients->[3][$y],
                        $Cromer_Mann_coefficients->[4][$y],
                        $Cromer_Mann_coefficients->[5][$y],
                        $Cromer_Mann_coefficients->[6][$y],
                        $Cromer_Mann_coefficients->[7][$y],
                        $Cromer_Mann_coefficients->[8][$y] ]
                    ); 
                push ( @atoms_aniso_coefficients, \%thermal );
                
            } # end of if;
        } # second for     
    } # first for 
    return \@atoms_aniso_coefficients;
}

#--------------------------------------------------------------------#
# Function of extracting atoms anisotropic and isotropic 
# thermal parameteres the CIF file.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Returns:
# \@ = (
#           # [0]
#           {
#               B_factor => 0.78,
#               U_value_of_B_factor => 0.03,
#               aniso_value_Uij => [0.01, 0.002, 0.003,..,0.006] # 6 values,
#           },
#           # [1]
#           {
#               B_factor => 0.78,
#               U_value_of_B_factor => 0.03,
#               aniso_value_Uij => [0.01, 0.002, 0.003,..,0.006] # 6 values,
#           },
#  );  

sub get_thermal
{
    my ($datablock) = @_;
    my $datablock_values = $datablock->{values};
    my @atoms_thermal_coefficients;
    
    my $thermal_parameter_B = 
        remove_standard_uncertainties( 
            $datablock_values->{_atom_site_b_iso_or_equiv} );
    my $squared_displacement_U = 
        remove_standard_uncertainties( 
            $datablock_values->{_atom_site_u_iso_or_equiv} );
    my @anisotrophic_U_ij_values = 
        ( remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_11} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_22} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_33} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_23} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_13} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_12} ) );
    
    for my $i (0..$#{$datablock_values->{_atom_site_label}}) {
        my %thermal_info = (
            B_factor => $thermal_parameter_B->[$i],
            U_value_of_B_factor => $squared_displacement_U->[$i],
            aniso_value_Uij => [ $anisotrophic_U_ij_values[0]->[$i],
                                 $anisotrophic_U_ij_values[1]->[$i],
                                 $anisotrophic_U_ij_values[2]->[$i],
                                 $anisotrophic_U_ij_values[3]->[$i],
                                 $anisotrophic_U_ij_values[4]->[$i],
                                 $anisotrophic_U_ij_values[5]->[$i] ]
            );
        push ( @atoms_thermal_coefficients, \%thermal_info );
    }
    return \@atoms_thermal_coefficients;
}


#--------------------------------------------------------------------#
# Function of extracting unit-cell parameters of the CIF file.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Return
# $a = {
#        crystall_cell => [a, b, c, alpha, beta, gamma ],    
#        cell_volume => 14.055,
#      }
sub get_unit_cell_parameters
{
    my ($datablock) = @_;
    my $datablock_values = $datablock->{values};
    
    my @crystal_lattice =  ( ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_length_a} )}[0],
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_length_b} )}[0],
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_length_c} )}[0],
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_angle_alpha} )}[0],        
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_angle_beta} )}[0],
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_angle_gamma} )}[0] );
    # @crystal_lattice = ( a[0], b[1], c[2], alpha[3], beta[4], gamma[5] );
    my $cell_volume = ${ remove_standard_uncertainties( 
        $datablock_values->{_cell_volume} )}[0];
    my ($a, $b, $c, $alpha, $beta, $gamma) = @crystal_lattice;
    # alpha between b and c; beta between a and c; gamma between a and b.
    # @star_crystal_lattice = ( a*[0], b*[1], c*[2], alpha*, beta*, gamma*[5] );
    my @star_crystal_lattice = (
        d2r_length( $b, $c, $alpha, $cell_volume ), # a*
        d2r_length( $a, $c, $beta, $cell_volume ), # b*
        d2r_length( $a, $b, $gamma, $cell_volume ), # c*
        d2r_angle( $beta, $gamma, $alpha ), # alpha*
        d2r_angle( $alpha, $gamma, $beta ), # beta*
        d2r_angle( $alpha, $beta, $gamma ) # gamma* 
        );
    my $crystal_par = { 
        crystal_cell => \@crystal_lattice,
        cell_volume => $cell_volume,
        reciprocal_cell => \@star_crystal_lattice
    };
    return $crystal_par;
}

#--------------------------------------------------------------------#
# Function of converting lattice parameters (length of cell edges):
# from direct space to reciprocal.
#
# Parameters and return:
# for example  c* = d2r_length( a, b, angle(a,b), cell_volume );
sub d2r_length 
{
    my ($c_length1, $c_length2, $angle1_2, $cell_vol) = @_;
    return ($c_length1 * $c_length2 * POSIX::sin( $angle1_2 )) / $cell_vol;
} 

#--------------------------------------------------------------------#
# Function of converting lattice parameters (cell angles):
# from direct space to reciprocal.
#
# Parameters and return:
# gamma* = d2r_angle( alpha, beta, GAMMA );
# beta* = d2r_angle( alpha, gamma, BETA );
# alpha* = d2r_angle( beta, gamma, ALPHA );
sub d2r_angle 
{
    my ($angle1, $angle2, $angle_which_converts) = @_;
    return 
        (POSIX::cos( $angle1 ) * POSIX::cos( $angle2 ) -
         POSIX::cos( $angle_which_converts)) / 
         (POSIX::sin( $angle1 ) * POSIX::sin( $angle2 ));    
}

