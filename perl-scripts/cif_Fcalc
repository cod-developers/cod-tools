#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Compute the structure factors from CIF files.
#**

# The implementation in this programm follows the principles published
# in:

# (Yvon1977) Yvon, K.; Jeitschko, W. & ParthÃ©, E. it LAZY PULVERIX, a
# computer program, for calculating X-ray and neutron diffraction
# powder patterns Journal of Applied Crystallography, 1977, 10, 73-74
# http://dx.doi.org/10.1107/S0021889877012898

use strict;
use lib "./lib/perl5";
use lib "./CIFParser";
use lib "./CCIFParser";
use lib "./CIFTags";
use lib ".";
use File::Basename;
use CIFParser;
use Spacegroups::SpacegroupNames;
use Spacegroups::SymopParse;
use Spacegroups::SymopLookup;
use SOptions;
use SUsage;

use Fractional;

my $use_parser = "c";
my $dump_xyz_coordinates = 0;
my $dump_Cromer_Mann_parameters = 0;
my $dump_cell_parameters = 0;
my $dump_cell_xyz_coordinates = 0;
my $synthetic_test1 = 0;
my $iso_temperature_factor = 0;

# constants;
my $PI = 4*atan2( 1, 1 );

#* USAGE:
#*     $0 --options input1.cif input*.cif
#* 
#* OPTIONS:
#*    --use-perl-parser  Use development CIF parser written in Perl
#*    --use-c-parser     Use faster C/Yacc CIF parser (default)
#*    --dump-xyz-coordinates Print a XYZ file 
#*    --dump-Cromer-Mann Print a Cromer-Mann coefficients from CIF file
#*    --dump-cell-parameters Print a short usage message with cell parameters
#*    --synthetic-test1 Print a short usage message of various parameters.
#*    --dump-cell-xyz-coordinates Print a XYZ file which contains all atoms of cell.
#*    --isotropic-Tf Use isotropic temperature factor for structure factor calculations
#*    --help,--usage         Print a short usage message (this message) and exit.
#**

@ARGV = getOptions( 
    "--use-perl-parser"  => sub{ $use_parser = "perl" },
    "--use-c-parser"     => sub{ $use_parser = "c" },

    "--options"          => sub { 
        print "$0: The '--options' option is a placehoder.\n";
        print "$0: It should be replaced by one of the following options:\n";
        ## SUsage::usage;
        open( SCRIPT, $0 ) or die $!;
        while( <SCRIPT> ) {
            if( /^#\*\s+OPTIONS:/../^#\*\*/ ) {
                s/^#\*\s+OPTIONS://;
                s/^#\*\*?\s+//;
                print;
            }
        }
        close( SCRIPT );
        exit
    },
    "--dump-xyz-coordinates"    => sub { $dump_xyz_coordinates = 1 },
    "--dump-Cromer-Mann"    => sub { $dump_Cromer_Mann_parameters = 1 },
    "--dump-cell-parameters"    => sub { $dump_cell_parameters = 1 },
    "--synthetic-test1"    => sub { $synthetic_test1 = 1 },
    "--dump-cell-xyz-coordinates"    => sub { $dump_cell_xyz_coordinates = 1 },
    "--isotropic-Tf"    => sub { $iso_temperature_factor = 1 },
    "--help,--usage"     => sub { SUsage::usage; exit },
);

#==============================================================================#
# Forward subroutine definitions:
sub mat_vect_mul( $$ );
sub get_unit_cell( $$ );


@ARGV = ( "-" ) unless @ARGV;

for my $filename (@ARGV) {

    my( $data, $error_count );

    if( $use_parser eq "perl" ) {
        my $parser = new CIFParser;

        $data = $parser->Run( $filename );

        if( defined $parser->YYData->{ERRCOUNT} ) {
            $error_count = $parser->YYData->{ERRCOUNT};
        }
    } else {
        require CCIFParser;
        ( $data, $error_count ) = CCIFParser::parse( $filename );
    }

    if( defined $error_count && $error_count > 0 ) {
        print STDERR "$0: ", $error_count,
        " error(s) encountered while parsing file '${filename}'\n";
        die;
    }

    if( !@$data || !defined $data->[0] || !defined $data->[0]{name} ) {
        warn( "file '$filename' seems to be empty" );
        next;
    }
    
    for my $datablock (@$data) {
        
        my $radiation_wavelengths = remove_standard_uncertainties(
            $datablock->{values}{_diffrn_radiation_wavelength} );
        ## print "$radiation_wavelengths->[0]\n";
        die "The value of Xray radiation wavelength is empty." 
            if (!defined $radiation_wavelengths->[0]);
        die "The CIF contains more than one value of Xray radiation wavelength." 
            if ($#{$radiation_wavelengths}>0);
        
        my @cell = get_unit_cell( $datablock, $filename );
        my $f2o = symop_ortho_from_fract( @cell );
        my $atoms = atoms_from_cif( $datablock, $f2o, $filename);
        my $cell_parameters = get_unit_cell_parameters( $datablock );
        ## print "@cell\n";
	#---------------------------------------------------------
	# using tests function
        tests_outputs( $atoms, $filename, $cell_parameters ); 
	#-------------------------------------------------------------
        
	# test of aniso koefficients: if not all atoms (without H and D)
        # contains aniso coef. then isotrophic koef. are using.
        my $temperature_factor_key = 1;
        foreach my $atom (@{$atoms}) {
            if( !defined $atom->{aniso_value_Uij}[0] &&
                $atom->{label} !~ /[H|D]\d++/ ) {
                $temperature_factor_key = 0;
                warn( "The CIF file '$filename' don't contain the full data ".
                      "of the standard anisotropic atomic displacement ".
                      "components" );
                last;
            }
        }
        if( $iso_temperature_factor ) {
            $temperature_factor_key = 0; # if option --isotropic-Tf;
        }
        
        my $scat_dispersion_key = 0;
        if( defined $atoms->[0]{scat_dispesion_real} ) {
            $scat_dispersion_key = 1;
        }
        
        unless( $dump_Cromer_Mann_parameters || $dump_cell_parameters || 
                $dump_xyz_coordinates || $dump_cell_xyz_coordinates ) {
            my ( $h_max, $h_min, $k_max, $k_min, $l_max, $l_min ) = 
                @{hkl_limits( $datablock, $filename )};
            
	    my @abc_star = @{$cell_parameters->{reciprocal_cell_radians}}[0..2];
            
            foreach my $h_limit ( $h_min..$h_max ) {
            foreach my $k_limit ( $k_min..$k_max ) {   
            foreach my $l_limit ( $l_min..$l_max ) {  
                my @hkl = ($h_limit, $k_limit, $l_limit);
                next if( $h_limit==0 && $k_limit==0 && $l_limit==0 );
                my $resolution_hkl = spacing_d_hkl( 
                    @hkl, 
                    @{$cell_parameters->{reciprocal_cell_radians}} );
                my $sin_teta_hkl = 
                    $radiation_wavelengths->[0] / (2 * $resolution_hkl);

                # Temporary local test which will be removed after
                # creating *pm with outer Cromer Mann coefficients.
                # --------------------------------------------
                die "CIF file does not contain Crommer-Mann coefficients." 
                    if( !defined $atoms->[0]{Crommer_Mann_coefficients}[0] ); 
                #--------------------------------------------------------------

                my ( $F_cos_comp_w_Tf_and_cor, $F_sin_comp_w_Tf_and_cor,
                     $F_cos_comp_w_cor, $F_sin_comp_w_cor,
                     $F_cos_comp, $F_sin_comp ) = (0,0,0,0,0,0);		
                foreach my $atom (@$atoms) {                
                    my $atom_structure_factor = 
                        atom_structure_factor_from_coefficients( 
                            $atom->{Crommer_Mann_coefficients}, 
                            $radiation_wavelengths->[0],
                            $sin_teta_hkl );

                    my $atom_structure_factor_corrected;
                    if( $scat_dispersion_key ) {
                        $atom_structure_factor_corrected = 
                            sqrt( ( $atom_structure_factor + 
                                    $atom->{scat_dispesion_real} )**2 + 
                                  $atom->{scat_dispesion_real}**2 );
                    }
                    
		    foreach my $sym_xyz (@{$atom->{symmetrical_xyz_fract}}) {
			my $atom_hkl_phase = atom_phase_hkl_rad( 
			    @hkl, @{$sym_xyz} );
			
			my $temperature_factor;
			if( $temperature_factor_key ) {
			    # calculation of aniso temperature factor;
			    if( $atom->{chemical_type} eq "H" ) {
				$temperature_factor = 1;
			    } else {
				$temperature_factor = 
				    temperature_factor_aniso( 
					@{$atom->{aniso_value_Uij}},
					@hkl, @abc_star);
			    }
			} else { # calculation of iso temperature factor;
			    $temperature_factor = 
				exp( ( -$atom->{B_factor}/4 ) * 
				     ( 1/$resolution_hkl )**2 );
			}
                        
			$F_cos_comp_w_Tf_and_cor +=
			    $atom->{occupancy} * 
			    $atom_structure_factor * cos( $atom_hkl_phase );
			$F_sin_comp_w_Tf_and_cor +=
			    $atom->{occupancy} * 
			    $atom_structure_factor * sin( $atom_hkl_phase );
			unless ($synthetic_test1) {
			    # structure factor components without corrections;
			    $F_cos_comp_w_cor +=
				$atom->{occupancy} * $atom_structure_factor * 
				$temperature_factor * cos( $atom_hkl_phase );
			    $F_sin_comp_w_cor += 
				$atom->{occupancy} * $atom_structure_factor * 
				$temperature_factor * sin( $atom_hkl_phase );
                            if( $scat_dispersion_key ) { 
                                $F_cos_comp += $atom->{occupancy} * 
                                    $atom_structure_factor_corrected * 
                                    $temperature_factor * cos( $atom_hkl_phase );
                                $F_sin_comp += $atom->{occupancy} * 
                                    $atom_structure_factor_corrected * 
                                    $temperature_factor * sin( $atom_hkl_phase );
                            } else {
                                warn( "The CIF file '$filename' don't contain the data ".
                                      "of anomalous-dispersion scattering factor" );
                            }
			}
		    } # foreach of cell atoms;
		} # foreach of assimetric unit atoms;
                
		my $F_hkl_without_Tf_and_cor = 
                    sqrt( $F_cos_comp_w_Tf_and_cor**2 + 
                          $F_sin_comp_w_Tf_and_cor**2 );
                my $F_hkl_iso_without_cor = 
                    sqrt( $F_cos_comp_w_cor**2 + $F_sin_comp_w_cor**2 ); 
		my $F_hkl_sguared = 
                    $F_cos_comp**2 + $F_sin_comp**2; 
                
                if( $synthetic_test1 ) {
                    print "  H   K   L  RESO  sin(theta)  F  1/2d   F_cos  "
                        ."F_sin\n";
                    printf "%3s %3s %3s  %0.3f %0.5f %0.3f %0.3f %0.3f "
                        ."%0.3f\n", @hkl, $resolution_hkl, $sin_teta_hkl, 
                        $F_hkl_without_Tf_and_cor, 1/(2 * $resolution_hkl), 
                        $F_cos_comp_w_Tf_and_cor, $F_sin_comp_w_Tf_and_cor;
		    exit;
                }
                
                if( 1 ) {
                    printf "%3s %3s %3s %0.3f %0.3f %0.3f\n", 
                    @hkl,  
                    $F_hkl_without_Tf_and_cor**2, 
                    $F_hkl_iso_without_cor**2,
                    $F_hkl_sguared;
                }
            }}}            
        }
    }
}


#===============================================================#
# Extract unit cell angles and lengths.
#
# Accepts
#     values - a hash where a data from the CIF file is stored
# Returns
#     cell - an array  with stored information.

sub get_unit_cell($$)
{
    my( $datablock, $filename ) = @_;

    my $values = $datablock->{values};
    my $dataname = $datablock->{name};

    my @cell;

    for my $cif_tag (qw(_cell_length_a
                        _cell_length_b
                        _cell_length_c
                        )) {
        push(@cell, $values->{$cif_tag}[0]);
        $cell[-1] =~ s/\(\d+\)$//;
    }

    for my $cif_tag (qw(_cell_angle_alpha
                        _cell_angle_beta
                        _cell_angle_gamma
                        )) {
        if( exists $values->{$cif_tag} ) {
            push( @cell, $values->{$cif_tag}[0] );
            $cell[-1] =~ s/\(\d+\)$//;
        } else {
            warning( $0, $filename, $dataname,
                     "cell angle '$cif_tag' not present -- " .
                     "taking default value 90 degress." );
            push( @cell, 90 );
        }
    }

    return @cell;
}

#===============================================================#
# Multiplies an ortho matrix with a vector.

# my $ortho = [
#     [ o11 o12 o13 ]
#     [ 0   o22 o23 ]
#     [ 0   0   o33 ]
# ]
#

sub mat_vect_mul($$)
{
    my($matrix, $vector) = @_;

    my @new_coordinates;

    for(my $i = 0; $i < @{$vector}; $i++)
    {
        $new_coordinates[$i] = 0;
        for(my $j = 0; $j < @{$vector}; $j++)
        {
            $new_coordinates[$i] += ${$matrix}[$i][$j] * ${$vector}[$j];
        }
    }

    if( @$vector == 3 && @$matrix == 4 ) {
        $new_coordinates[0] += $matrix->[0][3];
        $new_coordinates[1] += $matrix->[1][3];
        $new_coordinates[2] += $matrix->[2][3];
    }

    return wantarray ? @new_coordinates : \@new_coordinates;
}

#-------------------------------------------------------------------#
# Remove the standart deviation (standard uncertainties) components
# from input data; 
# Parameters: reference to an array with scalar
# values; for ex.: 0.21582(8) 
# Return: reference to an array without
# std. deviations; for ex.: 0.21582

sub remove_standard_uncertainties
{
    my( $input ) = @_;
    return [ map { my $value = $_;
                   $value =~ s/\(\d+\)//; $value } @{$input} ];
}

#--------------------------------------------------------------------#
# Function of extracting atom information from the CIF file.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Returns:
# \@atoms = (
#           # [0]
#           {
#               label => "O10",
#               chemical_type => "O",
#               coordinates_fract" => [0.1, 0.2, 0.3],
#               coordinates_ortho => [10, 20.5, 25.2],
#               occupancy => 0.5,
#               B_factor => 0.78,
#               U_value_of_B_factor => 0.03,
#               aniso_value_Uij => [0.01, 0.002, 0.003,..,0.006] # 6 values,
#               Crommer_Mann_coefficients => [1.10, .., .., ] # 9 values;
# a1, a2, .., b1, b2.., b4, c.
#               symmetrical_xyz_fract => [\@xyz1, \@xyz2, .. ],
#               symmetrical_xyz_ortho => [\@xyz1, \@xyz2, .. ],
#               count_of_cell_atoms => 10, # only for first atom;
#           },
#           # [1]
#           {
#             ...
#           },
#  );   

sub atoms_from_cif 
{ 
    my( $datablock, $f2o, $filename ) = @_;
    my @atoms;
    my $datablock_values = $datablock->{values};
    my @xyz_arrays =
        ( remove_standard_uncertainties( 
              $datablock_values->{_atom_site_fract_x} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_fract_y} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_fract_z} ) );    
    my $occupancy = 
        remove_standard_uncertainties( 
            $datablock_values->{_atom_site_occupancy} );
    
    my $Cromer_Mann_coefficients = get_Cromer_Mann_coefficients( $datablock );
    my $themal_coefficients = get_thermal( $datablock );
    my $sym_atoms_and_their_count = cell_filling_sym( $datablock, $filename, $f2o);
    
    for my $i (0..$#{$datablock_values->{_atom_site_label}}) {
        my $fract_xyz = [ $xyz_arrays[0]->[$i],
                          $xyz_arrays[1]->[$i],
                          $xyz_arrays[2]->[$i] ];
        my $ortho_xyz = 
            mat_vect_mul( $f2o,  $fract_xyz );
        my $atom_chemical_type = 
            $datablock_values->{_atom_site_type_symbol}[$i];
        if( !defined $datablock_values->{_atom_site_type_symbol}[$i] ) {
            $atom_chemical_type = 
                ucfirst( 
                    lc( substr( 
                            $datablock_values->{_atom_site_label}[$i], 0, 2
                        )));
            $atom_chemical_type =~ s/\d//;          
        }   
        my %atom_info = ( 
            label => $datablock_values->{_atom_site_label}[$i],
            chemical_type => $atom_chemical_type,
            coordinates_fract => $fract_xyz,
            coordinates_ortho => $ortho_xyz,
            occupancy => $occupancy->[$i]                     
            );
        # 
        %atom_info = (%atom_info, %{$Cromer_Mann_coefficients->[$i]});
        %atom_info = (%atom_info, %{$themal_coefficients->[$i]});
	%atom_info = (%atom_info, %{$sym_atoms_and_their_count->[$i]});
        push( @atoms, \%atom_info );
    }
    return \@atoms;
}

#--------------------------------------------------------------------#
# Function of extracting atoms Crommer-Mann coefficients the CIF file.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Returns:
# \@ = (
#           # [0]
#           {
#               Crommer_Mann_coefficients => [1.10, .., .., ] # 9 values;
# a1, a2, .., b1, b2.., b4, c.
#           },
#           # [1]
#           {
#               Crommer_Mann_coefficients => [1.10, .., .., ]
#           },
#  );   

sub get_Cromer_Mann_coefficients
{
    my( $datablock ) = @_;
    my $datablock_values = $datablock->{values};
    my @atoms_aniso_coefficients;
    
    my $labels = $datablock_values->{_atom_site_label};
    my $chemical_type_of_Cromer_Mann_loop = [];
    foreach (@{$datablock_values->{_atom_type_symbol}}) {
        my $double_sym = ucfirst( lc( substr( $_,0,2 )));
        $double_sym =~ s/\s//g;
        push( @{$chemical_type_of_Cromer_Mann_loop}, $double_sym );
    }
    my $Cromer_Mann_coefficients = 
        [ $datablock_values->{_atom_type_scat_cromer_mann_a1},
          $datablock_values->{_atom_type_scat_cromer_mann_a2},
          $datablock_values->{_atom_type_scat_cromer_mann_a3},
          $datablock_values->{_atom_type_scat_cromer_mann_a4},
          $datablock_values->{_atom_type_scat_cromer_mann_b1},
          $datablock_values->{_atom_type_scat_cromer_mann_b2},
          $datablock_values->{_atom_type_scat_cromer_mann_b3},
          $datablock_values->{_atom_type_scat_cromer_mann_b4},
          $datablock_values->{_atom_type_scat_cromer_mann_c} ];
    my $atom_scat_dispersion_real = 
        $datablock_values->{_atom_type_scat_dispersion_real};
    my $atom_scat_dispersion_imag = 
        $datablock_values->{_atom_type_scat_dispersion_imag};
    for my $i (0..$#{$labels}) {
        my $atom_chemical_type = 
            $datablock_values->{_atom_site_type_symbol}[$i];
        if( !defined $atom_chemical_type ) {
            $atom_chemical_type = 
                ucfirst( lc( substr($labels->[$i],0,2)));
            $atom_chemical_type =~ s/\d//;
            
        }
        for my $y (0..$#{$chemical_type_of_Cromer_Mann_loop}) {
        ## print length($chemical_type_of_Cromer_Mann_loop->[$y]), 
        ## ">>> $chemical_type_of_Cromer_Mann_loop->[$y]\n";
        ## print length($atom_chemical_type), 
        ## "<<< $atom_chemical_type\n";
            if( $atom_chemical_type eq 
                 $chemical_type_of_Cromer_Mann_loop->[$y] ) {                
                my %thermal = (
                    Crommer_Mann_coefficients => [
                        $Cromer_Mann_coefficients->[0][$y],
                        $Cromer_Mann_coefficients->[1][$y],
                        $Cromer_Mann_coefficients->[2][$y],
                        $Cromer_Mann_coefficients->[3][$y],
                        $Cromer_Mann_coefficients->[4][$y],
                        $Cromer_Mann_coefficients->[5][$y],
                        $Cromer_Mann_coefficients->[6][$y],
                        $Cromer_Mann_coefficients->[7][$y],
                        $Cromer_Mann_coefficients->[8][$y] ],
                    scat_dispesion_real => $atom_scat_dispersion_real->[$y],
                    scat_dispesion_imag => $atom_scat_dispersion_imag->[$y]
                    ); 
                push ( @atoms_aniso_coefficients, \%thermal );
                
            } # end of if;
        } # second for     
    } # first for 
    return \@atoms_aniso_coefficients;
}

#--------------------------------------------------------------------#
# Function of extracting atoms anisotropic and isotropic 
# thermal parameteres the CIF file.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Returns:
# \@ = (
#           # [0]
#           {
#               B_factor => 0.78,
#               U_value_of_B_factor => 0.03,
#               aniso_value_Uij => [0.01, 0.002, 0.003,..,0.006] # 6 values,
#           },
#           # [1]
#           {
#               B_factor => 0.78,
#               U_value_of_B_factor => 0.03,
#               aniso_value_Uij => [0.01, 0.002, 0.003,..,0.006] # 6 values,
#           },
#  );  


sub get_thermal
{
    my( $datablock ) = @_;
    my $datablock_values = $datablock->{values};
    my @atoms_thermal_coefficients;
    
    my $thermal_parameter_B = 
        remove_standard_uncertainties( 
            $datablock_values->{_atom_site_b_iso_or_equiv} );
    my $squared_displacement_U = 
        remove_standard_uncertainties( 
            $datablock_values->{_atom_site_u_iso_or_equiv} );
    my @anisotrophic_U_ij_values = 
        ( remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_11} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_22} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_33} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_23} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_13} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_12} ) ); 
    # _atom_site_aniso_label needs for extracting of anisotrophic values; 
    my %temporary_aniso_data;
    for my $i (0..$#{$datablock_values->{_atom_site_aniso_label}}) {
        my $atom_aniso_label = 
            $datablock_values->{_atom_site_aniso_label}[$i];
        $temporary_aniso_data{$atom_aniso_label} = 
            [ $anisotrophic_U_ij_values[0]->[$i],
              $anisotrophic_U_ij_values[1]->[$i],
              $anisotrophic_U_ij_values[2]->[$i],
              $anisotrophic_U_ij_values[3]->[$i],
              $anisotrophic_U_ij_values[4]->[$i],
              $anisotrophic_U_ij_values[5]->[$i] ];      
    }
    
    for my $i (0..$#{$datablock_values->{_atom_site_label}}) {
        my $atom_label = $datablock_values->{_atom_site_label}[$i];
        my %thermal_info = (
            B_factor => ($thermal_parameter_B->[$i] ? $thermal_parameter_B->[$i] : 
             8 * ($PI**2) * $squared_displacement_U->[$i]
            ),
            U_value_of_B_factor => $squared_displacement_U->[$i],
            aniso_value_Uij => $temporary_aniso_data{$atom_label}
            );
        push( @atoms_thermal_coefficients, \%thermal_info );
    }
    return \@atoms_thermal_coefficients;
}


#--------------------------------------------------------------------#
# Function of extracting unit-cell parameters of the CIF file.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Return
# $a = {
#        crystall_cell => [a, b, c, alpha, beta, gamma ],    
#        cell_volume => 14.055,
#        reciprocal_cell => [a*, b*, c*, alpha*, beta*, gamma*]
#      }
sub get_unit_cell_parameters
{
    my( $datablock ) = @_;
    my $datablock_values = $datablock->{values};
    
    my @crystal_lattice =  ( ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_length_a} )}[0],
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_length_b} )}[0],
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_length_c} )}[0],
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_angle_alpha} )}[0],        
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_angle_beta} )}[0],
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_angle_gamma} )}[0] );
    # @crystal_lattice = ( a[0], b[1], c[2], alpha[3], beta[4], gamma[5] );
    my $cell_volume = ${remove_standard_uncertainties( 
        $datablock_values->{_cell_volume} )}[0];
    my( $a, $b, $c, $alpha, $beta, $gamma ) = @crystal_lattice;
    my @crystal_cell_radians = 
        ( $a, $b, $c, deg2rad( $alpha, $beta, $gamma ));
    # alpha between b and c; beta between a and c; gamma between a and b.
    # @star_crystal_lattice = ( a*[0], b*[1], c*[2], alpha*, beta*, gamma*[5] );
    my @abc_star_values = ( 
        d2r_length( $b, $c, deg2rad( $alpha ), $cell_volume ), # a*
        d2r_length( $a, $c, deg2rad( $beta ), $cell_volume ), # b*
        d2r_length( $a, $b, deg2rad( $gamma ), $cell_volume )  # c*
        ); 
    my @alpha_beta_gamma_star_radians = (
        d2r_angle( deg2rad( $beta, $gamma, $alpha ) ), # alpha*
        d2r_angle( deg2rad( $alpha, $gamma, $beta) ),  # beta*
        d2r_angle( deg2rad( $alpha, $beta, $gamma) ));  # gamma*
    my  @alpha_beta_gamma_star_degrees = 
        rad2deg( @alpha_beta_gamma_star_radians );
    my @star_crystal_cell_parameters_degrees = 
        (@abc_star_values, @alpha_beta_gamma_star_degrees);
    my @star_crystal_cell_parameters_radians = 
        (@abc_star_values, @alpha_beta_gamma_star_radians);
    my $crystal_par = { 
        crystal_cell_degrees => \@crystal_lattice,
        crystal_cell_radians => \@crystal_cell_radians,
        cell_volume => $cell_volume,
        reciprocal_cell_degrees => \@star_crystal_cell_parameters_degrees,
        reciprocal_cell_radians => \@star_crystal_cell_parameters_radians
    };
    return $crystal_par;
}

#--------------------------------------------------------------------#
# Function of converting lattice parameters (length of cell edges):
# from direct space to reciprocal.
#
# Parameters:
# for example  c* = d2r_length( a, b, angle(a,b), cell_volume );
# Return:
# for example 0.554 [angstrom**-1]
sub d2r_length 
{
    my( $c_length1, $c_length2, $angle1_2, $cell_vol ) = @_;
    return ($c_length1 * $c_length2 * sin( $angle1_2 )) / $cell_vol;
} 

#--------------------------------------------------------------------#
# Function of converting lattice parameters (cell angles):
# from direct space to reciprocal.
#
# Parameters and return:
# gamma* = d2r_angle( alpha, beta, GAMMA );
# beta* = d2r_angle( alpha, gamma, BETA );
# alpha* = d2r_angle( beta, gamma, ALPHA );
sub d2r_angle 
{
    my( $angle1, $angle2, $angle_which_converts ) = @_;
    return POSIX::acos(
        (cos( $angle1 ) * cos( $angle2 ) -
         cos( $angle_which_converts)) / 
        (sin( $angle1 ) * sin( $angle2 )) );    
}

#----------------------------------------------------------------------#
# Function for calculation the distance(resolution) between hkl layers.
#
# Parameters:
# hkl (index of reflection), reciprocal lattice.
# for ex.: spacing_d_hkl( h, k, l, a*, b*, c*, alpha*, beta*, gamma* )
# Return
# hkl resolution (in angstrom): 5. 
sub spacing_d_hkl 
{
    my( $h, $k, $l, $a_star, $b_star, $c_star,
         $alpha_star, $beta_star, $gamma_star ) = @_;
    return 1 /
	sqrt( $h**2 * $a_star**2 +
              $k**2 * $b_star**2 +
              $l**2 * $c_star**2 +
              2 * $h * $k * $a_star * $b_star * cos( $gamma_star ) +
              2 * $h * $l * $a_star * $c_star * cos( $beta_star ) +
              2 * $k * $l * $b_star * $c_star * cos( $alpha_star ) );
}

#----------------------------------------------------------------------#
# Function for extracting the limits of the Miller indices.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Return
# \(h_max,h_min,k_max,k_min,l_max,l_min);
sub hkl_limits
{
    my( $datablock, $filename ) = @_;
    my $datablock_values = $datablock->{values};
    if( !defined ${$datablock_values->{_diffrn_reflns_limit_h_max}}[0] | 
        !defined ${$datablock_values->{_diffrn_reflns_limit_h_min}}[0] | 
        !defined ${$datablock_values->{_diffrn_reflns_limit_k_max}}[0] |
        !defined ${$datablock_values->{_diffrn_reflns_limit_k_min}}[0] |
        !defined ${$datablock_values->{_diffrn_reflns_limit_l_max}}[0] |
        !defined ${$datablock_values->{_diffrn_reflns_limit_l_min}}[0] ) {
        warn( "The CIF file '$filename' don't contain the full data ".
              "of limits on the Milers indices" );
        exit;
    }
    return [ ${$datablock_values->{_diffrn_reflns_limit_h_max}}[0],
             ${$datablock_values->{_diffrn_reflns_limit_h_min}}[0],
             ${$datablock_values->{_diffrn_reflns_limit_k_max}}[0],
             ${$datablock_values->{_diffrn_reflns_limit_k_min}}[0],
             ${$datablock_values->{_diffrn_reflns_limit_l_max}}[0],
             ${$datablock_values->{_diffrn_reflns_limit_l_min}}[0] ];   
}

#----------------------------------------------------------------------#
# Function converts degree to radian.
# deg2rad( 180 ) = Pi;
# deg2rad( angle1(deg), angle2(deg), .. ) = ( angle1(rad) , angle2(rad), .. );
sub deg2rad
{
    return map{ ($_ * $PI) / 180 } @_;
}

#----------------------------------------------------------------------#
# Function converts radian to degree.
# rad2deg( Pi ) = 180;
# rad2deg( angle1(rad), angle2(rad), .. ) = ( angle1(deg) , angle2(deg), .. );
sub rad2deg
{
    return map { ($_ * 180) / $PI } @_;
}

#----------------------------------------------------------------------#
# Print output of option --dump-cell-parameters.
sub printing_of_dump_cell_parameters
{  
    my( $file_name, $cell_parameters ) = @_;
    print "$file_name\n";
    printf "%15s %0.5f %0.5f %0.5f %0.5f %0.5f %0.5f\n", 
    "Direct cell     (deg)", @{$cell_parameters->{crystal_cell_degrees}};
    printf "%15s %0.5f %0.5f %0.5f %0.5f %0.5f %0.5f\n", 
    "Direct cell     (rad)", @{$cell_parameters->{crystal_cell_radians}};
    printf "%15s %0.5f %0.5f %0.5f %0.5f %0.5f %0.5f\n", 
    "Reciprocal cell (deg)", @{$cell_parameters->{reciprocal_cell_degrees}};
    printf "%15s %0.5f %0.5f %0.5f %0.5f %0.5f %0.5f\n", 
    "Reciprocal cell (rad)", @{$cell_parameters->{reciprocal_cell_radians}};
    printf "%15s %0.5f\n", 
    "Volume         ", $cell_parameters->{cell_volume}; 
}

#----------------------------------------------------------------------#
# Function for atom structure factor calculation.
#
# Parameters:
# [ Cromer_Mann coefficients: a1, .., a4, b1, .., b4, c ], diff. wavelength,
# sin(teta_hkl);
#
# Return:
# Value of atom structure factor which depends on wavelength and sin(teta_hkl)
# for ex.:
# atom_structure_factor_from_coefficient([a1,..,c],1.54, 0.33) = 1.4;
sub atom_structure_factor_from_coefficients 
{
    my( $Cromer_Mann, $wavelenth, $sin_theta_hkl ) = @_;
    my( $a1, $a2, $a3, $a4, $b1, $b2, $b3, $b4, $c ) = @{$Cromer_Mann};
    return 
	$a1 * exp( -$b1 * ($sin_theta_hkl / $wavelenth)**2 ) +
	$a2 * exp( -$b2 * ($sin_theta_hkl / $wavelenth)**2 ) +
	$a3 * exp( -$b3 * ($sin_theta_hkl / $wavelenth)**2 ) +
	$a4 * exp( -$b4 * ($sin_theta_hkl / $wavelenth)**2 ) +
	$c;
}

#----------------------------------------------------------------------#
# Function for calculation of atom hkl_phase. 
#
# Parameters: 
# phase_hkl( @hkl, @xyz_fract, @cell_length_abc);
# Return:
# phase(in radians)
# for ex.: 
# phase_hkl( @hkl, @xyz_fract, @cell_length_abc) = 1.12;
sub atom_phase_hkl_rad 
{
    my( $h, $k, $l, $fract_x, $fract_y, $fract_z ) = @_;
    return 2 * $PI * ($h * $fract_x + $k * $fract_y +
                       $l * $fract_z);   
}

# Function for temperature factor calculation (anisotropic);
# equation from "Principles of protein X-ray crystallography",
# Jan Drenth, page 94; T(aniso; hkl)=..
# 
# Parameters:
# temperature_factor_aniso( U11, U22, U33, U23, U13, U12, h, k, l, a*, b*, c* );
# Return:
# T(aniso, hkl).
sub temperature_factor_aniso 
{
    my( $U_11, $U_22, $U_33, $U_23, $U_13, $U_12,
        $h, $k, $l, $repro_length_a, $repro_length_b, $repro_length_c ) = @_;
    return exp( (-2 * $PI**2) *
                ($U_11 * ($h**2) * ($repro_length_a**2) +
                 $U_22 * ($k**2) * ($repro_length_b**2) +
                 $U_33 * ($l**2) * ($repro_length_c**2) +
                 2 * $U_12 * $h * $k * $repro_length_a * $repro_length_b +
                 2 * $U_13 * $h * $l * $repro_length_a * $repro_length_c +
                 2 * $U_23 * $k * $l * $repro_length_b * $repro_length_c ) );
}


# Function for symmetric transformations of atom positions for receiving of 
# symmetrical atoms.
#
# Parameters: 
# 1. values - a reference to array of hashes where a data from the CIF
# file is stored; 2. name of CIF file; 3. refence to orthogonalization matrix
# for orthogonal coordinates calculation.
# f.e.: cell_filling_sym( \[\%1, \%2, ..], "0022254", \matrix );
#
# Return: 
# \@sym_atom_info = (
#           # [0]
#           {
#               symmetrical_xyz_fract => [\@xyz1, \@xyz2, .. ],
#               symmetrical_xyz_ortho => [\@xyz1, \@xyz2, .. ],
#               
#            }, 
#        .. )
sub cell_filling_sym 
{
    my( $datablock, $filename, $f2o ) = @_;
    my $values =  $datablock->{values};    
    my @xyz_arrays =
        ( remove_standard_uncertainties( 
              $values->{_atom_site_fract_x} ),
          remove_standard_uncertainties( 
              $values->{_atom_site_fract_y} ),
          remove_standard_uncertainties( 
              $values->{_atom_site_fract_z} ) ); 
    
    my $sym_data;    
    if( exists $values->{"_symmetry_equiv_pos_as_xyz"} )
    {
        $sym_data = $values->{"_symmetry_equiv_pos_as_xyz"};
    }
    
    if( exists $values->{"_symmetry_space_group_name_hall"} &&                  
       (not defined $sym_data) ) {
        
        my $hall = $values->{"_symmetry_space_group_name_hall"}[0];
        $sym_data = get_symops("hall", $hall);        
        if( $sym_data == 0 ) {
            print STDERR "ERR: " . &File::Basename::fileparse($0) . ": ";
            print STDERR "'$filename': ";
            print STDERR "There was incorrect _symmetry_space_group_name_Hall "
                . $hall . "\n";
        }
    }
    
    if( exists $values->{"_symmetry_space_group_name_h-m"} &&                   
       ((not defined $sym_data) or $sym_data == 0) ) {
        my $h_m = $values->{"_symmetry_space_group_name_h-m"}[0];
        $sym_data = get_symops("hermann_mauguin", $h_m);
        
        if( $sym_data == 0 ) {
            print STDERR "ERR: " . &File::Basename::fileparse($0) . ": ";
            print STDERR "'$filename': ";
            print STDERR "There was incorrect _symmetry_space_group_name_H-M "
                . $h_m . "\n";
            die;          # data of space group is empty or incorrect;
        }
    }
    
    my @sym_operators = map{ SymopParse::symop_from_string($_) } @{$sym_data};

    my $atoms_number_of_cell = 0;    
    my @sym_atom_info;
    foreach my $i (0..$#{$values->{_atom_site_label}}) {
        my %sym_atom_coordinates;
        my $fract_xyz = [ $xyz_arrays[0]->[$i],
                          $xyz_arrays[1]->[$i],
                          $xyz_arrays[2]->[$i] ];

        for(my $i = 0; $i < @sym_operators; $i++) {
            my $symop = $sym_operators[$i]; # 
            ## print "$symop\n";

            my $new_xyz_fract = 
                symop_apply( [@{$fract_xyz}, 1], $symop);
            $new_xyz_fract = [ @{$new_xyz_fract}[0..2] ];
            ## print "@{$new_xyz_fract}\n";
            my $new_xyz_ortho = mat_vect_mul( $f2o, 
                                              $new_xyz_fract );
            ## print "@{$new_xyz_ortho}\n";
            $atoms_number_of_cell++;

            if( exists $sym_atom_coordinates{symmetrical_xyz_fract} ) { 
                push( @{$sym_atom_coordinates{symmetrical_xyz_fract}}, 
                      $new_xyz_fract);
            } else {
                $sym_atom_coordinates{symmetrical_xyz_fract} = 
                    [$new_xyz_fract];
            } 
            if(exists $sym_atom_coordinates{symmetrical_xyz_ortho}) { 
                push( @{$sym_atom_coordinates{symmetrical_xyz_ortho}}, 
                      $new_xyz_ortho );
            } else {
                $sym_atom_coordinates{symmetrical_xyz_ortho} = 
                    [$new_xyz_ortho];
            }             
        }                       # end of for;
        push( @sym_atom_info, \%sym_atom_coordinates);
    }                           # end of foreach;
    # only for first element adding the atoms full count of crystal cell;
    $sym_atom_info[0]{count_of_cell_atoms} = $atoms_number_of_cell;

    return \@sym_atom_info;
}


#---------------------------------------------------------------
# functions get_symops() and symop_apply() code was 
# copied from 'cif_fillcell' script. rev. 1440;
#===============================================================#
# @SymopLookup::table =
# (
# {
#     number          => 1,
#     hall            => ' P 1',
#     schoenflies     => 'C1^1',
#     hermann_mauguin => 'P 1',
#     universal_h_m   => 'P 1',
#     symops => [
#         'x,y,z',
#     ],
#     ncsym => [
#         'x,y,z',
#     ]
# },
# );

sub get_symops
{
    my ($option, $param) = @_;

    $param =~ s/ //g;
    $param =~ s/_//g;

    foreach my $hash (@SymopLookup::table)
    {
        my $value = $hash->{$option};
        $value =~ s/ //g;
        $value =~ s/_//g;

        if($value eq $param)
        {
            return $hash->{symops};
        }
    }
    return 0;
}

#===============================================================#
sub symop_apply
{
        my($atom_xyz, $symop) = @_;
        my @new_atom_xyz;

        for(my $i = 0; $i < @{$symop}; $i++)
        {
                $new_atom_xyz[$i] = 0;
                for(my $j = 0; $j < @{$symop}; $j++)
                {
                        ${$atom_xyz}[$j] =~ s/\(\d+\)$//;
                        $new_atom_xyz[$i] += ${$atom_xyz}[$j] * ${$symop}[$i][$j];
                }
                $new_atom_xyz[$i] = SymopParse::modulo_1($new_atom_xyz[$i]);
        }

        return \@new_atom_xyz;
}

#----------------------------------------------------------------------#
# Function which contains tests block;
#
# Parameters:
#    f.e. tests_outputs( 1, 2, 3), where
#    1. output of atoms_from_cif(); 2. name of file; 3.
#    output of get_unit_cell_parameters;
# 
# Return:
# Print outputs of tests.
sub tests_outputs 
{
    my( $atoms, $file_name, $cell_parameters ) = @_;
    if( $dump_xyz_coordinates ) { 
        print $#$atoms+1, "\n";
        print "$file_name\n";
            foreach my $atom (@$atoms) {
                printf "%2s %.5f %.5f %.5f\n", $atom->{chemical_type}, 
                @{$atom->{coordinates_ortho}};
            }
        exit;
    }
    if( $dump_Cromer_Mann_parameters ) {
        print "$file_name\n";
        foreach my $atom (@$atoms) {
            print "$atom->{label} "."$atom->{chemical_type} ",
            $atom->{Crommer_Mann_coefficients}[0] ? 
                "@{$atom->{Crommer_Mann_coefficients}}\n" : "Empty\n";
        }
        exit;
    }
    if( $dump_cell_parameters ) {            
        printing_of_dump_cell_parameters( $file_name, $cell_parameters );
        exit;
    }    
    if( $dump_cell_xyz_coordinates ) { 
        print $atoms->[0]{count_of_cell_atoms}, "\n";
        print "$file_name\n";
        foreach my $atom (@$atoms) {
            foreach my $sym_xyz (@{$atom->{symmetrical_xyz_ortho}}) {
                printf "%2s %.5f %.5f %.5f\n", $atom->{chemical_type}, 
                @{$sym_xyz};
            }
        }
        exit;
    }
}

