#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Compute the structure factors from CIF files.
#**

# The implementation in this programm follows the principles published
# in:

# (Yvon1977) Yvon, K.; Jeitschko, W. & ParthÃ©, E. it LAZY PULVERIX, a
# computer program, for calculating X-ray and neutron diffraction
# powder patterns Journal of Applied Crystallography, 1977, 10, 73-74
# http://dx.doi.org/10.1107/S0021889877012898

use strict;
use lib "./lib/perl5";
use lib "./CIFParser";
use lib "./CCIFParser";
use lib "./CIFTags";
use lib ".";
use File::Basename;
use CIFParser;
use Spacegroups::SpacegroupNames;
use Spacegroups::SymopParse;
use Spacegroups::SymopLookup;
use SOptions;
use SUsage;

use Fractional;

my $use_parser = "c";
my $dump_xyz_coordinates = 0;
my $dump_Cromer_Mann_parameters = 0;
my $dump_cell_parameters = 0;
my $synthetic_test1 = 0;

# constants;
my $PI = 4*atan2( 1, 1 );

#* USAGE:
#*     $0 --options input1.cif input*.cif
#* 
#* OPTIONS:
#*    --use-perl-parser  Use development CIF parser written in Perl
#*    --use-c-parser     Use faster C/Yacc CIF parser (default)
#*    --dump-xyz-coordinates Print a XYZ file 
#*    --dump-Cromer-Mann Print a Cromer-Mann coefficients from CIF file
#*    --dump-cell-parameters Print a short usage message with cell parameters
#*    --synthetic-test1 Print a short usage message of various parameters.
#*    --help,--usage         Print a short usage message (this message) and exit.
#**

@ARGV = getOptions( 
    "--use-perl-parser"  => sub{ $use_parser = "perl" },
    "--use-c-parser"     => sub{ $use_parser = "c" },

    "--options"          => sub { 
        print "$0: The '--options' option is a placehoder.\n";
        print "$0: It should be replaced by one of the following options:\n";
        ## SUsage::usage;
        open( SCRIPT, $0 ) or die $!;
        while( <SCRIPT> ) {
            if( /^#\*\s+OPTIONS:/../^#\*\*/ ) {
                s/^#\*\s+OPTIONS://;
                s/^#\*\*?\s+//;
                print;
            }
        }
        close( SCRIPT );
        exit
    },
    "--dump-xyz-coordinates"    => sub { $dump_xyz_coordinates = 1 },
    "--dump-Cromer-Mann"    => sub { $dump_Cromer_Mann_parameters = 1 },
    "--dump-cell-parameters"    => sub { $dump_cell_parameters = 1 },
    "--synthetic-test1"    => sub { $synthetic_test1 = 1 },
    "--help,--usage"     => sub { SUsage::usage; exit },
);

#==============================================================================#
# Forward subroutine definitions:
sub mat_vect_mul( $$ );
sub get_unit_cell( $$ );


@ARGV = ( "-" ) unless @ARGV;

for my $filename (@ARGV) {

    my( $data, $error_count );

    if( $use_parser eq "perl" ) {
        my $parser = new CIFParser;

        $data = $parser->Run( $filename );

        if( defined $parser->YYData->{ERRCOUNT} ) {
            $error_count = $parser->YYData->{ERRCOUNT};
        }
    } else {
        require CCIFParser;
        ( $data, $error_count ) = CCIFParser::parse( $filename );
    }

    if( defined $error_count && $error_count > 0 ) {
        print STDERR "$0: ", $error_count,
        " error(s) encountered while parsing file '${filename}'\n";
        die;
    }

    if( !@$data || !defined $data->[0] || !defined $data->[0]{name} ) {
        warn( "file '$filename' seems to be empty" );
        next;
    }
    
    for my $datablock (@$data) {
        
        my $radiation_wavelengths = remove_standard_uncertainties(
            $datablock->{values}{_diffrn_radiation_wavelength} );
        ## print "$radiation_wavelengths->[0]\n";
        die "The value of Xray radiation wavelength is empty." 
            if (!defined $radiation_wavelengths->[0]);
        die "The CIF contains more than one value of Xray radiation wavelength." 
            if ($#{$radiation_wavelengths}>0);
        
        my @cell = get_unit_cell( $datablock, $filename );
        my $f2o = symop_ortho_from_fract( @cell );
        ## print "@{$f2o->[0]}\n";
        my $atoms = atoms_from_cif( $datablock, $f2o );
        my $cell_parameters = get_unit_cell_parameters ( $datablock );
        ## print "@cell\n";
        if( $dump_xyz_coordinates ) { 
            print $#$atoms+1, "\n";
            print "$datablock->{name}\n";
            foreach my $atom (@$atoms) {
                printf "%2s %.5f %.5f %.5f\n", $atom->{chemical_type}, 
                @{$atom->{coordinates_ortho}};
            }
        }      
        if ( $dump_Cromer_Mann_parameters ) {
            print "$datablock->{name}\n";
            foreach my $atom (@$atoms) {
                print "$atom->{label} "."$atom->{chemical_type} ",
                $atom->{Crommer_Mann_coefficients}[0] ? 
                    "@{$atom->{Crommer_Mann_coefficients}}\n" : "Empty\n";
            }
        }        
        if ( $dump_cell_parameters ) {            
            printing_of_dump_cell_parameters( $datablock, $cell_parameters );
        }
        # for &cell_filling_sym testing;
        if (0) {
            cell_filling_sym( $datablock, $filename, $atoms, $f2o);
            exit;
        }
        
        unless ( $dump_Cromer_Mann_parameters || $dump_cell_parameters || 
                 $dump_xyz_coordinates ) {
            #--------------------------------------------------
            # temporary code for testing
            if (0) {
                print "$datablock->{name}\n";
                foreach my $atom (@$atoms) {
                    local $,=' ';
                    print "$atom->{label} "."$atom->{chemical_type} ".
                        "$atom->{U_value_of_B_factor} $atom->{B_factor}",
                        $atom->{aniso_value_Uij}[0] ? 
                        @{$atom->{aniso_value_Uij}} : "EMPTY" ,"\n";
                }
            }
            #-------------------------------------------------
            my ($h_max, $h_min, 
                $k_max, $k_min, 
                $l_max, $l_min) = @{ hkl_limits( $datablock )};
	    my @abc_star = @{$cell_parameters->{reciprocal_cell_radians}}[0..2];
	    
            foreach my $h_limit ($h_min..$h_max) {
            foreach my $k_limit ($k_min..$k_max) {   
            foreach my $l_limit ($l_min..$l_max) {  
                my @hkl = ($h_limit, $k_limit, $l_limit);
                next if ($h_limit==0 && $k_limit==0 && $l_limit==0);
                ## local $,=' ';
                ## print @hkl,"\n";
                my $resolution_hkl = spacing_d_hkl( 
                    @hkl, 
                    @{$cell_parameters->{reciprocal_cell_radians}} );
                my $sin_teta_hkl = 
                    $radiation_wavelengths->[0] / (2 * $resolution_hkl);
                ## print "$sin_teta_hkl\n";
                # Temporary local test which will be removed after
                # creating *pm with outer Cromer Mann coefficients.

                # --------------------------------------------
                die "CIF file does not contain Crommer-Mann coefficients." 
                    if ( !defined $atoms->[0]{Crommer_Mann_coefficients}[0] ); 
                #--------------------------------------------------------------
                my $F_cos_comp_w_Tf_and_cor = 0; 
                my $F_sin_comp_w_Tf_and_cor = 0;
                my $F_cos_comp_w_cor = 0;
                my $F_sin_comp_w_cor = 0;
                my ($F_cos_comp_aniso_w_cor, 
                    $F_sin_comp_aniso_w_cor) = (0,0);
		
                foreach my $atom (@$atoms) {                
                    my $atom_structure_factor = 
                        atom_structure_factor_from_coefficients( 
                            $atom->{Crommer_Mann_coefficients}, 
                            $radiation_wavelengths->[0],
                            $sin_teta_hkl );
                    # print "Atom structure factor: $atom_structure_factor\n";
                    ## print "$atom_structure_factor\n";
                    my $atom_hkl_phase = atom_phase_hkl_rad( 
                        @hkl, 
                        @{$atom->{coordinates_fract}} );
                    if (0) { # local temporary test for atomic struct.factor;
                        if ($atom->{label} eq "Cl1") {
                            printf "%3s %3s %3s  %0.3f %0.3f %0.4f\n", 
                            @hkl, $resolution_hkl, 1/(2 * $resolution_hkl),
                            $atom_structure_factor;
                        }
                    }
                    # print "Phase of atom: $atom_hkl_phase\n";
                    ## print "$atom_structure_factor\n";
                    $F_cos_comp_w_Tf_and_cor +=
                        $atom->{occupancy} * 
                        $atom_structure_factor * cos( $atom_hkl_phase );
                    $F_sin_comp_w_Tf_and_cor +=
                        $atom->{occupancy} * 
                        $atom_structure_factor * sin( $atom_hkl_phase );
                    my $temperature_factor_ISO = 
                        exp( ( -$atom->{B_factor}/4 ) * 
                             ( 1/$resolution_hkl )**2 );
                    # print "$atom->{chemical_type}  $temperature_factor_ISO\n";
                    # structure factor components without corrections;
                    $F_cos_comp_w_cor +=
                        $atom->{occupancy} * $atom_structure_factor * 
                        $temperature_factor_ISO * cos( $atom_hkl_phase );
                    $F_sin_comp_w_cor += 
                        $atom->{occupancy} * $atom_structure_factor * 
                        $temperature_factor_ISO * sin( $atom_hkl_phase );
                    # structure factor components
		    unless ($synthetic_test1) {
			my $temperature_factor_ANISO;
			if ($atom->{chemical_type} eq "H") {
			    $temperature_factor_ANISO = 1;
			} else {
			    $temperature_factor_ANISO = 
				temperature_factor_aniso( 
				    @{$atom->{aniso_value_Uij}},
				    @hkl, @abc_star);
			}
			$F_cos_comp_aniso_w_cor += 
			    $atom->{occupancy} * $atom_structure_factor *
			    $temperature_factor_ANISO * cos( $atom_hkl_phase );
			$F_sin_comp_aniso_w_cor += 
			    $atom->{occupancy} * $atom_structure_factor *
			    $temperature_factor_ANISO * sin( $atom_hkl_phase );
		    } # end unless;
                        
                }
                
                my $F_hkl_without_Tf_and_cor = 
                    sqrt( $F_cos_comp_w_Tf_and_cor**2 + 
                          $F_sin_comp_w_Tf_and_cor**2 );
                my $F_hkl_iso_without_cor = 
                    sqrt( $F_cos_comp_w_cor**2 + $F_sin_comp_w_cor**2 ); 
                my $F_hkl_aniso_without_cor = 
                    sqrt( $F_cos_comp_aniso_w_cor**2 + 
                          $F_sin_comp_aniso_w_cor**2);

                if ( $synthetic_test1 ) {
                    print "  H   K   L  RESO  sin(theta)  F  1/2d   F_cos  "
                        ."F_sin\n";
                    printf "%3s %3s %3s  %0.3f %0.5f %0.3f %0.3f %0.3f "
                        ."%0.3f\n", @hkl, $resolution_hkl, $sin_teta_hkl, 
                        $F_hkl_without_Tf_and_cor, 1/(2 * $resolution_hkl), 
                        $F_cos_comp_w_Tf_and_cor, $F_sin_comp_w_Tf_and_cor;
                }
                
                if (0) {
                    printf "%3s %3s %3s %0.3f %0.3f %0.3f %0.3f %0.3f\n", 
                    @hkl, $resolution_hkl, 
                    $F_hkl_without_Tf_and_cor, 
                    $F_hkl_iso_without_cor,
                    $F_hkl_aniso_without_cor,
                    $F_hkl_iso_without_cor**2;
                }
            }}}
            
        }
    }
}


#===============================================================#
# Extract unit cell angles and lengths.
#
# Accepts
#     values - a hash where a data from the CIF file is stored
# Returns
#     cell - an array  with stored information.

sub get_unit_cell($$)
{
    my( $datablock, $filename ) = @_;

    my $values = $datablock->{values};
    my $dataname = $datablock->{name};

    my @cell;

    for my $cif_tag (qw(_cell_length_a
                        _cell_length_b
                        _cell_length_c
                        )) {
        push(@cell, $values->{$cif_tag}[0]);
        $cell[-1] =~ s/\(\d+\)$//;
    }

    for my $cif_tag (qw(_cell_angle_alpha
                        _cell_angle_beta
                        _cell_angle_gamma
                        )) {
        if( exists $values->{$cif_tag} ) {
            push( @cell, $values->{$cif_tag}[0] );
            $cell[-1] =~ s/\(\d+\)$//;
        } else {
            warning( $0, $filename, $dataname,
                     "cell angle '$cif_tag' not present -- " .
                     "taking default value 90 degress." );
            push( @cell, 90 );
        }
    }

    return @cell;
}

#===============================================================#
# Multiplies an ortho matrix with a vector.

# my $ortho = [
#     [ o11 o12 o13 ]
#     [ 0   o22 o23 ]
#     [ 0   0   o33 ]
# ]
#

sub mat_vect_mul($$)
{
    my($matrix, $vector) = @_;

    my @new_coordinates;

    for(my $i = 0; $i < @{$vector}; $i++)
    {
        $new_coordinates[$i] = 0;
        for(my $j = 0; $j < @{$vector}; $j++)
        {
            $new_coordinates[$i] += ${$matrix}[$i][$j] * ${$vector}[$j];
        }
    }

    if( @$vector == 3 && @$matrix == 4 ) {
        $new_coordinates[0] += $matrix->[0][3];
        $new_coordinates[1] += $matrix->[1][3];
        $new_coordinates[2] += $matrix->[2][3];
    }

    return wantarray ? @new_coordinates : \@new_coordinates;
}

#-------------------------------------------------------------------#
# Remove the standart deviation (standard uncertainties) components
# from input data; 
# Parameters: reference to an array with scalar
# values; for ex.: 0.21582(8) 
# Return: reference to an array without
# std. deviations; for ex.: 0.21582

sub remove_standard_uncertainties
{
    my ($input) = @_;
    return [ map { my $value = $_;
                   $value =~ s/\(\d+\)//; $value } @{$input} ];
}

#--------------------------------------------------------------------#
# Function of extracting atom information from the CIF file.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Returns:
# \@atoms = (
#           # [0]
#           {
#               site_label => "O10",
#               chemical_type => "O",
#               coordinates_fract" => [0.1, 0.2, 0.3],
#               coordinates_ortho => [10, 20.5, 25.2],
#               occupancy => 0.5,
#               B_factor => 0.78,
#               U_value_of_B_factor => 0.03,
#               aniso_value_Uij => [0.01, 0.002, 0.003,..,0.006] # 6 values,
#               Crommer_Mann_coefficients => [1.10, .., .., ] # 9 values;
# a1, a2, .., b1, b2.., b4, c.
#           },
#           # [1]
#           {
#               site_label => "C11",
#               chemical_type => "C",
#               coordinates_fract" => [0.2, 0.25, 0.35],
#           },
#  );   

sub atoms_from_cif 
{ 
    my ($datablock, $f2o) = @_;
    my @atoms;
    my $datablock_values = $datablock->{values};
    my @xyz_arrays =
        ( remove_standard_uncertainties( 
              $datablock_values->{_atom_site_fract_x} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_fract_y} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_fract_z} ) );    
    my $occupancy = 
        remove_standard_uncertainties( 
            $datablock_values->{_atom_site_occupancy} );
    
    my $Cromer_Mann_coefficients = get_Cromer_Mann_coefficients( $datablock );
    my $themal_coefficients = get_thermal( $datablock );
    
    for my $i (0..$#{$datablock_values->{_atom_site_label}}) {
        my $fract_xyz = [ $xyz_arrays[0]->[$i],
                          $xyz_arrays[1]->[$i],
                          $xyz_arrays[2]->[$i] ];
        my $ortho_xyz = 
            mat_vect_mul( $f2o,  $fract_xyz );
        
        my %atom_info = ( 
            label => $datablock_values->{_atom_site_label}[$i],
            chemical_type => $datablock_values->{_atom_site_type_symbol}[$i],
            coordinates_fract => $fract_xyz,
            coordinates_ortho => $ortho_xyz,
            occupancy => $occupancy->[$i]                     
            );
        # 
        %atom_info = (%atom_info, %{$Cromer_Mann_coefficients->[$i]});
        %atom_info = (%atom_info, %{$themal_coefficients->[$i]});
        push( @atoms, \%atom_info );
    }
    return \@atoms;
}

#--------------------------------------------------------------------#
# Function of extracting atoms Crommer-Mann coefficients the CIF file.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Returns:
# \@ = (
#           # [0]
#           {
#               Crommer_Mann_coefficients => [1.10, .., .., ] # 9 values;
# a1, a2, .., b1, b2.., b4, c.
#           },
#           # [1]
#           {
#               Crommer_Mann_coefficients => [1.10, .., .., ]
#           },
#  );   

sub get_Cromer_Mann_coefficients
{
    my ($datablock) = @_;
    my $datablock_values = $datablock->{values};
    my @atoms_aniso_coefficients;
    
    my $labels = $datablock_values->{_atom_site_label};
    my $chemical_type_of_aniso_propierties_loop = 
        $datablock_values->{_atom_type_symbol};
    my $Cromer_Mann_coefficients = 
        [ $datablock_values->{_atom_type_scat_cromer_mann_a1},
          $datablock_values->{_atom_type_scat_cromer_mann_a2},
          $datablock_values->{_atom_type_scat_cromer_mann_a3},
          $datablock_values->{_atom_type_scat_cromer_mann_a4},
          $datablock_values->{_atom_type_scat_cromer_mann_b1},
          $datablock_values->{_atom_type_scat_cromer_mann_b2},
          $datablock_values->{_atom_type_scat_cromer_mann_b3},
          $datablock_values->{_atom_type_scat_cromer_mann_b4},
          $datablock_values->{_atom_type_scat_cromer_mann_c} ];
    for my $i (0..$#{$labels}) {
        my $atom_chemical_type = 
            $datablock_values->{_atom_site_type_symbol}[$i];
        for my $y (0..$#{$chemical_type_of_aniso_propierties_loop}) {
            
            if ( $atom_chemical_type eq 
                 $chemical_type_of_aniso_propierties_loop->[$y] ) {
                my %thermal = (
                    Crommer_Mann_coefficients => [
                        $Cromer_Mann_coefficients->[0][$y],
                        $Cromer_Mann_coefficients->[1][$y],
                        $Cromer_Mann_coefficients->[2][$y],
                        $Cromer_Mann_coefficients->[3][$y],
                        $Cromer_Mann_coefficients->[4][$y],
                        $Cromer_Mann_coefficients->[5][$y],
                        $Cromer_Mann_coefficients->[6][$y],
                        $Cromer_Mann_coefficients->[7][$y],
                        $Cromer_Mann_coefficients->[8][$y] ]
                    ); 
                push ( @atoms_aniso_coefficients, \%thermal );
                
            } # end of if;
        } # second for     
    } # first for 
    return \@atoms_aniso_coefficients;
}

#--------------------------------------------------------------------#
# Function of extracting atoms anisotropic and isotropic 
# thermal parameteres the CIF file.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Returns:
# \@ = (
#           # [0]
#           {
#               B_factor => 0.78,
#               U_value_of_B_factor => 0.03,
#               aniso_value_Uij => [0.01, 0.002, 0.003,..,0.006] # 6 values,
#           },
#           # [1]
#           {
#               B_factor => 0.78,
#               U_value_of_B_factor => 0.03,
#               aniso_value_Uij => [0.01, 0.002, 0.003,..,0.006] # 6 values,
#           },
#  );  

sub get_thermal
{
    my ($datablock) = @_;
    my $datablock_values = $datablock->{values};
    my @atoms_thermal_coefficients;
    
    my $thermal_parameter_B = 
        remove_standard_uncertainties( 
            $datablock_values->{_atom_site_b_iso_or_equiv} );
    my $squared_displacement_U = 
        remove_standard_uncertainties( 
            $datablock_values->{_atom_site_u_iso_or_equiv} );
    my @anisotrophic_U_ij_values = 
        ( remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_11} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_22} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_33} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_23} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_13} ),
          remove_standard_uncertainties( 
              $datablock_values->{_atom_site_aniso_u_12} ) ); 
    # _atom_site_aniso_label needs for extracting of anisotrophic values; 
    my %temporary_aniso_data;
    for my $i (0..$#{$datablock_values->{_atom_site_aniso_label}}) {
        my $atom_aniso_label = 
            $datablock_values->{_atom_site_aniso_label}[$i];
        $temporary_aniso_data{$atom_aniso_label} = 
            [ $anisotrophic_U_ij_values[0]->[$i],
              $anisotrophic_U_ij_values[1]->[$i],
              $anisotrophic_U_ij_values[2]->[$i],
              $anisotrophic_U_ij_values[3]->[$i],
              $anisotrophic_U_ij_values[4]->[$i],
              $anisotrophic_U_ij_values[5]->[$i] ];
    }
    # 
    for my $i (0..$#{$datablock_values->{_atom_site_label}}) {
        my $atom_label = $datablock_values->{_atom_site_label}[$i];
        my %thermal_info = (
            B_factor => ($thermal_parameter_B->[$i] ? $thermal_parameter_B->[$i] : 
             8 * ($PI**2) * $squared_displacement_U->[$i]
            ),
            U_value_of_B_factor => $squared_displacement_U->[$i],
            aniso_value_Uij => $temporary_aniso_data{$atom_label}
            );
        push ( @atoms_thermal_coefficients, \%thermal_info );
    }
    return \@atoms_thermal_coefficients;
}


#--------------------------------------------------------------------#
# Function of extracting unit-cell parameters of the CIF file.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Return
# $a = {
#        crystall_cell => [a, b, c, alpha, beta, gamma ],    
#        cell_volume => 14.055,
#        reciprocal_cell => [a*, b*, c*, alpha*, beta*, gamma*]
#      }
sub get_unit_cell_parameters
{
    my ($datablock) = @_;
    my $datablock_values = $datablock->{values};
    
    my @crystal_lattice =  ( ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_length_a} )}[0],
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_length_b} )}[0],
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_length_c} )}[0],
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_angle_alpha} )}[0],        
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_angle_beta} )}[0],
                             ${ remove_standard_uncertainties( 
                                    $datablock_values->{_cell_angle_gamma} )}[0] );
    # @crystal_lattice = ( a[0], b[1], c[2], alpha[3], beta[4], gamma[5] );
    my $cell_volume = ${remove_standard_uncertainties( 
        $datablock_values->{_cell_volume} )}[0];
    my ($a, $b, $c, $alpha, $beta, $gamma) = @crystal_lattice;
    my @crystal_cell_radians = 
        ($a, $b, $c, deg2rad( $alpha, $beta, $gamma ));
    # alpha between b and c; beta between a and c; gamma between a and b.
    # @star_crystal_lattice = ( a*[0], b*[1], c*[2], alpha*, beta*, gamma*[5] );
    my @abc_star_values = ( 
        d2r_length( $b, $c, deg2rad( $alpha ), $cell_volume ), # a*
        d2r_length( $a, $c, deg2rad( $beta ), $cell_volume ), # b*
        d2r_length( $a, $b, deg2rad( $gamma ), $cell_volume )  # c*
        ); 
    my @alpha_beta_gamma_star_radians = (
        d2r_angle( deg2rad( $beta, $gamma, $alpha ) ), # alpha*
        d2r_angle( deg2rad( $alpha, $gamma, $beta) ),  # beta*
        d2r_angle( deg2rad( $alpha, $beta, $gamma) ));  # gamma*
    my  @alpha_beta_gamma_star_degrees = 
        rad2deg( @alpha_beta_gamma_star_radians );
    my @star_crystal_cell_parameters_degrees = 
        (@abc_star_values, @alpha_beta_gamma_star_degrees);
    my @star_crystal_cell_parameters_radians = 
        (@abc_star_values, @alpha_beta_gamma_star_radians);
    my $crystal_par = { 
        crystal_cell_degrees => \@crystal_lattice,
        crystal_cell_radians => \@crystal_cell_radians,
        cell_volume => $cell_volume,
        reciprocal_cell_degrees => \@star_crystal_cell_parameters_degrees,
        reciprocal_cell_radians => \@star_crystal_cell_parameters_radians
    };
    return $crystal_par;
}

#--------------------------------------------------------------------#
# Function of converting lattice parameters (length of cell edges):
# from direct space to reciprocal.
#
# Parameters:
# for example  c* = d2r_length( a, b, angle(a,b), cell_volume );
# Return:
# for example 0.554 [angstrom**-1]
sub d2r_length 
{
    my ($c_length1, $c_length2, $angle1_2, $cell_vol) = @_;
    return ($c_length1 * $c_length2 * sin( $angle1_2 )) / $cell_vol;
} 

#--------------------------------------------------------------------#
# Function of converting lattice parameters (cell angles):
# from direct space to reciprocal.
#
# Parameters and return:
# gamma* = d2r_angle( alpha, beta, GAMMA );
# beta* = d2r_angle( alpha, gamma, BETA );
# alpha* = d2r_angle( beta, gamma, ALPHA );
sub d2r_angle 
{
    my ($angle1, $angle2, $angle_which_converts) = @_;
    return POSIX::acos(
        (cos( $angle1 ) * cos( $angle2 ) -
         cos( $angle_which_converts)) / 
        (sin( $angle1 ) * sin( $angle2 )) );    
}

#----------------------------------------------------------------------#
# Function for calculation the distance(resolution) between hkl layers.
#
# Parameters:
# hkl (index of reflection), reciprocal lattice.
# for ex.: spacing_d_hkl( h, k, l, a*, b*, c*, alpha*, beta*, gamma* )
# Return
# hkl resolution (in angstrom): 5. 
sub spacing_d_hkl {
    my ($h, $k, $l, 
        $a_star, $b_star, $c_star,
        $alpha_star, $beta_star, $gamma_star) = @_;
    return 1 /
	sqrt( ($h ** 2) * ($a_star ** 2) +
              ($k ** 2) * ($b_star ** 2) +
              ($l ** 2) * ($c_star ** 2) +
              2 * $h * $k * $a_star * $b_star * cos( $gamma_star ) +
              2 * $h * $l * $a_star * $c_star * cos( $beta_star ) +
              2 * $k * $l * $b_star * $c_star * cos( $alpha_star ) );
}

#----------------------------------------------------------------------#
# Function for extracting the limits of the Miller indices.
#
# Parameters:
#    values - a reference to array of hashes where a data from the CIF
#    file is stored
#
# Return
# \(h_max,h_min,k_max,k_min,l_max,l_min);
sub hkl_limits
{
    my ($datablock) = @_;
    my $datablock_values = $datablock->{values};
    return [ ${$datablock_values->{_diffrn_reflns_limit_h_max}}[0],
             ${$datablock_values->{_diffrn_reflns_limit_h_min}}[0],
             ${$datablock_values->{_diffrn_reflns_limit_k_max}}[0],
             ${$datablock_values->{_diffrn_reflns_limit_k_min}}[0],
             ${$datablock_values->{_diffrn_reflns_limit_l_max}}[0],
             ${$datablock_values->{_diffrn_reflns_limit_l_min}}[0] ];   
}

#----------------------------------------------------------------------#
# Function converts degree to radian.
# deg2rad( 180 ) = Pi;
# deg2rad( angle1(deg), angle2(deg), .. ) = ( angle1(rad) , angle2(rad), .. );
sub deg2rad
{
    return map{ ($_ * $PI) / 180 } @_;
}

#----------------------------------------------------------------------#
# Function converts radian to degree.
# rad2deg( Pi ) = 180;
# rad2deg( angle1(rad), angle2(rad), .. ) = ( angle1(deg) , angle2(deg), .. );
sub rad2deg
{
    return map { ($_ * 180) / $PI } @_;
}

#----------------------------------------------------------------------#
# Print output of option --dump-cell-parameters.
sub printing_of_dump_cell_parameters
{  
    my ($datablock, $cell_parameters) = @_;
    print "$datablock->{name}\n";
    printf "%15s %0.5f %0.5f %0.5f %0.5f %0.5f %0.5f\n", 
    "Direct cell     (deg)", @{$cell_parameters->{crystal_cell_degrees}};
    printf "%15s %0.5f %0.5f %0.5f %0.5f %0.5f %0.5f\n", 
    "Direct cell     (rad)", @{$cell_parameters->{crystal_cell_radians}};
    printf "%15s %0.5f %0.5f %0.5f %0.5f %0.5f %0.5f\n", 
    "Reciprocal cell (deg)", @{$cell_parameters->{reciprocal_cell_degrees}};
    printf "%15s %0.5f %0.5f %0.5f %0.5f %0.5f %0.5f\n", 
    "Reciprocal cell (rad)", @{$cell_parameters->{reciprocal_cell_radians}};
    printf "%15s %0.5f\n", 
    "Volume         ", $cell_parameters->{cell_volume}; 
}

#----------------------------------------------------------------------#
# Function for atom structure factor calculation.
#
# Parameters:
# [ Cromer_Mann coefficients: a1, .., a4, b1, .., b4, c ], diff. wavelength,
# sin(teta_hkl);
#
# Return:
# Value of atom structure factor which depends on wavelength and sin(teta_hkl)
# for ex.:
# atom_structure_factor_from_coefficient([a1,..,c],1.54, 0.33) = 1.4;
sub atom_structure_factor_from_coefficients {
    my ($Cromer_Mann, $wavelenth, $sin_theta_hkl) = @_;
    my ($a1, $a2, $a3, $a4, $b1, $b2, $b3, $b4, $c) = @{$Cromer_Mann};
    return 
	$a1 * exp( -$b1 * ($sin_theta_hkl / $wavelenth)**2 ) +
	$a2 * exp( -$b2 * ($sin_theta_hkl / $wavelenth)**2 ) +
	$a3 * exp( -$b3 * ($sin_theta_hkl / $wavelenth)**2 ) +
	$a4 * exp( -$b4 * ($sin_theta_hkl / $wavelenth)**2 ) +
	$c;
}

#----------------------------------------------------------------------#
# Function for calculation of atom hkl_phase. 
#
# Parameters: 
# phase_hkl( @hkl, @xyz_fract, @cell_length_abc);
# Return:
# phase(in radians)
# for ex.: 
# phase_hkl( @hkl, @xyz_fract, @cell_length_abc) = 1.12;
sub atom_phase_hkl_rad {
    my ($h, $k, $l,
        $fract_x, $fract_y, $fract_z) = @_;
    return 2 * $PI * ( $h * $fract_x + $k * $fract_y +
                       $l * $fract_z );   
}

# Function for temperature factor calculation (anisotropic);
# equation from "Principles of protein X-ray crystallography",
# Jan Drenth, page 94; T(aniso; hkl)=..
# 
# Parameters:
# temperature_factor_aniso( U11, U22, U33, U23, U13, U12, h, k, l, a*, b*, c* );
# Return:
# T(aniso, hkl).
sub temperature_factor_aniso {
    my ($U_11, $U_22, $U_33, 
        $U_23, $U_13, $U_12,
        $h, $k, $l, $repro_length_a, 
	$repro_length_b, $repro_length_c) = @_;
    return exp( ( -2 * $PI**2 ) *
                ($U_11 * ($h**2) * ($repro_length_a**2) +
                 $U_22 * ($k**2) * ($repro_length_b**2) +
                 $U_33 * ($l**2) * ($repro_length_c**2) +
                 2 * $U_12 * $h * $k * $repro_length_a * $repro_length_b +
                 2 * $U_13 * $h * $l * $repro_length_a * $repro_length_c +
                 2 * $U_23 * $k * $l * $repro_length_b * $repro_length_c ) );
}


# Symmetric transformations of atom positions for receiving of 
# symmetrical atoms.

sub cell_filling_sym 
{
    my ($datablock, $filename, $atoms_data, $f2o) = @_;
    my $values =  $datablock->{values};
    
    my $sym_data;    
    if(exists $values->{"_symmetry_equiv_pos_as_xyz"})
    {
        $sym_data = $values->{"_symmetry_equiv_pos_as_xyz"};
    }

    if(exists $values->{"_symmetry_space_group_name_hall"} &&                  
       (not defined $sym_data)) {
        
        my $hall = $values->{"_symmetry_space_group_name_hall"}[0];
        $sym_data = get_symops("hall", $hall);        
        if($sym_data == 0) {
            print STDERR "ERR: " . &File::Basename::fileparse($0) . ": ";
            print STDERR "'$filename': ";
            print STDERR "There was incorrect _symmetry_space_group_name_Hall "
                . $hall . "\n";
        }
        
    }
    
    if(exists $values->{"_symmetry_space_group_name_h-m"} &&                   
       ((not defined $sym_data) or $sym_data == 0)) {
        my $h_m = $values->{"_symmetry_space_group_name_h-m"}[0];
        $sym_data = get_symops("hermann_mauguin", $h_m);
        
        if($sym_data == 0) {
            print STDERR "ERR: " . &File::Basename::fileparse($0) . ": ";
            print STDERR "'$filename': ";
            print STDERR "There was incorrect _symmetry_space_group_name_H-M "
                . $h_m . "\n";
            die; # data of space group is empty or incorrect;
        }
    }
    
    my @sym_operators = map{ SymopParse::symop_from_string($_) } @{$sym_data};
    #-----------------------------------------------------------------------
    # print for @sym_operators values only for testing purpose;
    if (0) { 
        foreach my $what (map{ @{$_} } @sym_operators) {
            print @{$what},"\n";
        };
    }
    #------------------------------------------------------------------------
    
    my $atoms_number_of_cell = 0;
    for(my $i = 0; $i < @sym_operators; $i++) {
        my $symop = $sym_operators[$i]; # 
        ## print "$symop\n";
        foreach my $atom (@{$atoms_data}) {
            my $new_xyz_fract = 
                symop_apply( [@{$atom->{coordinates_fract}}, 1], $symop);
            $new_xyz_fract = [ @{$new_xyz_fract}[0..2] ];
            ## print "@{$new_xyz_fract}\n";
            my $new_xyz_ortho = 
                mat_vect_mul( $f2o, $new_xyz_fract );
            ## print "@{$new_xyz_ortho}\n";
            $atoms_number_of_cell++;
            
            if(exists $atom->{symmetrical_xyz_fract}) { 
                push( @{$atom->{symmetrical_xyz_fract}}, $new_xyz_fract);
            } else {
                $atom->{symmetrical_xyz_fract} = [$new_xyz_fract];
            } 
            if(exists $atom->{symmetrical_xyz_ortho}) { 
                push( @{$atom->{symmetrical_xyz_ortho}}, $new_xyz_ortho );
            } else {
                $atom->{symmetrical_xyz_ortho} = [$new_xyz_ortho];
            }             
        }
    } # end of for;
    
    
    if( 0 ) { 
        print $atoms_number_of_cell, "\n";
        print "$datablock->{name}\n";
        foreach my $atom (@$atoms_data) {
            foreach my $sym_xyz (@{$atom->{symmetrical_xyz_ortho}}) {
                printf "%2s %.5f %.5f %.5f\n", $atom->{chemical_type}, 
                @{$sym_xyz};
            }
        }
    }   
    
}


#---------------------------------------------------------------
# functions get_symops() and symop_apply() code was 
# copied from 'cif_fillcell' script. rev. 1440;
#===============================================================#
# @SymopLookup::table =
# (
# {
#     number          => 1,
#     hall            => ' P 1',
#     schoenflies     => 'C1^1',
#     hermann_mauguin => 'P 1',
#     universal_h_m   => 'P 1',
#     symops => [
#         'x,y,z',
#     ],
#     ncsym => [
#         'x,y,z',
#     ]
# },
# );

sub get_symops
{
    my ($option, $param) = @_;

    $param =~ s/ //g;
    $param =~ s/_//g;

    foreach my $hash (@SymopLookup::table)
    {
        my $value = $hash->{$option};
        $value =~ s/ //g;
        $value =~ s/_//g;

        if($value eq $param)
        {
            return $hash->{symops};
        }
    }
    return 0;
}

#===============================================================#
sub symop_apply
{
        my($atom_xyz, $symop) = @_;
        my @new_atom_xyz;

        for(my $i = 0; $i < @{$symop}; $i++)
        {
                $new_atom_xyz[$i] = 0;
                for(my $j = 0; $j < @{$symop}; $j++)
                {
                        ${$atom_xyz}[$j] =~ s/\(\d+\)$//;
                        $new_atom_xyz[$i] += ${$atom_xyz}[$j] * ${$symop}[$i][$j];
                }
                $new_atom_xyz[$i] = SymopParse::modulo_1($new_atom_xyz[$i]);
        }

        return \@new_atom_xyz;
}
