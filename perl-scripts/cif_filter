#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Parse a CIF file and print out essential data values in the CIF
#  format, the COD CIF style.
#
#  This script has also many capabilities -- it can restore spacegroup
#  symbols from symmetry operators (consulting pre-defined tables),
#  parse and tidy-up _chemical_formula_sum, compute cell volume,
#  exclude unknown or "empty" tags, and add specified bibliography data.
#**

use strict;
use lib "./lib/perl5";
use lib "./CIFParser";
use lib "./CCIFParser";
use lib "./CIFTags";
use lib ".";
use File::Basename;
use CIFParser;
use CCIFParser;
use CIFDictTags;
use CIFCODTags;
use CIFAMCSDTags;
use CIFExcludedTags;
use CIFTagManage;
use CIFTagPrint;
use CIFTagCanonicalNames;
use Spacegroups::SpacegroupNames;
use Spacegroups::SymopParse;
use Spacegroups::SymopLookup;
use Formulae::AdHocParser;
use Unicode2CIF;
use SOptions;
use SUsage;

sub mk_symop_key
{
    my ( $symops ) = @_;

    my @canonical = sort 
        map {SymopParse::symop_string_canonical_form($_)} @$symops;
    my $key = join( ";", @canonical );
    return $key;
}

sub mkhash
{
    if( 1 ) {
        map { (mk_symop_key($_->{symops}), $_) }
        @SymopLookup::table, @SymopLookup::extra_settings;
    #} else {
    #        map { (mk_symop_key($_->{symops}), $_) } @CCP4SymopLookup::table;
    }
}

my %symop_lookup_table;
## my %symop_lookup_table = mkhash();

sub merge_new_tag_values($$$);

my $user_biblio = 0;
my $leave_biblio = 0;
my $leave_title = 0;
my $global_priority = 0; # if set to says that bibliography in
                         # 'data_global' has priority over
                         # bibliography in each other datablock.
my $estimate_spacegroup = 0;
my $exclude_empty_tags = 0;
my $exclude_empty_non_loop_tags = 0;
my $preserve_tag_order = 0;
my $preserve_loop_order = 0;
my $reformat_spacegroup = 0;
my $keep_unrecognised_spacegroups = 0;
my $calculate_cell_volume = 0;
my $record_original_filename = 0;
my $exclude_misspelled_tags = 0;
my $fold_long_fields = 0;
my $fold_title = 0;
my $folding_width = 76;
my $exclude_publ_details = 1;
my $use_parser = "perl";
my $parse_formula_sum = 0;
my $fix_errors = 0;
my $use_datablocks_without_coord = 0;
my $update_database_code = 1; # Specifies whether to update
                              # _cod_database_code tag value upon
                              # renumbering.

my $extra_tag_file;
my $original_filename;

my $journal;
my $volume;
my $doi;
my $issue;
my $start_page;
my $end_page;
my $year;
my $title;
my @authors;
my $biblio; # A bibliography file name, possibly marked up by XML-like
            # or LaTeX-like tags.

my $cif_comment_header; # A header with comments to printed at the
                        # beginning of the output CIF file.

my $cif_header_file; # The name of an external file that holds a CIF
                     # header.

my $data_block_nr; # If defined, specifies that data blocks should be
                   # numbered in a COD-like fasion.

my %spacegroups = map {
    my $key1 = $_->[1];
    my $key2 = $_->[2];
    $key1 =~ s/\s//g;
    $key2 =~ s/\s//g;
    ($key1, $_->[2], $key2, $_->[2] )
} @SpacegroupNames::names;

#* USAGE:
#*     $0 [options] input.cif [input2.cif ...]
#* 
#* OPTIONS:
#*    -j, --journal 'Acta Cryst. A'
#*    -v, --volume    36
#*    -i, --issue      1
#*    -p, --page     123
#*    --start-page   123
#*    -e, --end-page 132
#*    -y, --year     1999
#*        Specify bibliographic data to be included into the output.
#*
#*    -B, --bibliography bibliography.cif
#*    --bibliography bibliography.mrk
#*        Provide a bibliography file, 'bibliography.mrk' in this example,
#*        with the bibliographic information to be included into the output.
#*        The bibliography information can be provided in CIF format or in
#*        a XML-like .mrk file with data items between <authors>, <journal>,
#*        <volume>, <issue>, <year>, <pages>123-132</pages> tags.
#*    
#*    -h, --add-cif-header header_file.cif
#*
#*    -s, --estimate-spacegroup
#*    -s-, --dont-estimate-spacegroup, --no-estimate-spacegroup
#*         Estimate spacegroup symbols from the symmetry operators in the
#*         input.
#*
#*    -x,--extra-tag-list tag-list.lst
#*
#*    --exclude-empty-tags
#*    --dont-exclude-empty-tags, --no-exclude-empty-tags
#*
#*    --exclude-misspelled-tags
#*    --dont-exclude-misspelled-tags, --no-exclude-misspelled-tags
#*
#*    --keep-unrecognised-spacegroups
#*    --dont-keep-unrecognised-spacegroups, --no-keep-unrecognised-spacegroups
#*
#*    --parse-formula-sum
#*    --dont-parse-formula-sum, --no-parse-formula-sum
#*
#*    --fix-syntax-errors
#*    --dont-fix-syntax-errors, --no-fix-syntax-errors
#*
#*    --preserve-loop-order
#*    --use-internal-loop-order
#*
#*    --retain-tag-order
#*    --dont-retain-tag-order
#*
#*    --reformat-space-group
#*    --dont-reformat-space-group, --leave-space-group
#*
#*    --reformat-spacegroup
#*    --dont-reformat-spacegroup, --leave-spacegroup
#*
#*    --calculate-cell-volume
#*    --dont-calculate-cell-volume
#*
#*    --original-filename data_source.cif
#*
#*    --clear-original-filename
#*
#*    --record-original-filename
#*    --dont-record-original-filename
#*
#*    --update-database-code
#*    --dont-update-database-code
#*
#*    -S, --start-data-block-number 1234567
#*
#*    -R, --renumber-data-blocks
#*    -R-, --dont-renumber-data-blocks
#*
#*    --use-datablocks-without-coordinates
#*    
#*    --do-not-use-datablocks-without-coordinates, --use-all-datablocks
#*    --dont-use-datablocks-without-coordinates
#*    --no-use-datablocks-without-coordinates
#*    --skip-datablocks-without-coordinates
#*
#*    --folding-width 78
#*
#*    --fold-title
#*    --dont-fold-title
#*
#*    --fold-long-fields
#*    --dont-fold-long-fields
#*
#*    --use-perl-parser
#*    --use-c-parser
#*
#*    --leave-bibliography
#*    --discard-bibliograph
#*
#*    --exclude-publication-details
#*    --dont-exclude-publication-details, --no-exclude-publication-details
#*
#*    --leave-title
#*    --help,--usage         Print a short usage message (this message) and exit.
#**

@ARGV = getOptions( 
    "-a,--authors"      => sub{ $user_biblio = 1;
                                @authors = split( /(?:;|:)\s*/,
                                                  get_value()) },
    "-j,--journal"      => sub{ $user_biblio = 1; $journal = get_value() },
    "-v,--volume"       => sub{ $user_biblio = 1; $volume = get_value() },
    "-i,--issue"        => sub{ $user_biblio = 1; $issue = get_value() },
    "-p,--page"         => sub{ $user_biblio = 1; $start_page = get_value() },
    "--start-page"      => sub{ $user_biblio = 1; $start_page = get_value() },
    "-e,--end-page"     => sub{ $user_biblio = 1; $end_page = get_value() },
    "-y,--year"         => sub{ $user_biblio = 1; $year = get_value() },
    "-B,--bibliography" => \$biblio,

    "-g,--global-priority"     => sub { $global_priority = 1 },
    "-g-,--no-global-priority" => sub { $global_priority = 0 },

    "-h,--add-cif-header" => \$cif_header_file,

    "-s,--estimate-spacegroup" => sub { $estimate_spacegroup = 1; },
    "-s-,--dont-estimate-spacegroup" => sub { $estimate_spacegroup = 0; },
    "--no-estimate-spacegroup" => sub { $estimate_spacegroup = 0; },

    "-x,--extra-tag-list" => \$extra_tag_file,

    "--exclude-empty-tags"      => sub { $exclude_empty_tags = 1; },
    "--dont-exclude-empty-tags" => sub { $exclude_empty_tags = 0; },
    "--no-exclude-empty-tags"   => sub { $exclude_empty_tags = 0; },

    "--exclude-empty-non-loop-tags"      => sub { $exclude_empty_non_loop_tags = 1; },
    "--dont-exclude-non-loop-empty-tags" => sub { $exclude_empty_non_loop_tags = 0; },
    "--no-exclude-non-loop-empty-tags"   => sub { $exclude_empty_non_loop_tags = 0; },

    "--exclude-misspelled-tags"      => sub { $exclude_misspelled_tags = 1; },
    "--dont-exclude-misspelled-tags" => sub { $exclude_misspelled_tags = 0; },
    "--no-exclude-misspelled-tags"   => sub { $exclude_misspelled_tags = 0; },

    "--keep-unrecognised-spacegroups"
        => sub { $keep_unrecognised_spacegroups = 1; },
    "--dont-keep-unrecognised-spacegroups"
        => sub { $keep_unrecognised_spacegroups = 0; },
    "--no-keep-unrecognised-spacegroups"
        => sub { $keep_unrecognised_spacegroups = 0; },

    "--parse-formula-sum"       => sub { $parse_formula_sum = 1; },
    "--dont-parse-formula-sum"  => sub { $parse_formula_sum = 0; },
    "--no-parse-formula-sum"    => sub { $parse_formula_sum = 0; },

    "--fix-syntax-errors"       => sub { $fix_errors = 1; },
    "--dont-fix-syntax-errors"  => sub { $fix_errors = 0; },
    "--no-fix-syntax-errors"    => sub { $fix_errors = 0; },

    "--preserve-loop-order"     => sub { $preserve_loop_order = 1; },
    "--use-internal-loop-order" => sub { $preserve_loop_order = 0; },

    "--retain-tag-order"        => sub { $preserve_tag_order = 1; },
    "--dont-retain-tag-order"   => sub { $preserve_tag_order = 0; },

    "--reformat-space-group"      => sub { $reformat_spacegroup = 1; },
    "--dont-reformat-space-group" => sub { $reformat_spacegroup = 0; },
    "--leave-space-group"         => sub { $reformat_spacegroup = 0; },

    "--reformat-spacegroup"       => sub { $reformat_spacegroup = 1; },
    "--dont-reformat-spacegroup"  => sub { $reformat_spacegroup = 0; },
    "--leave-spacegroup"          => sub { $reformat_spacegroup = 0; },

    "--calculate-cell-volume"      => sub { $calculate_cell_volume = 1; },
    "--dont-calculate-cell-volume" => sub { $calculate_cell_volume = 0; },

    "--original-filename" => sub { $original_filename = &get_value;
                                   $record_original_filename = 1 },
    "--clear-original-filename" => sub { undef $original_filename },

    "--record-original-filename"      => sub { $record_original_filename = 1; },
    "--dont-record-original-filename" => sub { $record_original_filename = 0; },

    "--update-database-code"          => sub { $update_database_code = 1; },
    "--dont-update-database-code"     => sub { $update_database_code = 0; },

    "-S,--start-data-block-number"    => \$data_block_nr,
    "-R,--renumber-data-blocks"       => sub { $data_block_nr = 7000001 },
    "-R-,--dont-renumber-data-blocks" => sub { undef $data_block_nr },

    "--use-datablocks-without-coordinates"
        => sub{ $use_datablocks_without_coord = 1 },
    "--use-all-datablocks"
        => sub{ $use_datablocks_without_coord = 1 },

    "--do-not-use-datablocks-without-coordinates"
        => sub{ $use_datablocks_without_coord = 0 },
    "--dont-use-datablocks-without-coordinates"
        => sub{ $use_datablocks_without_coord = 0 },
    "--no-use-datablocks-without-coordinates"
        => sub{ $use_datablocks_without_coord = 0 },
    "--skip-datablocks-without-coordinates"
        => sub{ $use_datablocks_without_coord = 0 },

    "--folding-width"         => \$folding_width,
    "--fold-title"            => sub{ $fold_title = 1 },
    "--dont-fold-title"       => sub{ $fold_title = 0 },
    "--fold-long-fields"      => sub{ $fold_long_fields = 1 },
    "--dont-fold-long-fields" => sub{ $fold_long_fields = 0 },

    "--use-perl-parser"       => sub{ $use_parser = "perl" },
    "--use-c-parser"          => sub{ $use_parser = "c" },

    "--leave-bibliography"   => sub{ $leave_biblio = 1 },
    "--discard-bibliography" => sub{ $leave_biblio = 0 },

    "--exclude-publication-details"      => sub{ $exclude_publ_details = 1 },
    "--dont-exclude-publication-details" => sub{ $exclude_publ_details = 0 },
    "--no-exclude-publication-details"   => sub{ $exclude_publ_details = 0 },

    "--leave-title"          => sub{ $leave_title  = 1 },
    "--help,--usage" => sub { SUsage::usage; exit },
);

my @extra_tags = ();

if( $extra_tag_file ) {
    open( EXTRA, "$extra_tag_file" ) or
        die( "could not open tag list '$extra_tag_file' for reading: $!" );
    @extra_tags = map {s/\s//g;lc($_)} map {split} grep /^\s*_/, <EXTRA>;
    close( EXTRA ) or
        die( "error while closing file '$extra_tag_file' after reading" );

    ## local $, = "\n"; local $\ = "\n";
    ## print @extra_tags;
}

my %excluded_tags  = map { ($_,$_) } @CIFExcludedTags::tag_list;

my @dictionary_tags = ( @CIFDictTags::tag_list, @CIFCODTags::tag_list,
                        @CIFAMCSDTags::tag_list, @extra_tags );

my %dictionary_tags = map { $_, $_ } @dictionary_tags;

if( defined $cif_header_file ) {
    open( HEADER, "$cif_header_file" ) or
        die( "could not open CIF header file '$cif_header_file' for reading: $!" );
    # local $/; # enable "slurp" mode: read the whole header file.
    $cif_comment_header = "";
    while( <HEADER> ) {
        last unless /^\#|^\s*$/;
        $cif_comment_header .= $_;
    }
    close( HEADER ) or
        die( "error while closing file '$cif_header_file' after reading" );
}

@ARGV = ( "-" ) unless @ARGV;

for my $filename (@ARGV) {

    my( $data, $error_count );
    my %options;

    if( $fix_errors ) {
        $options{fix_errors} = 1;
    }

    if( $use_parser eq "perl" ) {
        my $parser = new CIFParser;

        $data = $parser->Run($filename, \%options);

        if( defined $parser->YYData->{ERRCOUNT} ) {
            $error_count = $parser->YYData->{ERRCOUNT};
        }
    } else {
        ( $data, $error_count ) = CCIFParser::parse( $filename, \%options );
    }

    if( defined $error_count && $error_count > 0 ) {
        print STDERR "$0: ", $error_count,
        " error(s) encountered while parsing file '${filename}'\n";
        die;
    }

    if( !@$data || !defined $data->[0] || !defined $data->[0]{name} ) {
        warn( "file '$filename' seems to be empty" );
        next;
    }

#------------------------------------------------------------------------------

    my %global_bibliography = ();
    my @global_biblio_keys = (
        "_journal_name_full",
        "_journal_volume",
        "_journal_issue",
        "_journal_page_first",
        "_journal_page_last",
        "_journal_year",
        "_publ_section_title",
        "_publ_author_name",
        "_journal_coeditor_code",
        "_journal_paper_doi"
        );

    my %global_biblio_keys = map {($_,$_)} @global_biblio_keys;

#
# First, look for a data_global section and extract bibliography
# information. Stupidly enough, this section can be in the very end of
# the CIF file, so we need to scan all sections to find it.
#

    my $global_section_nr = 0;

    for my $dataset (@$data) {
        next unless $dataset->{name} eq "global";
        my $datablock = $dataset->{values};

        $global_section_nr ++;

        %global_bibliography = ();

        merge_new_tag_values( \@global_biblio_keys, \%global_bibliography,
                              $dataset );

        ## use ShowStruct; showRef( \%global_bibliography );
    }

    if( $global_section_nr > 1 ) {
        warn "file '${filename}' had $global_section_nr global sections, "
            . "taking one into account, other were removed"
    }

    # Assume that there are no datablocks with coordinates until a datablock
    # with coordinates is found 

    my $no_coordinates = 1;

    binmode( STDOUT, ":utf8" );

    for my $dataset (@$data) {

        ## next unless defined $dataset->{kind} && $dataset->{kind} == "DATA";

        my $datablok = $dataset->{values};

        # Add bibliography from a global section, if any:

        if( %global_bibliography ) {
            merge_new_tag_values( [keys %{$global_bibliography{values}}],
                                  $dataset, \%global_bibliography );
        }

        # convert all tags to a "cannonical" form:

        canonicalize_names( $dataset );

        next if !defined $datablok;
        next if !$use_datablocks_without_coord && !defined $datablok->{_atom_site_label};

        $no_coordinates = 0;

        ## print "\n" if $n > 0;

        # Remove empty tags, if requested:

        if( $exclude_empty_tags ) {
            CIFTagManage::exclude_empty_tags( $dataset );
        }

        if( $exclude_empty_non_loop_tags ) {
            CIFTagManage::exclude_empty_non_loop_tags( $dataset );
        }

        # Process the bibliography file that was supplied on the command
        # line:

        if( defined $biblio ) {
            my $reference;

            if( $biblio =~ /\.cif/i ) {

                my( $biblio_blocks, $error_count );
                my %biblio_options = ( fix_errors => 1 );
                if( $use_parser eq "perl" ) {
                    my $parser = new CIFParser;

                        $biblio_blocks = $parser->Run($biblio, \%biblio_options);

                        if( defined $parser->YYData->{ERRCOUNT} &&
                            $parser->YYData->{ERRCOUNT} > 0 ) {
                            $error_count = $parser->YYData->{ERRCOUNT};
                        }
                } else {
                    ( $biblio_blocks, $error_count ) = 
                        CCIFParser::parse( $biblio, \%biblio_options );
                }

                if( defined $error_count && $error_count > 0 ) {
                    print STDERR "$0: ", $error_count,
                        " error(s) encountered while parsing",
                        " file '${biblio}'\n";
                    die;
                }

                my $bibdata;

                if( @{$biblio_blocks} > 1 ) {
                    warn "file '${biblio}' has @{$biblio_blocks} --" .
                        "will take bibliography from a datablock "  .
                        "that has the same name as the coordinate datablock";
                    for my $block (@{$biblio_blocks}) {
                        if( $block->{name} eq $dataset->{name} ) {
                            $bibdata = $block->{values};
                            last
                        }
                    }
                } else {
                    $bibdata = $biblio_blocks->[0]{values};
                }
                if( !defined $bibdata ) {
                    warn "file '${biblio}' matching bibliography datablock " .
                        "for '$dataset->{name}' --"  .
                        "no bibliography wil be taken for this datablock";
                } else {
                    if( !$leave_biblio ) {
                        for my $key ( grep /_journal_|_publ_section_title|_author_/,
                                      keys %{$datablok} ) {
                            if( $key ne "_journal_coeditor_code" ) {
                                if( $key ne "_publ_section_title" || !$leave_title ) {
                                    CIFTagManage::exclude_tag( $dataset, $key );
                                }
                            }
                        }
                    }
                    for my $bibtag (@global_biblio_keys) {
                        if( !exists $datablok->{$bibtag} &&
                            exists $bibdata->{$bibtag}) {
                            $datablok->{$bibtag} = $bibdata->{$bibtag};
                            if( $bibtag eq "_publ_author_name" ) {
                                if( exists $dataset->{inloop}{$bibtag} ) {
                                    my $loop_nr = $dataset->{inloop}{$bibtag};
                                    $dataset->{loops}[$loop_nr] = [ $bibtag ];
                                } else {
                                    if( exists $dataset->{loops} ) {
                                        push( @{$dataset->{loops}}, [ $bibtag ] );
                                        $dataset->{inloop}{$bibtag} = $#{$dataset->{loops}};
                                    } else {
                                        $dataset->{inloop}{$bibtag} = 0;
                                        $dataset->{loops} = [ [ $bibtag ] ];
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                open( BIBLIO, "<:utf8", $biblio ) or
                    die( "Could not open file '$biblio' for reading: $!" );
                if( $biblio =~ /\.ref/ ) {
                    $reference = <BIBLIO>; # read the first line
                } elsif( $biblio =~ /\.xrf/ ) {
                    my @reference = grep !/^\#/, <BIBLIO>;
                    $reference = $reference[0]; # read the first non-comment line
                } else {
                    local $/ = undef; # read the whole file
                    $reference = <BIBLIO>;
                }
                close BIBLIO;
                chomp $reference;

                if( !$leave_biblio ) {
                    for my $key ( grep /_journal_|_publ_section_title|_author_/,
                                  keys %{$datablok} ) {
                        if( $key ne "_journal_coeditor_code" ) {
                            if( $key ne "_publ_section_title" || !$leave_title ) {
                                CIFTagManage::exclude_tag( $dataset, $key );
                            }
                        }
                    }
                }

                if( $reference =~ /<.*?>.*?<.*?>/s ||
                    $reference =~ /\\.*?(?:\[.*?\])?\{.*?\}/s ) {
                    if( !$title && ( $reference =~ /<title>(.*?)<\/title>/s ||
                                     $reference =~ /\\title\{(.*?)\}/s )) {
                        my $cif_title = unicode2cif( $1 );
                        $cif_title =~ s/\n/ /g;
                        $datablok->{_publ_section_title} = [
                            "\n" . join( "\n", map { " " . $_ }
                                         CIFTagPrint::fold( 71, " +", " ", $cif_title ))
                            ];
                    }
                    if( !$journal && ( $reference =~ /<journal>(.*?)<\/journal>/s ||
                                       $reference =~ /\\journal\{(.*?)\}/s )) {
                        $datablok->{_journal_name_full} = [ unicode2cif( $1 ) ];
                    }
                    if( !$issue && ( $reference =~ /<issue>(.*?)<\/issue>/s ||
                                     $reference =~ /\\issue\{(.*?)\}/s )) {
                        $datablok->{_journal_issue} = [ unicode2cif( $1 ) ];
                    }
                    if( !$volume && ( $reference =~ /<volume>(.*?)<\/volume>/s ||
                                      $reference =~ /\\volume\{(.*?)\}/s )) {
                        $datablok->{_journal_volume} = [ unicode2cif( $1 ) ];
                    }
                    if( !$year && ( $reference =~ /<year>(.*?)<\/year>/s ||
                                    $reference =~ /\\year\{(.*?)\}/s )) {
                        my $y = $1;
                        $y =~ s/[^0-9]//g;
                        $datablok->{_journal_year} = [ unicode2cif( $y ) ];
                    }
                    if( !$doi && ( $reference =~ /<doi>(.*?)<\/doi>/s ||
                                      $reference =~ /\\doi\{(.*?)\}/s )) {
                        $datablok->{_journal_paper_doi} = [ unicode2cif( $1 ) ];
                    }
                    if( !$start_page && ( $reference =~ /<pages?>(.*?)<\/pages?>/s ||
                                          $reference =~ /\\pages?\{(.*?)\}/s )) {
                        my @pages = map { s/\s//g; $_ } split ( "-", $1 );
                        $datablok->{_journal_page_first} = [ unicode2cif( $pages[0] ) ];
                        if( int(@pages) > 1 ) {
                            $datablok->{_journal_page_last} =
                                [ unicode2cif( $pages[1] ) ];
                        }
                    }
                    if( !@authors && ( $reference =~
                                       /<authors?\s?(.*?)>(.*?)<\/authors?>/s ||
                                       $reference =~
                                       /\\authors?(?:\[(.*?)\])?\{(.*?)\}/s )) {
                        my $attributes = $1;
                        my $author_list = $2;
                        my $separator = qr/,\s*and|\sand\s|,/;
                        if( $attributes && $attributes =~ /separator\s*=\s*"(.*?)"/ ) {
                            $separator = qr/$1/;
                        }
                        $datablok->{_publ_author_name} =
                            [
                             map { unicode2cif( $_ ) }
                             map { s/\n/ /g; s/\s+/ /g; $_ }
                             map { s/^\s*|\s*$//g; $_ }
                             split( $separator, $author_list )
                            ];
                        my $tag = "_publ_author_name";
                        if( exists $dataset->{inloop}{$tag} ) {
                            my $loop_nr = $dataset->{inloop}{$tag};
                            $dataset->{loops}[$loop_nr] = [ $tag ];
                        } else {
                            if( exists $dataset->{loops} ) {
                                push( @{$dataset->{loops}}, [ $tag ] );
                                $dataset->{inloop}{$tag} = $#{$dataset->{loops}};
                            } else {
                                $dataset->{inloop}{$tag} = 0;
                                $dataset->{loops} = [ [ $tag ] ];
                            }
                        }
                    }
                }
            }
        }

        # User specified bibliography is processed last since it must take
        # precedence over the original CIF bibliography and over the
        # bibliography file data:

        if( $user_biblio ) {
            if( !$leave_biblio ) {
                for my $key ( grep /_journal_|_publ_section_title|_author_/,
                              keys %{$datablok} ) {
                    if( $key ne "_publ_section_title" || !$leave_title ) {
                        CIFTagManage::exclude_tag( $dataset, $key );
                    }
                }
            }

            do {
                use Encode 'decode_utf8';
                ## use encoding 'utf8';
                @authors = map { s/\n/ /g; s/\s+/ /g; $_ }
                           map { s/^\s*|\s*$//g; $_ }
                           map { unicode2cif( $_ ) }
                           # Insist that the names are well-formed utf8:
                           map { decode_utf8($_) }
                           # This does not work, alas:
                           ## map { pack("U*", unpack("C*", $_ )) }
                           @authors;
                $datablok->{_publ_author_name} = [ @authors ];
                my $tag = "_publ_author_name";
                if( exists $dataset->{inloop}{$tag} ) {
                    my $loop_nr = $dataset->{inloop}{$tag};
                    $dataset->{loops}[$loop_nr] = [ $tag ];
                } else {
                    if( exists $dataset->{loops} ) {
                        push( @{$dataset->{loops}}, [ $tag ] );
                        $dataset->{inloop}{$tag} = $#{$dataset->{loops}};
                    } else {
                        $dataset->{inloop}{$tag} = 0;
                        $dataset->{loops} = [ [ $tag ] ];
                    }
                }
            } if @authors;

            $datablok->{_publ_section_title} = [ $title ]
                if defined $title;

            $datablok->{_journal_name_full} = [ $journal ]
                if defined $journal;

            $datablok->{_journal_year} = [ $year ]
                if defined $year;

            $datablok->{_journal_volume} = [ $volume ]
                if defined $volume;

            $datablok->{_journal_issue} = [ $issue ]
                if defined $issue;

            $datablok->{_journal_page_first} = [ $start_page ]
                if defined $start_page;

            $datablok->{_journal_page_last} = [ $end_page ]
                if defined $end_page;
        }

        # Restore the full final page number if only trailing digits of
        # the _journal_page_last are given:

        if( defined $datablok->{_journal_page_first} &&
            defined $datablok->{_journal_page_last} &&
            $datablok->{_journal_page_first}[0] =~ /^[0-9]+$/ &&
            $datablok->{_journal_page_last}[0] =~ /^[0-9]+$/ &&
            $datablok->{_journal_page_first}[0] >
            $datablok->{_journal_page_last}[0] ) {
            $datablok->{_journal_page_last}[0] =
                restore_last_page( $datablok->{_journal_page_first}[0],
                                   $datablok->{_journal_page_last}[0] );
        }

        # Fold title if requested:

        if( $fold_title && exists $datablok->{_publ_section_title} ) {
            my $cif_title = join( " ", @{$datablok->{_publ_section_title}} );
            $cif_title =~ s/\n/ /g;
            $datablok->{_publ_section_title} = [
                "\n" . join( "\n", map { " " . $_ }
                             CIFTagPrint::fold( $folding_width - 2, " +", " ", $cif_title ))
                ];
        }

        # Exclude potentially copyrighted and irrelevant tags if requested:

        if( $exclude_publ_details ) {
            my @tag_list = @{$dataset->{tags}};
            for my $tag (@tag_list) {
                if( exists $excluded_tags{$tag} || $tag =~ /^_vrf_/ ) {
                    CIFTagManage::exclude_tag( $dataset, $tag );
                    #use ShowStruct;
                    #showRef( $dataset );
                }
            }
        }

        # Check for misspelled tags:

        for my $tag (@{$dataset->{tags}}) {
            unless( exists $dictionary_tags{$tag} ) {
                print STDERR basename( $0 ) . ": ";
                print STDERR "tag '$tag' is not recognised\n";
            }
        }

        # Exclude the misspelled tags if requested:

        if( $exclude_misspelled_tags ) {
            my @tag_list = @{$dataset->{tags}};
            for my $tag (@tag_list) {
                unless( exists $dictionary_tags{$tag} ) {
                    CIFTagManage::exclude_tag( $dataset, $tag );
                }
            }
        }

        # Add the data source file name, if requested:

        if( $record_original_filename ) {
            my $basename;
            if( defined $original_filename ) {
                $basename = File::Basename::basename( $original_filename );
            } elsif( defined $filename && $filename ne "-" ) {
                $basename = File::Basename::basename( $filename );
            } else {
                $basename = "?";
            }
            set_tag( $dataset, "_[local]_cod_data_source_file", $basename );
            set_tag( $dataset, "_[local]_cod_data_source_block", $dataset->{name} );
        }

        # Clean up the resulting CIF data structure:

        for my $excluded_tag (qw( _publ_author_address
                              _publ_author.address
                              _publ_author_email
                              _publ_author.email
                              _publ_author_footnote
                              _publ_author.footnote
                              _publ_author_id_iucr
                              _publ_author.id_iucr )) {
            if( exists $datablok->{$excluded_tag} ) {
                CIFTagManage::exclude_tag( $dataset, $excluded_tag );
                #use ShowStruct;
                #showRef( $dataset );
            }
        }

        # Correct the formatting of the H-M spacegroup symbol:

        if( $reformat_spacegroup ) {
            for my $sg_tag (qw (
            _symmetry_space_group_name_H-M
            _space_group_name_H-M_alt
            _space_group.name_H-M_full
        )) {
                ##use ShowStruct;
                ##showRef( \%spacegroups  );
                if( exists $datablok->{$sg_tag} ) {
                    my $clean_sg = $datablok->{$sg_tag}[0];
                    $clean_sg =~ s/[()~_\s]//g;
                    ##print ">>> $clean_sg\n";
                    if( exists $spacegroups{$clean_sg} ) {
                        my $original_sg_H_M = $datablok->{$sg_tag}[0];
                        if( $sg_tag eq "_symmetry_space_group_name_H-M" &&
                            $original_sg_H_M ne '?' &&
                            $original_sg_H_M ne $spacegroups{$clean_sg} &&
                            !exists $datablok->{"_[local]_cod_cif_authors_sg_H-M"} ) {
                            set_tag( $dataset, "_[local]_cod_cif_authors_sg_H-M",
                                     $original_sg_H_M );
                        }
                        $datablok->{$sg_tag}[0] = $spacegroups{$clean_sg};
                    }
                }
            }
        }

        # Determine space group symbols from symmetry elements if requested:

        if( $estimate_spacegroup ) {
            if( !%symop_lookup_table ) {
                %symop_lookup_table = mkhash();
            }

            my @symops;
            if( exists $datablok->{"_space_group_symop_operation_xyz"} ) {
                @symops = @{$datablok->{"_space_group_symop_operation_xyz"}};
            } elsif( exists $datablok->{"_symmetry_equiv_pos_as_xyz"} ) {
                @symops = @{$datablok->{"_symmetry_equiv_pos_as_xyz"}};
            }
            
            if( @symops ) {
                my $has_errors = 0;
                for my $symop (@symops) {
                    my $error = SymopParse::check_symmetry_operator( $symop );
                    if( $error ) {
                        $has_errors = 1;
                        print STDERR "$0: $filename: $error\n";
                    }
                }
                if( !$has_errors ) {
                    my $key = mk_symop_key( \@symops );
                    my $original_sg_H_M =
                        defined $datablok->{"_symmetry_space_group_name_H-M"} ?
                        $datablok->{"_symmetry_space_group_name_H-M"}[0] :
                        undef;
                    my $original_sg_Hall =
                        defined $datablok->{"_symmetry_space_group_name_Hall"} ?
                        $datablok->{"_symmetry_space_group_name_Hall"}[0] :
                        undef;
                    my $original_sg_number =
                        defined $datablok->{"_space_group_IT_number"} ?
                        $datablok->{"_space_group_IT_number"}[0] :
                        undef;

                    if( exists $symop_lookup_table{$key} ) {
                        my $estimated_sg = $symop_lookup_table{$key};

                        my $estimated_sg_H_M = $estimated_sg->{universal_h_m};
                        if( defined $original_sg_H_M &&
                            $original_sg_H_M ne '?' &&
                            $original_sg_H_M ne $estimated_sg_H_M &&
                            !exists $datablok->{"_[local]_cod_cif_authors_sg_H-M"} ) {
                            set_tag( $dataset, "_[local]_cod_cif_authors_sg_H-M",
                                     $original_sg_H_M );
                        }
                        set_tag( $dataset, "_symmetry_space_group_name_H-M",
                                 $estimated_sg_H_M );

                        my $estimated_sg_Hall = $estimated_sg->{hall};
                        $estimated_sg_Hall =~ s/^\s*//;
                        if( defined $original_sg_Hall &&
                            $original_sg_Hall ne '?' &&
                            $original_sg_Hall ne $estimated_sg_Hall ) {
                            set_tag( $dataset, "_[local]_cod_cif_authors_sg_Hall",
                                     $original_sg_Hall );
                        }
                        set_tag( $dataset, "_symmetry_space_group_name_Hall",
                                 $estimated_sg_Hall );

                        my $estimated_sg_number = $estimated_sg->{number};
                        if( defined $original_sg_number &&
                            $original_sg_number ne '?' &&
                            $original_sg_number != $estimated_sg_number ) {
                            set_tag( $dataset, "_[local]_cod_cif_authors_sg_number",
                                     $original_sg_number );
                        }
                        set_tag( $dataset, "_space_group_IT_number",
                                 $estimated_sg_number );
                    } else {
                        if( !$keep_unrecognised_spacegroups ) {
                            if( defined $original_sg_H_M && $original_sg_H_M ne '?' &&
                                !exists $datablok->{"_[local]_cod_cif_authors_sg_H-M"} ) {
                                set_tag( $dataset, "_[local]_cod_cif_authors_sg_H-M",
                                         $original_sg_H_M );
                            }
                            set_tag( $dataset, "_symmetry_space_group_name_H-M", '?' );

                            if( defined $original_sg_Hall && $original_sg_Hall ne '?' ) {
                                set_tag( $dataset, "_[local]_cod_cif_authors_sg_Hall",
                                         $original_sg_Hall );
                            }
                            set_tag( $dataset, "_symmetry_space_group_name_Hall",'?' );

                            if( defined $original_sg_number ) {
                                set_tag( $dataset, "_[local]_cod_cif_authors_sg_number",
                                         $original_sg_number );
                            }
                            set_tag( $dataset, "_space_group_IT_number", '?' );
                        }
                    }
                }
            } else {
                print STDERR "$0: the ", defined $filename ? "'$filename' " : "",
                "data_$dataset->{name} does not contain symmetry operators\n";
            }
        }

        # Try to parse and correct chemical formula if requested:

        if( $parse_formula_sum && defined $datablok->{_chemical_formula_sum} ) {
            my $formula = $datablok->{_chemical_formula_sum}[0];
            $formula =~ s/\n/ /g;
            $formula =~ s/^\s*|\s*$//g;
            my $parser = new AdHocParser;
            $parser->ParseString( $formula );
            my $new_formula = $parser->SprintFormula;

            if( defined $new_formula && 
                $datablok->{_chemical_formula_sum}[0] ne $new_formula ) {
                set_tag( $dataset, "_[local]_cod_chemical_formula_sum_orig",
                         $datablok->{_chemical_formula_sum}[0] );
                set_tag( $dataset, "_chemical_formula_sum", $new_formula );
            }
        }

        # Calculate essential information if it is missing but requested:

        if( $calculate_cell_volume ) {
            my @cell = get_cell( $datablok );
            my @sigcell = get_cell( $dataset->{precisions} );
            $cell[3] = 90 unless defined $cell[3];
            $cell[4] = 90 unless defined $cell[4];
            $cell[5] = 90 unless defined $cell[5];

            my $has_cell = 1;
            my $has_precisions = 0;

            for (@cell) {
                if( !defined $_ ) {
                    $has_cell = 0;
                    last;
                }
            }
            for (@sigcell) {
                if( defined $_ && $_ != 0 ) {
                    $has_precisions = 1;
                    last;
                }
            }

            if( $has_cell ) {
                my ( $V, $sigV );
                if( $has_precisions ) {
                    @sigcell = map { defined $_ ? $_ : 0 } @sigcell;
                    ($V, $sigV) = cell_volume( @cell, @sigcell );
                    $V = CIFTagPrint::pack_precision( $V, $sigV );
                } else {
                    $V = sprintf( "%.3f", scalar( cell_volume( @cell )));
                }
                if( exists $datablok->{"_cell_volume"} &&
                    !exists $datablok->{"_cod_original_cell_volume"} &&
                    $datablok->{"_cell_volume"}[0] ne $V ) {
                    $datablok->{"_cod_original_cell_volume"}[0] =
                        $datablok->{"_cell_volume"}[0];
                }
                $datablok->{"_cell_volume"}[0] = $V;
            } else {
                warn "file '${filename}', datablock $dataset->{name} " .
                    "has no unit cell info -- "  .
                    "can't compute cell volume";
            }
        }

        # Add default cell angles of 90 degrees if these are missing:
        if( exists $datablok->{"_cell_length_a"} ||
            exists $datablok->{"_cell_length_b"} ||
            exists $datablok->{"_cell_length_c"} ) {
            if( ! exists $datablok->{"_cell_angle_alpha"} ) {
                $datablok->{"_cell_angle_alpha"}[0] = 90;
            }
            if( ! exists $datablok->{"_cell_angle_beta"} ) {
                $datablok->{"_cell_angle_beta"}[0] = 90;
            }
            if( ! exists $datablok->{"_cell_angle_gamma"} ) {
                $datablok->{"_cell_angle_gamma"}[0] = 90;
            }
        }

        # Print out the CIF header if requested:

        if( defined $cif_comment_header ) {
            print $cif_comment_header;
        }

        # Calculate the data block name:

        if( defined $data_block_nr ) {
            $dataset->{name} = sprintf "%07d", $data_block_nr;
            if( $update_database_code ) {
                $dataset->{values}{_cod_database_code}[0] = $dataset->{name};
            }
            $data_block_nr ++;
        }

        # Print out requested tags:

        print_cif( $dataset, { 
            exclude_misspelled_tags => $exclude_misspelled_tags,
            preserve_loop_order => $preserve_loop_order,
            fold_long_fields => $fold_long_fields,
            folding_width => $folding_width,
            dictionary_tags => \%dictionary_tags,
            dictionary_tag_list => \@dictionary_tags,
            keep_tag_order => $preserve_tag_order,
                   } );

    }

    if( $no_coordinates ) {
        warn "file '${filename}' does not contain any datablocks with"
            . " coordinates";
    }

}

#
# Subroutines:
#

sub cell_volume
{
    my @cell = map { s/\(.*\)//g; $_ } @_;

    my $Pi = 4 * atan2(1,1);

    # Compute unit cell volume:

    my ($a, $b, $c) = @cell[0..2];
    my ($alpha, $beta, $gamma) = map {$Pi * $_ / 180} @cell[3..5];
    my ($ca, $cb, $cg) = map {cos} ($alpha, $beta, $gamma);
    my $sg = sin($gamma);
    my $D = $sg**2 - $ca**2 - $cb**2 + 2*$ca*$cb*$cg;
    
    my $V = $a * $b * $c * sqrt( $D );

    if( wantarray ) {
        # Compute unit cell volume standard deviation, using "error
        # propagation" method:
        my $sa = sin($alpha);
        my $sb = sin($beta);
        my ( $siga, $sigb, $sigc ) = @cell[6..8];
        my ( $sigalpha, $sigbeta, $siggamma ) =
            map {$Pi * $_ / 180} @cell[9..11];
        my $dVda = $sigalpha * $sa * ($ca - $cb * $cg ) / $D;
        my $dVdb = $sigbeta * $sb * ($cb - $ca * $cg ) / $D;
        my $dVdg = $siggamma * $sg * ($cg - $ca * $cb ) / $D;
        my $sigV = $V * sqrt(
            ($siga/$a) ** 2 + ($sigb/$b) ** 2 + ($sigc/$c) ** 2 +
            $dVda ** 2 + $dVdb ** 2 + $dVdg ** 2
            );
        return ( $V, $sigV );
    } else {
        return $V;
    }
}

sub merge_new_tag_values($$$)
{
    my ($tag_list, $dst, $src ) = @_;

    my %tag_list = map {($_,1)} @$tag_list;

    for my $key (@{$tag_list}) {
        if( defined $src->{values}{$key}
            && (!exists $dst->{values}{$key} || $global_priority )) {

            if( exists $dst->{values}{$key} ) {
                exclude_tag( $dst, $key );
            }

            $dst->{values}{$key} = $src->{values}{$key};
            push( @{$dst->{tags}}, $key );

            if( exists $src->{inloop}{$key} &&
                !exists $dst->{inloop}{$key} ) {
                my $loop_nr = $src->{inloop}{$key};
                my @loop = @{$src->{loops}[$loop_nr]};
                my $dst_loop_nr =
                    defined $dst->{loops} ? int(@{$dst->{loops}}) : 0;

                for my $loop_key (@loop) {
                    if( exists $tag_list{$loop_key}) {
                        push( @{$dst->{loops}[$dst_loop_nr]}, $loop_key );
                        $dst->{inloop}{$loop_key} = $dst_loop_nr;
                    }
                }
            }
        }
    }

    return $dst;
}

sub get_cell
{
    my $datablok = $_[0];

    my @cell = (
        exists $datablok->{_cell_length_a} ?
            $datablok->{_cell_length_a}[0] : undef,

        exists $datablok->{_cell_length_b} ?
            $datablok->{_cell_length_b}[0] : undef,

        exists $datablok->{_cell_length_c} ?
            $datablok->{_cell_length_c}[0] : undef,

        exists $datablok->{_cell_angle_alpha} ?
            $datablok->{_cell_angle_alpha}[0] : undef,

        exists $datablok->{_cell_angle_beta} ?
            $datablok->{_cell_angle_beta}[0] : undef,

        exists $datablok->{_cell_angle_gamma} ?
            $datablok->{_cell_angle_gamma}[0] : undef
    );

    return map { defined $_ && /^\s*[?.]\s*$/ ? undef : $_ } @cell;
}

sub restore_last_page
{
    my ( $page_first, $page_last ) = @_;

    if( $page_last > $page_first ) {
        return $page_last;
    } else {
        my $length_last = length( $page_last );
        my $length_first = length( $page_first );
        my $extra = $length_first - $length_last;

        my $leading_digits = substr( $page_first, 0, $extra );

        return $leading_digits . $page_last;
    }
}
