#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Parse a CIF file and print out the essential information in the COD
#  CIF format
#**

use strict;
use lib "./lib/perl5";
use lib "./CIFParser";
use lib "./CIFTags";
use lib ".";
use File::Basename;
use CIFParser;
use CIFDictTags;
use CIFCODTags;
use CIFExcludedTags;
use CIFTagManage;
use Spacegroups::SpacegroupNames;
use Spacegroups::SymopParse;
use Spacegroups::SymopLookup;
use Unicode2CIF;
use SOptions;
use SUsage;

sub mk_symop_key
{
    my ( $symops ) = @_;

    my @canonical = sort 
	map {SymopParse::symop_string_canonical_form($_)} @$symops;
    my $key = join( ";", @canonical );
    return $key;
}

sub mkhash
{
    if( 1 ) {
	map { (mk_symop_key($_->{symops}), $_) } @SymopLookup::table;
    #} else {
    #	map { (mk_symop_key($_->{symops}), $_) } @CCP4SymopLookup::table;
    }
}

my %symop_lookup_table;
## my %symop_lookup_table = mkhash();

sub merge_new_tag_values($$$);

$::max_cif_line_len = 80;
$::max_cif_tag_len = 32;

my $user_biblio = 0;
my $leave_biblio = 0;
my $estimate_spacegroup = 0;
my $exclude_empty_tags = 0;
my $preserve_loop_order = 0;
my $reformat_spacegroup = 0;
my $calculate_cell_volume = 0;
my $record_original_filename = 0;
my $exclude_misspelled_tags = 0;
my $fold_long_fields = 0;
my $fold_title = 0;
my $folding_width = 76;

my $extra_tag_file;
my $original_filename;

my $journal;
my $volume;
my $issue;
my $start_page;
my $end_page;
my $year;
my $title;
my @authors;
my $biblio; # A bibliography file name, possibly marked up by XML-like
	    # or LaTeX-like tags.

my $cif_comment_header; # A header with comments to printed at the
			# beginning of the output CIF file.

my $cif_header_file; # The name of an external file that holds a CIF
		     # header.

my $data_block_nr; # If defined, specifies that data blocks should be
		   # numbered in a COD-like fasion.

my %spacegroups = map {
    my $generated_key = $_->[2];
    $generated_key =~ s/\s//g;
    ($_->[1], $_->[2], $generated_key, $_->[2] )
} @SpacegroupNames::names;

@ARGV = getOptions( 
    "-j,--journal"      => sub{ $user_biblio = 1; $journal = get_value() },
    "-v,--volume"       => sub{ $user_biblio = 1; $volume = get_value() },
    "-i,--issue"        => sub{ $user_biblio = 1; $issue = get_value() },
    "-p,--page"         => sub{ $user_biblio = 1; $start_page = get_value() },
    "--start-page"      => sub{ $user_biblio = 1; $start_page = get_value() },
    "-e,--end-page"     => sub{ $user_biblio = 1; $end_page = get_value() },
    "-y,--year"         => sub{ $user_biblio = 1; $year = get_value() },
    "-B,--bibliography" => \$biblio,

    "-h,--add-cif-header" => \$cif_header_file,

    "-s,--estimate-spacegroup" => sub { $estimate_spacegroup = 1; },
    "-s-,--dont-estimate-spacegroup" => sub { $estimate_spacegroup = 0; },
    "--no-estimate-spacegroup" => sub { $estimate_spacegroup = 0; },

    "-x,--extra-tag-list" => \$extra_tag_file,

    "--exclude-empty-tags"      => sub { $exclude_empty_tags = 1; },
    "--dont-exclude-empty-tags" => sub { $exclude_empty_tags = 0; },
    "--no-exclude-empty-tags"   => sub { $exclude_empty_tags = 0; },

    "--exclude-misspelled-tags"      => sub { $exclude_misspelled_tags = 1; },
    "--dont-exclude-misspelled-tags" => sub { $exclude_misspelled_tags = 0; },
    "--no-exclude-misspelled-tags"   => sub { $exclude_misspelled_tags = 0; },

    "--preserve-loop-order"     => sub { $preserve_loop_order = 1; },
    "--use-internal-loop-order" => sub { $preserve_loop_order = 0; },

    "--reformat-space-group"      => sub { $reformat_spacegroup = 1; },
    "--dont-reformat-space-group" => sub { $reformat_spacegroup = 0; },
    "--leave-space-space-group"   => sub { $reformat_spacegroup = 0; },

    "--calculate-cell-volume"      => sub { $calculate_cell_volume = 1; },
    "--dont-calculate-cell-volume" => sub { $calculate_cell_volume = 0; },

    "--original-filename" => sub { $original_filename = &get_value;
				   $record_original_filename = 1 },
    "--clear-original-filename" => sub { undef $original_filename },

    "--record-original-filename"      => sub { $record_original_filename = 1; },
    "--dont-record-original-filename" => sub { $record_original_filename = 0; },

    "-S,--start-data-block-number"    => \$data_block_nr,
    "-R,--renumber-data-blocks"       => sub { $data_block_nr = 7000001 },
    "-R-,--dont-renumber-data-blocks" => sub { undef $data_block_nr },

    "--folding-width"         => \$folding_width,
    "--fold-title"            => sub{ $fold_title = 1 },
    "--dont-fold-title"       => sub{ $fold_title = 0 },
    "--fold-long-fields"      => sub{ $fold_long_fields = 1 },
    "--dont-fold-long-fields" => sub{ $fold_long_fields = 0 },

    "--leave-bibliography"   => sub{ $leave_biblio = 1 },
    "--discard-bibliography" => sub{ $leave_biblio = 0 },
    "--help,--usage" => sub { SUsage::usage; exit },
);

my @extra_tags = ();

if( $extra_tag_file ) {
    open( EXTRA, "$extra_tag_file" ) or
	die( "could not open tag list '$extra_tag_file' for reading: $!" );
    @extra_tags = map {s/\s//g;$_} map {split} grep /^\s*_/, <EXTRA>;
    close( EXTRA ) or
	die( "error while closing file '$extra_tag_file' after reading" );

    ## local $, = "\n"; local $\ = "\n";
    ## print @extra_tags;
}

my %excluded_tags  = map { ($_,$_) } @CIFExcludedTags::tag_list;

my @dictionary_tags = ( @CIFDictTags::tag_list, @CIFCODTags::tag_list,
			@extra_tags );

my %dictionary_tags = map { $_, $_ } @dictionary_tags;

my %cif_tags_lc = map {(lc($_),$_)} @dictionary_tags;

if( defined $cif_header_file ) {
    open( HEADER, "$cif_header_file" ) or
	die( "could not open CIF header file '$cif_header_file' for reading: $!" );
    local $/; # enable "slurp" mode: read the whole header file.
    $cif_comment_header = <HEADER>;
    close( HEADER ) or
	die( "error while closing file '$cif_header_file' after reading" );
}

my $filename = shift(@ARGV);
my @data;

my $parser = new CIFParser;

@data = @{$parser->Run($filename)};

if( defined $parser->YYData->{ERRCOUNT} && $parser->YYData->{ERRCOUNT} > 0 ) {
    print STDERR "$0: ", $parser->YYData->{ERRCOUNT},
                 " error(s) encountered while parsing file '${filename}'\n";
    die;
}

#------------------------------------------------------------------------------

my %global_bibliography = ();
my @global_biblio_keys = (
    "_journal_name_full",
    "_journal_volume",
    "_journal_issue",
    "_journal_page_first",
    "_journal_page_last",
    "_journal_year",
    "_publ_section_title",
    "_publ_author_name",
    "_journal_coeditor_code"
);

my %global_biblio_keys = map {($_,$_)} @global_biblio_keys;

#
# First, look for a data_global section and extract bibliography
# information. Stupidly enough, this section can be in the very end of
# the CIF file, so we need to scan all sections to find it.
#

my $global_section_nr = 0;

for my $dataset (@data) {
    next unless $dataset->{name} eq "global";
    my $datablock = $dataset->{values};

    $global_section_nr ++;

    %global_bibliography = ();

    merge_new_tag_values( \@global_biblio_keys, \%global_bibliography,
			  $dataset );

    ## use ShowStruct; showRef( \%global_bibliography );
}

if( $global_section_nr > 1 ) {
    warn "file '${filename}' has $global_section_nr global sections";
}

binmode( STDOUT, ":utf8" );

for my $dataset (@data) {

    ## next unless defined $dataset->{kind} && $dataset->{kind} == "DATA";

    my $compound_name = $dataset->{name};
    my $datablok = $dataset->{values};

    # Add bibliography from a global section, if any:

    if( %global_bibliography ) {
	merge_new_tag_values( [keys %{$global_bibliography{values}}],
			      $dataset, \%global_bibliography );
    }

    # convert all tags to a "cannonical" form (the one used in this
    # script ;):

    for my $key ( keys %{$datablok} ) {
	my $lc_key = lc( $key );
	## print ">>> $key -> $lc_key\n";
	if( defined $cif_tags_lc{$lc_key} ) {
	    my $cannonical_key = $cif_tags_lc{$lc_key};
	    ## print ">>> $key -> $lc_key -> $cannonical_key\n";
	    if( !exists $datablok->{$cannonical_key} ) {
		$datablok->{$cannonical_key} = $datablok->{$key};
		delete $datablok->{$key};
		@{$dataset->{tags}} =
		    map { s/^$key$/$cannonical_key/; $_ }
		@{$dataset->{tags}};
		if( exists $dataset->{inloop}{$key} ) {
		    my $loop_nr = $dataset->{inloop}{$key};
		    $dataset->{inloop}{$cannonical_key} =
			$dataset->{inloop}{$key};
		    delete $dataset->{inloop}{$key};
		    @{$dataset->{loops}[$loop_nr]} =
			map { s/^$key$/$cannonical_key/; $_ }
		    @{$dataset->{loops}[$loop_nr]};
		}
	    }
	}
    }

    next if !defined $datablok or !defined $datablok->{_atom_site_label};

    ## print "\n" if $n > 0;

    # Remove empty tags, if requested:

    if( $exclude_empty_tags ) {
	CIFTagManage::exclude_empty_tags( $dataset );
    }

    # Process the bibliography file that was supplied on the command
    # line:

    if( defined $biblio ) {
	my $reference;

	open( BIBLIO, "<:utf8", $biblio ) or
	    die( "Could not open file '$biblio' for reading: $!" );
	if( $biblio =~ /\.ref/ ) {
	    $reference = <BIBLIO>; # read the first line
	} elsif( $biblio =~ /\.xrf/ ) {
	    my @reference = grep !/^\#/, <BIBLIO>;
	    $reference = $reference[0]; # read the first non-comment line
	} else {
	    local $/ = undef; # read the whole file
	    $reference = <BIBLIO>;
	}
	close BIBLIO;
	chomp $reference;

	if( !$leave_biblio ) {
	    for my $key ( grep /_journal_|_publ_section_title|_author_/,
			  keys %{$datablok} ) {
		delete $datablok->{$key};
	    }
	}

	if( $reference =~ /<.*?>.*?<.*?>/s ||
	    $reference =~ /\\.*?(?:\[.*?\])?\{.*?\}/s ) {
	    if( !$title && ( $reference =~ /<title>(.*?)<\/title>/s ||
			     $reference =~ /\\title\{(.*?)\}/s )) {
		my $cif_title = unicode2cif( $1 );
		$cif_title =~ s/\n/ /g;
		$datablok->{_publ_section_title} = [
		    "\n" . join( "\n", map { " " . $_ }
				 fold( 71, " +", " ", $cif_title ))
		];
	    }
	    if( !$journal && ( $reference =~ /<journal>(.*?)<\/journal>/s ||
			       $reference =~ /\\journal\{(.*?)\}/s )) {
		$datablok->{_journal_name_full} = [ unicode2cif( $1 ) ];
	    }
	    if( !$issue && ( $reference =~ /<issue>(.*?)<\/issue>/s ||
			     $reference =~ /\\issue\{(.*?)\}/s )) {
		$datablok->{_journal_issue} = [ unicode2cif( $1 ) ];
	    }
	    if( !$volume && ( $reference =~ /<volume>(.*?)<\/volume>/s ||
			      $reference =~ /\\volume\{(.*?)\}/s )) {
		$datablok->{_journal_volume} = [ unicode2cif( $1 ) ];
	    }
	    if( !$year && ( $reference =~ /<year>(.*?)<\/year>/s ||
			    $reference =~ /\\year\{(.*?)\}/s )) {
		my $y = $1;
		$y =~ s/[^0-9]//g;
		$datablok->{_journal_year} = [ unicode2cif( $y ) ];
	    }
	    if( !$start_page && ( $reference =~ /<pages?>(.*?)<\/pages?>/s ||
				  $reference =~ /\\pages?\{(.*?)\}/s )) {
		my @pages = map { s/\s//g; $_ } split ( "-", $1 );
		$datablok->{_journal_page_first} = [ unicode2cif( $pages[0] ) ];
		if( int(@pages) > 1 ) {
		    $datablok->{_journal_page_last} =
			[ unicode2cif( $pages[1] ) ];
		}
	    }
	    if( !@authors && ( $reference =~
			       /<authors?\s?(.*?)>(.*?)<\/authors?>/s ||
			       $reference =~
			       /\\authors?(?:\[(.*?)\])?\{(.*?)\}/s )) {
		my $attributes = $1;
		my $author_list = $2;
		my $separator = qr/,\s*and|\sand\s|,/;
		if( $attributes && $attributes =~ /separator\s*=\s*"(.*?)"/ ) {
		    $separator = qr/$1/;
		}
		$datablok->{_publ_author_name} =
		    [
		     map { unicode2cif( $_ ) }
		     map { s/\n/ /g; s/\s+/ /g; $_ }
		     map { s/^\s*|\s*$//g; $_ }
		     split( $separator, $author_list )
		    ];
		my $tag = "_publ_author_name";
		if( exists $dataset->{inloop}{$tag} ) {
		    my $loop_nr = $dataset->{inloop}{$tag};
		    $dataset->{loops}[$loop_nr] = [ $tag ];
		} else {
		    if( exists $dataset->{loops} ) {
			push( @{$dataset->{loops}}, [ $tag ] );
			$dataset->{inloop}{$tag} = $#{$dataset->{loops}};
		    } else {
			$dataset->{inloop}{$tag} = 0;
			$dataset->{loops} = [ [ $tag ] ];
		    }
		}
	    }
	}
    }

    # User specified bibliography is processed last since it must take
    # precedence over the original CIF bibliography and over the
    # bibliography file data:

    if( $user_biblio ) {
	if( !$leave_biblio ) {
	    for my $key ( grep /_journal_|_publ_section_title|_author_/,
			  keys %{$datablok} ) {
		delete $datablok->{$key};
	    }
	}

	do {
	    $datablok->{_publ_author_name} = [ @authors ];
	    my $tag = "_publ_author_name";
	    if( exists $dataset->{inloop}{$tag} ) {
		my $loop_nr = $dataset->{inloop}{$tag};
		$dataset->{loops}[$loop_nr] = [ $tag ];
	    } else {
		if( exists $dataset->{loops} ) {
		    push( @{$dataset->{loops}}, [ $tag ] );
		    $dataset->{inloop}{$tag} = $#{$dataset->{loops}};
		} else {
		    $dataset->{inloop}{$tag} = 0;
		    $dataset->{loops} = [ [ $tag ] ];
		}
	    }
	} if @authors;

	$datablok->{_publ_section_title} = [ $title ]
	    if defined $title;

	$datablok->{_journal_name_full} = [ $journal ]
	    if defined $journal;

	$datablok->{_journal_year} = [ $year ]
	    if defined $year;

	$datablok->{_journal_volume} = [ $volume ]
	    if defined $volume;

	$datablok->{_journal_issue} = [ $issue ]
	    if defined $issue;

	$datablok->{_journal_page_first} = [ $start_page ]
	    if defined $start_page;

	$datablok->{_journal_page_last} = [ $end_page ]
	    if defined $end_page;
    }

    #
    # Fold title if requested:

    if( $fold_title ) {
	my $cif_title = join( " ", @{$datablok->{_publ_section_title}} );
	$cif_title =~ s/\n/ /g;
	$datablok->{_publ_section_title} = [
	    "\n" . join( "\n", map { " " . $_ }
				 fold( $folding_width - 2, " +", " ", $cif_title ))
	    ];
    }

    # Exclude potentially copyrighted and irrelevant tags
    # unconditionally:

    do {
	my @tag_list = @{$dataset->{tags}};
	for my $tag (@tag_list) {
	    if( exists $excluded_tags{$tag} || $tag =~ /^_vrf_/ ) {
		CIFTagManage::exclude_tag( $dataset, $tag );
		#use ShowStruct;
		#showRef( $dataset );
	    }
	}
    };

    # Check for misspelled tags:

    for my $tag (@{$dataset->{tags}}) {
	unless( exists $dictionary_tags{$tag} ) {
	    print STDERR basename( $0 ) . ": ";
	    print STDERR "tag '$tag' is not recognised\n";
	}
    }

    # Exclude the misspelled tags if requested:

    if( $exclude_misspelled_tags ) {
	my @tag_list = @{$dataset->{tags}};
	for my $tag (@tag_list) {
	    unless( exists $dictionary_tags{$tag} ) {
		CIFTagManage::exclude_tag( $dataset, $tag );
	    }
	}
    }

    # Add the data source file name, if requested:

    if( $record_original_filename ) {
	my $basename;
	if( defined $original_filename ) {
	    $basename = File::Basename::basename( $original_filename );
	} elsif( defined $filename && $filename ne "-" ) {
	    $basename = File::Basename::basename( $filename );
	} else {
	    $basename = "?";
	}
	set_tag( $dataset, "_[local]_cod_data_source_file", $basename );
	set_tag( $dataset, "_[local]_cod_data_source_block", $dataset->{name} );
    }

    # Clean up the resulting CIF data structure:

    for my $excluded_tag (qw( _publ_author_address
                              _publ_author.address
                              _publ_author_email
                              _publ_author.email
                              _publ_author_footnote
                              _publ_author.footnote
                              _publ_author_id_iucr
                              _publ_author.id_iucr )) {
	if( exists $datablok->{$excluded_tag} ) {
	    CIFTagManage::exclude_tag( $dataset, $excluded_tag );
	    #use ShowStruct;
	    #showRef( $dataset );
	}
    }

    # Correct the formatting of the H-M spacegroup symbol:

    if( $reformat_spacegroup ) {
	for my $sg_tag (qw (
            _symmetry_space_group_name_H-M
            _space_group_name_H-M_alt
            _space_group.name_H-M_full
        )) {
	    ##use ShowStruct;
	    ##showRef( \%spacegroups  );
	    if( exists $datablok->{$sg_tag} ) {
		my $orig_sg = $datablok->{$sg_tag}[0];
		$orig_sg =~ s/[()~\s]//g;
		##print ">>> $orig_sg\n";
		if( exists $spacegroups{$orig_sg} ) {
		    $datablok->{$sg_tag}[0] = $spacegroups{$orig_sg};
		}
	    }
	}
    }

    # Determine space group symbols from symmetry elements if requested:

    if( $estimate_spacegroup ) {
	if( !%symop_lookup_table ) {
	    %symop_lookup_table = mkhash();
	}
	if( exists $datablok->{"_symmetry_equiv_pos_as_xyz"} ) {
	    my $has_errors = 0;
	    my @symops = @{$datablok->{"_symmetry_equiv_pos_as_xyz"}};
	    for my $symop (@symops) {
		my $error = SymopParse::check_symmetry_operator( $symop );
		if( $error ) {
		    $has_errors = 1;
		    print STDERR "$0: $filename: $error\n";
		}
	    }
	    if( !$has_errors ) {
		my $key = mk_symop_key( \@symops );
		my $original_sg_H_M =
		    defined $datablok->{"_symmetry_space_group_name_H-M"} ?
		    $datablok->{"_symmetry_space_group_name_H-M"}[0] :
		    undef;
		my $original_sg_Hall =
		    defined $datablok->{"_symmetry_space_group_name_Hall"} ?
		    $datablok->{"_symmetry_space_group_name_Hall"}[0] :
		    undef;
		my $original_sg_number =
		    defined $datablok->{"_space_group_IT_number"} ?
		    $datablok->{"_space_group_IT_number"}[0] :
		    undef;

		if( exists $symop_lookup_table{$key} ) {
		    my $estimated_sg = $symop_lookup_table{$key};

		    my $estimated_sg_H_M = $estimated_sg->{hermann_mauguin};
		    if( defined $original_sg_H_M &&
			$original_sg_H_M ne '?' &&
			$original_sg_H_M ne $estimated_sg_H_M ) {
			set_tag( $dataset, "_[local]_cod_cif_authors_sg_H-M",
				 $original_sg_H_M );
		    }
		    set_tag( $dataset, "_symmetry_space_group_name_H-M",
			     $estimated_sg_H_M );

		    my $estimated_sg_Hall = $estimated_sg->{hall};
		    $estimated_sg_Hall =~ s/^\s*//;
		    if( defined $original_sg_Hall &&
			$original_sg_Hall ne '?' &&
			$original_sg_Hall ne $estimated_sg_Hall ) {
			set_tag( $dataset, "_[local]_cod_cif_authors_sg_Hall",
				 $original_sg_Hall );
		    }
		    set_tag( $dataset, "_symmetry_space_group_name_Hall",
			     $estimated_sg_Hall );

		    my $estimated_sg_number = $estimated_sg->{number};
		    if( defined $original_sg_number &&
			$original_sg_number != $estimated_sg_number ) {
			set_tag( $dataset, "_[local]_cod_cif_authors_sg_number",
				 $original_sg_number );
		    }
		    set_tag( $dataset, "_space_group_IT_number",
			     $estimated_sg_number );
		} else {

		    if( defined $original_sg_H_M && $original_sg_H_M ne '?' ) {
			set_tag( $dataset, "_[local]_cod_cif_authors_sg_H-M",
				 $original_sg_H_M );
		    }
		    set_tag( $dataset, "_symmetry_space_group_name_H-M", '?' );

		    if( defined $original_sg_Hall && $original_sg_Hall ne '?' ) {
			set_tag( $dataset, "_[local]_cod_cif_authors_sg_Hall",
				 $original_sg_Hall );
		    }
		    set_tag( $dataset, "_symmetry_space_group_name_Hall",'?' );

		    if( defined $original_sg_number ) {
			set_tag( $dataset, "_[local]_cod_cif_authors_sg_number",
				 $original_sg_number );
		    }
		    set_tag( $dataset, "_space_group_IT_number", '?' );
		}
	    }
	} else {
	    print STDERR "$0: the ", defined $filename ? "'$filename' " : "",
	        "data_$dataset->{name} does not contain symmetry operators\n";
	}
    }

    # Calculate essential information if it is missing but requested:

    if( $calculate_cell_volume ) {
	if( !exists $datablok->{"_cell_volume"} &&
	    exists $datablok->{"_cell_length_a"} ) {
	    my @cell = get_cell( $datablok );
	    $datablok->{"_cell_volume"}[0] =
		sprintf( "%7.2f", cell_volume( @cell ));
	}
    }
    
    # Print out the CIF header if requested:

    if( defined $cif_comment_header ) {
	print $cif_comment_header;
    }

    # Print out requested tags:

    my %printed_loops = ();

    if( defined $data_block_nr ) {
	printf "data_%07d\n", $data_block_nr;
	$data_block_nr ++;
    } else {
	print "data_", $compound_name, "\n";
    }

    for my $tag (@dictionary_tags) {
	if( defined $datablok->{$tag} ) {
	    if( !exists $dataset->{inloop}{$tag} ) {
		print_tag( $tag, $datablok );
	    } elsif( $tag eq "_publ_author_name" ) {
		my $tag_loop_nr = $dataset->{inloop}{$tag};
		unless( exists $printed_loops{$tag_loop_nr} ) {
		    print_loop( $tag, $tag_loop_nr, $dataset );
		    $printed_loops{$tag_loop_nr} = 1;
		}
	    }
	}
    }

    # Print out any tags that are not in the dictionary (most probably
    # some misspelled tags):

    if( !$exclude_misspelled_tags ) {
	my $tags_encountered = 0;
	for my $tag (@{$dataset->{tags}}) {
	    if( !exists $dictionary_tags{$tag} &&
		!exists $dataset->{inloop}{$tag} ) {
		if( !$tags_encountered ) {
		    print "#BEGIN Tags that were not found in dictionaries:\n";
		    $tags_encountered = 1;
		}
		print_tag( $tag, $datablok );
	    }
	}
	if( $tags_encountered ) {
	    print "#END Tags that were not found in dictionaries\n";
	}
    }

    # Print out loops:

    my @tags_for_output;

    if( $preserve_loop_order ) {
	@tags_for_output = @{$dataset->{tags}}
    } else {
	@tags_for_output = @dictionary_tags;
    }

    for my $tag (@tags_for_output) {
	if( defined $datablok->{$tag} ) {
	    if( exists $dataset->{inloop}{$tag} ) {
		my $tag_loop_nr = $dataset->{inloop}{$tag};
		unless( exists $printed_loops{$tag_loop_nr} ) {
		    print_loop( $tag, $tag_loop_nr, $dataset );
		    $printed_loops{$tag_loop_nr} = 1;
		}
	    }
	}
    }

    # Print out loops that contain only non-dictionary tags:

    if( !$exclude_misspelled_tags ) {
	my $tags_encountered = 0;
	for my $tag (@{$dataset->{tags}}) {
	    if( exists $dataset->{inloop}{$tag} && 
		! exists $dictionary_tags{$tag} ) {
		my $tag_loop_nr = $dataset->{inloop}{$tag};
		unless( exists $printed_loops{$tag_loop_nr} ) {
		    if( !$tags_encountered ) {
			print "#BEGIN Loops that were not found in " .
			    "dictionaries:\n";
			$tags_encountered = 1;
		    }
		    print_loop( $tag, $tag_loop_nr, $dataset );
		    $printed_loops{$tag_loop_nr} = 1;
		}
	    }
	}
	if( $tags_encountered ) {
	    print "#END Loops that were not found in dictionaries\n";
	}
    }

}

#
# Subroutines:
#

sub print_tag
{
    my ($key, $tags) = @_;

    if( exists $tags->{$key} ) {
	my $val = $tags->{$key};
	if( int(@{$val}) > 1 ) {
	    print "loop_\n";
	    print "$key\n";
	    for my $value (@$val) {
		print_value( $value );
		print "\n";
	    }
	} else {
	    my $value = sprint_value( $val->[0] );
	    my $key_len = length($key) > $::max_cif_tag_len ?
		length($key) : $::max_cif_tag_len;
	    my $val_len = length($value);

	    if( $value =~ /\s/ ) {
		$val_len += 2;
	    }
	    if( $key_len + $val_len + 1 > $::max_cif_line_len &&
		$value !~ /\n/ ) {
		printf "%s\n", $key;
	    } else {
		if( $value !~ /\n/ ) {
		    printf "%-" . $::max_cif_tag_len . "s ", $key;
		} else {
		    printf "%s", $key;
		}
	    }
	    print $value, "\n";
	}
    }
}

sub print_loop
{
    my ($tag, $loop_nr, $tags) = @_;

    my @loop_tags = @{$tags->{loops}[$loop_nr]};

    print "loop_\n";
    for (@loop_tags) {
	print $_, "\n";
    }

    my $val_array = $tags->{values}{$tag};
    my $last_val = $#{$val_array};

    my $line_prefix = "";
    for my $i (0..$last_val) {
	my $folding_separator = "";
	my $lines = "";
	my $line = $line_prefix;
	for my $loop_tag (@loop_tags) {
	    my $val = sprint_value( $tags->{values}{$loop_tag}[$i] );
	    if( $val =~ /^\n;/ ) {
		$lines .= $folding_separator . $line if $line ne $line_prefix;
		if( $lines eq "" ) {
		    # don't print extra newline at the beginning of the loop:
		    $val =~ s/^\n//;
		}
		$lines .= $val;
		$line = $line_prefix;
		$folding_separator = "\n";
	    } elsif( length( $line ) + length( $val ) + 1 
		     < $::max_cif_line_len ) {
		if( $line eq $line_prefix ) {
		    $line .= $val;
		} else {
		    $line .= " " . $val;
		}
	    } else {
		$lines .= $folding_separator . $line;
		$line = $line_prefix . $val;
		$folding_separator = "\n";
	    }
	}
	if( $line ne $line_prefix ) {
	    $lines .= $folding_separator . $line;
	}
	print $lines;
	print "\n";
    }
}

sub print_value
{
    print &sprint_value
}

sub maxlen
{
    my $val = $_[0];
    my $len = 0;

    for (split( "\n", $val )) {
	$len = length if length > $len;
    }
    return $len;
}

sub sprint_value
{
    my $val = $_[0];

    if( $fold_long_fields && maxlen($val) > $folding_width - 2 ) {
	$val = join( "\n", map { " " . $_ }
		     fold( $folding_width - 1, " +", " ", $val ));
	$val =~ s/^\s+//g;
    }

    if( $val =~ /\n/ || $val =~ /^$/ ) {
	$val = "\n;" . $val . "\n;";
    } elsif( $val =~ /\s/) {
	$val = "'" . $val . "'";
    }
    return $val;
}

sub fold
{
    my $length = shift;
    my $separator = shift;
    my $ors = shift;
    my $string = shift;
    my @lines = ();
    my $line = "";

    my $word;
    for $word (split( $separator, $string )) {
	$word =~ s/^\s*|\s*$//g;
	if( !$line ) {
	    $line = $word;
	} else {
	    my $new_line = "$line$ors$word";
	    if( length($new_line) < $length ) {
		$line = $new_line;
	    } else {
		push( @lines, $line );
		$line = $word;
	    }
	}
    }
    push( @lines, $line );
    return @lines;
}

sub cell_volume
{
    my @cell = map { s/\(.*\)//g; $_ } @_;

    my $Pi = 3.14159265358979;

    my ($a, $b, $c) = @cell[0..2];
    my ($alpha, $beta, $gamma) = map {$Pi * $_ / 180} @cell[3..5];
    my ($ca, $cb, $cg) = map {cos} ($alpha, $beta, $gamma);
    my $sg = sin($gamma);
    
    my $V = $a * $b * $c * sqrt( $sg**2 - $ca**2 - $cb**2 + 2*$ca*$cb*$cg );

    return $V;
}

sub merge_new_tag_values($$$)
{
    my ($tag_list, $dst, $src ) = @_;

    my %tag_list = map {($_,1)} @$tag_list;

    for my $key (@{$tag_list}) {
	if( defined $src->{values}{$key}
	    && !exists $dst->{values}{$key} ) {

	    $dst->{values}{$key} = $src->{values}{$key};
	    push( @{$dst->{tags}}, $key );

	    if( exists $src->{inloop}{$key} &&
		!exists $dst->{inloop}{$key} ) {
		my $loop_nr = $src->{inloop}{$key};
		my @loop = @{$src->{loops}[$loop_nr]};
		my $dst_loop_nr =
		    defined $dst->{loops} ? int(@{$dst->{loops}}) : 0;

		for my $loop_key (@loop) {
		    if( exists $tag_list{$loop_key}) {
			push( @{$dst->{loops}[$dst_loop_nr]}, $loop_key );
			$dst->{inloop}{$loop_key} = $dst_loop_nr;
		    }
		}
	    }
	}
    }

    return $dst;
}

sub get_cell
{
    my $datablok = $_[0];

    return (
	$datablok->{_cell_length_a}[0],
	$datablok->{_cell_length_b}[0],
	$datablok->{_cell_length_c}[0],
	$datablok->{_cell_angle_alpha}[0],
	$datablok->{_cell_angle_beta}[0],
	$datablok->{_cell_angle_gamma}[0]
    );
}
