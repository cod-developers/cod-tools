#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Format run time error and warning messages in a uniform way.
#**

package COD::UserMessage;

use strict;
use warnings;
require Exporter;
@COD::UserMessage::ISA = qw(Exporter);
@COD::UserMessage::EXPORT = qw( print_message error warning note parse_message sprint_message );

#==============================================================================
# Print a message, reporting a program name, file name, data block
# name and am error level (ERROR or WARNING) in a uniform way.
#
# For ease of parsing error messages from log files, $message should
# probably not contain a colon (":") since colon is used to separate
# different parts of the error message.

sub sprint_message($$$$$@)
{
    my ( $program, $filename, $datablock, $errlevel,
         $message, $line, $column ) = @_;

    $message =~ s/\.?\n?$//;
    return $program . ": " . $filename .
           (defined $line
                ? "($line" . (defined $column ? ",$column" : "" ) . ")"
                : "") .
           (defined $datablock ? " data_" . $datablock : "") .
           (defined $errlevel ? ": " . $errlevel : "") .
           ", " . $message . ".\n";
}

#==============================================================================
# Generic function for printing messages to STDERR

sub print_message($$$$$@)
{
    my ( $program, $filename, $datablock, $errlevel,
         $message, $line, $column ) = @_;
    print STDERR sprint_message( $program, $filename, $datablock,
                                 $errlevel, $message, $line, $column );
}

#==============================================================================
# Parse an error message, generated by print_message. To be parsed
# correctly, program, file and datablock names as well as error level must
# not not contain colons (':'). Error level is confined to uninterrupted
# word without colons and commas (','). Error level can be separated from
# the rest of the message by colon.
sub parse_message($)
{
    my( $message ) = @_;
    if( $message =~ /^
                        ([^:]+):\ 
                        ([^:]+?)
                            (?:\((\d+)(?:,(\d+))?\))?
                            (?:\ data_([^:]+?))?
                        :\ 
                        (?:([^,:\ ]+?)[,:]\ )?
                        (.+?)\.?
                    $/x ) {
        return {
            program   => $1,
            filename  => $2,
            line      => $3,
            column    => $4,
            datablock => $5,
            errlevel  => $6,
            message   => $7
        };
    } else {
        return undef;
    }
}

#==============================================================================
# Report an error message. Errors are indicated with the "ERROR"
# keyword in the message line. This is supposed to be a fatal even,
# and the program will most probably die() or exit(255) after this
# message, but the UserMessage package does not enforce this policy.

sub error($$$$)
{
    my ( $program, $filename, $datablock, $message ) = @_;
    print_message( $program, $filename, $datablock, "ERROR", $message );
}

#==============================================================================
# Report a warning message. Warnings are indicated with the "WARNING"
# keyword. Program can probably continue after warnings and give a
# reasonable result, but it might be not the result which the user
# expected.

sub warning($$$$)
{
    my ( $program, $filename, $datablock, $message ) = @_;
    print_message( $program, $filename, $datablock, "WARNING", $message );
}

#==============================================================================
# Report a note message. Notes are indicated with the "NOTE"
# keyword. Program can always continue after issuing notes as the intent
# of note is just to provide information on the progress.

sub note($$$$)
{
    my ( $program, $filename, $datablock, $message ) = @_;
    print_message( $program, $filename, $datablock, "NOTE", $message );
}

1;
