#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl5 -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Parse a CIF file and print out the essential information in the COD
#  REF format
#**

use strict;
use lib "./lib/perl5";
use STAR::Parser;
use Unicode2CIF;
use SOptions;
use SUsage;

my $user_biblio = 0;
my $leave_biblio = 0;

my $journal;
my $volume;
my $issue;
my $start_page;
my $end_page;
my $year;
my $title;
my @authors;

my $no_biblio_tags = 1;

@ARGV = getOptions( 
    "-j,--journal"   => sub{ $user_biblio = 1; $journal = get_value() },
    "-v,--volume"    => sub{ $user_biblio = 1; $volume = get_value() },
    "-p,--page"      => sub{ $user_biblio = 1; $start_page = get_value() },
    "--start-page"   => sub{ $user_biblio = 1; $start_page = get_value() },
    "-e,--end-page"  => sub{ $user_biblio = 1; $end_page = get_value() },
    "-y,--year"      => sub{ $user_biblio = 1; $year = get_value() },
    "--leave-bibliography"   => sub{ $leave_biblio = 1 },
    "--discard-bibliography" => sub{ $leave_biblio = 0 },
    "--help,--usage" => sub { SUsage::usage; exit },
);

my $filename = shift(@ARGV);
my $biblio = @ARGV > 0 ? shift(@ARGV) : undef;
my @data;

@data = STAR::Parser->parse(-file=>$filename);

my @requested_cif_tags = (
    "_publ_author_name",
    "_publ_section_title",
    "_journal_name_full",
    "_journal_year",
    "_journal_volume",
    "_journal_issue",
    "_journal_page_first",
    "_journal_page_last",
    "_chemical_formula_sum",
    "_chemical_name_systematic",
    "_cell_measurement_temperature",
    "_diffrn_ambient_temperature",
    "_cell_length_a",
    "_cell_length_b",
    "_cell_length_c",
    "_cell_angle_alpha",
    "_cell_angle_beta",
    "_cell_angle_gamma",
    "_symmetry_space_group_name_H-M",
    "_symmetry_equiv_pos_as_xyz",
    "_atom_site_B_iso_or_equiv",
    "_atom_site_calc_flag",
    "_atom_site_refinement_flags",
    "_atom_site_disorder_assembly",
    "_atom_site_disorder_group",
    #
    # Data collection parameters:
    #
    "_diffrn_radiation_type",
    "_diffrn_radiation_wavelength",
    "_diffrn_reflns_number",
    "_diffrn_reflns_av_R_equivalents",
    "_diffrn_reflns_av_sigmaI/netI",
    "_diffrn_reflns_limit_h_min",
    "_diffrn_reflns_limit_h_max",
    "_diffrn_reflns_limit_k_min",
    "_diffrn_reflns_limit_k_max",
    "_diffrn_reflns_limit_l_min",
    "_diffrn_reflns_limit_l_max",
    "_diffrn_reflns_theta_min",
    "_diffrn_reflns_theta_max",
    "_reflns_number_total",
    "_reflns_number_gt",
    "_reflns_threshold_expression",
    #
    # Refinement statistics:
    #
    "_refine_ls_number_reflns",
    "_refine_ls_number_parameters",
    "_refine_ls_number_restraints",
    "_refine_ls_R_factor_all",
    "_refine_ls_R_factor_gt",
    "_refine_ls_wR_factor_ref",
    "_refine_ls_wR_factor_gt",
);

my %looped_tags = (
    "_publ_author_name" => 1,
);

my $n = 0;

binmode( STDOUT, ":utf8" );

for my $dataset (@data) {

    next unless defined $dataset->{DATA};

    my $compounds = $dataset->{DATA};
    my @names = keys %{$compounds};

    ## print int(@data), "\n"; exit;

    my $compound_name = $names[0];
    my $compound = $compounds->{$compound_name};
    my $category = defined $compound ? $compound->{"-"} : undef;
    my $datablok = defined $category ? $category->{"-"} : undef;

    next if !defined $datablok or !defined $datablok->{_atom_site_label};

    print "\n" if $n > 0;

    # Process bibliography:

    if( $user_biblio ) {
	if( !$leave_biblio ) {
	    for my $key ( grep /_journal_|_publ_section_title|_author_/,
			  keys %{$datablok} ) {
		delete $datablok->{$key};
	    }
	}

	$datablok->{_journal_name_full} = [ $journal ]
	    if defined $journal;

	$datablok->{_journal_year} = [ $year ]
	    if defined $year;

	$datablok->{_journal_volume} = [ $volume ]
	    if defined $volume;

	$datablok->{_journal_page_first} = [ $start_page ]
	    if defined $start_page;

	$datablok->{_journal_page_last} = [ $end_page ]
	    if defined $end_page;
    }

    my $reference;

    if( defined $biblio ) {
	open( BIBLIO, "<:utf8", $biblio ) or
	    die( "Could not open file '$biblio' for reading: $!" );
	if( $biblio =~ /\.ref/ ) {
	    $reference = <BIBLIO>; # read the first line
	} elsif( $biblio =~ /\.xrf/ ) {
	    my @reference = grep !/^\#/, <BIBLIO>;
	    $reference = $reference[0]; # read the first non-comment line
	} else {
	    local $/ = undef; # read the whole file
	    $reference = <BIBLIO>;
	}
	close BIBLIO;
	chomp $reference;
	if( (!$user_biblio || $leave_biblio) &&
	    ( $reference =~ /<.*?>.*?<.*?>/s ||
	      $reference =~ /\\.*?(?:\[.*?\])?\{.*?\}/s )) {
	    if( !$title && ( $reference =~ /<title>(.*?)<\/title>/s ||
			     $reference =~ /\\title\{(.*?)\}/s )) {
		$datablok->{_publ_section_title} = [ unicode2cif( $1 ) ];
	    }
	    if( !$journal && ( $reference =~ /<journal>(.*?)<\/journal>/s ||
			       $reference =~ /\\journal\{(.*?)\}/s )) {
		$datablok->{_journal_name_full} = [ unicode2cif( $1 ) ];
	    }
	    if( !$issue && ( $reference =~ /<issue>(.*?)<\/issue>/s ||
			     $reference =~ /\\issue\{(.*?)\}/s )) {
		$datablok->{_journal_issue} = [ unicode2cif( $1 ) ];
	    }
	    if( !$volume && ( $reference =~ /<volume>(.*?)<\/volume>/s ||
			      $reference =~ /\\volume\{(.*?)\}/s )) {
		$datablok->{_journal_volume} = [ unicode2cif( $1 ) ];
	    }
	    if( !$year && ( $reference =~ /<year>(.*?)<\/year>/s ||
			    $reference =~ /\\year\{(.*?)\}/s )) {
		my $y = $1;
		$y =~ s/[^0-9]//g;
		$datablok->{_journal_year} = [ unicode2cif( $y ) ];
	    }
	    if( !$start_page && ( $reference =~ /<pages?>(.*?)<\/pages?>/s ||
				  $reference =~ /\\pages?\{(.*?)\}/s )) {
		my @pages = map { s/\s//g; $_ } split ( "-", $1 );
		$datablok->{_journal_page_first} = [ unicode2cif( $pages[0] ) ];
		if( int(@pages) > 1 ) {
		    $datablok->{_journal_page_last} =
			[ unicode2cif( $pages[1] ) ];
		}
	    }
	    if( !@authors && ( $reference =~
			       /<authors?\s?(.*?)>(.*?)<\/authors?>/s ||
			       $reference =~
			       /\\authors?(?:\[(.*?)\])?\{(.*?)\}/s )) {
		my $attributes = $1;
		my $author_list = $2;
		my $separator = qr/,|\sand\s/;
		if( $attributes && $attributes =~ /separator\s*=\s*"(.*?)"/ ) {
		    $separator = qr/$1/;
		}
		$datablok->{_publ_author_name} =
		    [
		     map { unicode2cif( $_ ) }
		     map { s/\n/ /g; $_ }
		     map { s/^\s*|\s*$//g; $_ }
		     split( $separator, $author_list )
		    ];
	    }
	}

	if( $no_biblio_tags ) {
	    while( $reference =~ /<(.*?)(\s+.*?)?>(.*?)<\/.*>/s ) {
		my $tag = $1;
		my $regexp = qr/<$tag(?:\s+.*?)?>(.*?)<\/$tag>/s;
		## print "\n<$tag>:\n";
		while( $reference =~ /$regexp/ ) {
		    $reference =~ s/$regexp/$1/g;
		}
		## print ">>>$reference\n";
	    }
	    while( $reference =~ /\\(.*?)(?:(\[.*?\]))?\{(.*?)\}/s ) {
		my $tag = $1;
		my $regexp = qr/\\$tag(?:\[.*?\])?\{(.*?)\}/s;
		## print "\n\\$tag:\n";
		while( $reference =~ /$regexp/ ) {
		    $reference =~ s/$regexp/$1/g;
		}
		## print ">>>$reference\n";
	    }
	}

	$reference =~ s/\n/ /g;
    }


    # Clean away "empty" tags:

    for my $atom_site_tag ( "_atom_site_calc_flag",
			    "_atom_site_disorder_assembly",
			    "_atom_site_disorder_group" ) {
	if( defined $datablok->{$atom_site_tag} ) {
	    my $has_value = 0;
	    for my $val ( @{$datablok->{$atom_site_tag}} ) {
		if( defined $val && $val ne '.' && $val ne '?' ) {
		    $has_value = 1;
		    last;
		}
	    }
	    if( !$has_value ) {
		delete $datablok->{$atom_site_tag};
	    }
	}
    }

    # Print out requested tags:

    for my $tag (@requested_cif_tags) {
	if( defined $datablok->{$tag} ) {
	    my $data = $datablok->{$tag};
	    if( int(@{$data}) == 1 && !$looped_tags{$tag} ) {
		my @lines = split( "\n", $data->[0] );
		for my $line (@lines) {
		    print "#", $tag, "\t", $line, "\n";
		}
	    } else {
		for my $j (0..$#{$data}) {
		    my @lines = split( "\n", $data->[$j] );
		    for my $line (@lines) {
			print "#", $tag, "[", $j, "]", "\t", $line, "\n";
		    }
		}
	    }
	}
    }

    # Chemical formula:
    my $formula = $datablok->{_chemical_formula_sum}[0];
    if( defined $formula ) {
	$formula =~ s/^\s*|\s*$//g;
    } else {
	$formula = "?";
    }

    # Cell constants:
    my $a = $datablok->{_cell_length_a}[0];
    my $b = $datablok->{_cell_length_b}[0];
    my $c = $datablok->{_cell_length_c}[0];
    my $alpha = $datablok->{_cell_angle_alpha}[0];
    my $beta  = $datablok->{_cell_angle_beta}[0];
    my $gamma = $datablok->{_cell_angle_gamma}[0];

    # Spacegroup:
    my $spacegroup = $datablok->{"_symmetry_space_group_name_H-M"}[0];

    # Atom records:

    my $atom = $datablok->{_atom_site_label};

    my $x = $datablok->{_atom_site_fract_x};
    my $y = $datablok->{_atom_site_fract_y};
    my $z = $datablok->{_atom_site_fract_z};

    my $q = $datablok->{_atom_site_occupancy};
    my $U = $datablok->{_atom_site_U_iso_or_equiv};
    
    if( !defined $U ) {
	$U = $datablok->{_atom_site_Uiso_or_Biso};
    }

    if( !defined $U && defined $datablok->{_atom_site_B_iso_or_equiv} ) {
	my $B = $datablok->{_atom_site_B_iso_or_equiv};
	my $Pi = 3.14159265358979;
	for my $i ( 0..$#{$B} ) {
	    my $b = $B->[$i];
	    $b =~ s/\(.*\)$//;
	    $datablok->{_atom_site_U_iso_or_equiv}[$i] = $b/(8*$Pi**2);
	}
	$U = $datablok->{_atom_site_U_iso_or_equiv};
    }

    my $multiplicity = $datablok->{_atom_site_symmetry_multiplicity};

    if( !defined $multiplicity ) {
	$datablok->{_atom_site_symetry_multiplicity};
    }

    my $Wyckoff_sym = $datablok->{_atom_site_Wyckoff_symbol};

    # Anisotripoc temperature factor records:

    my $aniso_label = $datablok->{_atom_site_aniso_label};
    my @anisou = (
	$datablok->{_atom_site_aniso_U_11},
	$datablok->{_atom_site_aniso_U_22},
	$datablok->{_atom_site_aniso_U_33},
	$datablok->{_atom_site_aniso_U_23},
	$datablok->{_atom_site_aniso_U_13},
	$datablok->{_atom_site_aniso_U_12},
    );

    my @bonds = (
	$datablok->{_geom_bond_atom_site_label_1},
	$datablok->{_geom_bond_atom_site_label_2},
	$datablok->{_geom_bond_distance},
    );

    # Print it out:

    if( $reference ) {
	print $reference, "\n";
    } else {
	print "?\n";
    }

    do {
	local $, = " ";
	local $\ = "\n";

	print $formula;

	print $a, $b, $c, $alpha, $beta, $gamma;

	$spacegroup =~ s/^\s*|\s*$//g;
	print $spacegroup;

	for my $i (0..$#{$atom}) {
	    print
		$atom->[$i],
		defined $multiplicity ? $multiplicity->[$i] : "?",
		defined $Wyckoff_sym ? $Wyckoff_sym->[$i] : "?",
		$x->[$i], $y->[$i], $z->[$i],
		defined $q ? $q->[$i] : "?",
		$U->[$i];
	}
    };

    if( defined $aniso_label and int(@{$aniso_label}) > 0 ) {
	for my $i (0..$#{$aniso_label}) {
	    print "ANISOU ", $aniso_label->[$i];
	    for my $anisou (@anisou) {
		print " ", $anisou->[$i];
	    }
	    print "\n";
	}
    }

    if( int(@bonds) > 0 ) {
	for my $i (0..$#{$bonds[0]}) {
	    print "BOND ";
	    for my $bond_parameter (@bonds) {
		print " ", $bond_parameter->[$i];
	    }
	    print "\n";
	}
    }

    $n ++;
}
