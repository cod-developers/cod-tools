# --*-Perl-*----------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
# -------------------------------------------------------------- 
#
# parse.yp
#
# Parsed CIF file structure overview is described at the end of this file.
# --------------------------------------------------------------
# begin of header
# --------------------------------------------------------------
# copy directly to PERL module:
%{
use warnings;
use ShowStruct;
use FileHandle;

$CIFParser::version = '1.0';

my $SVNID = '$Id$';

# 0 - no debug
# 1 - only YAPP output (type -> value)
# 2 - lex & yapp output
# 3 - generated array dump
$CIFParser::debug = 0;

sub merge_data_lists($$$)
{
    my $parser = $_[0];
    my $list = $_[1];
    my $item = $_[2];

    for my $tag (@{$item->{tags}}) {

	push( @{$list->{tags}}, $tag );

        if( exists $list->{values}{$tag} )  {
            $parser->YYData->{ERRMSG} =
                "tag $tag appears more than once";
            # Don't call $parser->YYError() since it clears the Yapp stack.
            # For now, let's call _Error() directly:
            _Error( $parser );
        }

	$list->{values}{$tag} =
	    $item->{values}{$tag};

	$list->{types}{$tag} =
	    $item->{types}{$tag};

	if( exists $item->{precisions}{$tag} ) {
	    $list->{precisions}{$tag} =
		$item->{precisions}{$tag};
	}

    }

    if( exists $item->{loops} ) {
	if( defined $list->{loops} ) {
	    push( @{$list->{loops}}, $item->{loops}[0] );
	} else {
	    $list->{loops} = [ $item->{loops}[0] ];
	}
    }

    if( exists $item->{inloop} ) {
	my $loop_nr = $#{$list->{loops}};
	for my $key (keys %{$item->{inloop}} ) {
	    $list->{inloop}{$key} = $loop_nr;
	}
    }

    if( exists $item->{save_blocks} ) {
	if( defined $list->{save_blocks} ) {
	    push( @{$list->{save_blocks}}, $item->{save_blocks}[0] );
	} else {
	    $list->{save_blocks} = [ $item->{save_blocks}[0] ];
	}
    }

    return $list;
}

%}
# --------------------------------------------------------------

# --------------------------------------------------------------
# begin of body
# --------------------------------------------------------------

%%
cif_file
	:	#empty
                {
			$_[0]->{USER}->{CIFfile} =
                            [ { name => undef, values => {}, tags => [] } ];
		}
	|	data_block_list
		{
			if($CIFParser::debug >= 3)
			{
				showRef($_[1]);
			}
			$_[0]->{USER}->{CIFfile} = $_[1];
		}
	|	data_item
		{
			$_[0]->YYData->{ERRMSG} = "no data block heading (i.e." .
			    " data_somecif) found";
			$_[0]->{USER}->{CIFfile} = [
                            { name => "", values => {}, tags => [] }
                        ];
			$_[0]->YYError();
		}
	|	cif_value                     {
			$_[0]->{USER}->{CIFfile} =
                            [ { name => undef, values => {}, tags => [] } ];
		}
           {
			$_[0]->{USER}->{CIFfile} =
                            [ { name => undef, values => {}, tags => [] } ];
		}

		{
			$_[0]->YYData->{ERRMSG} = "no data block heading (i.e." .
			" data_somecif) found";
			$_[0]->{USER}->{CIFfile} = [
                            { name => "", values => {}, tags => [] }
                        ];
			$_[0]->YYError();
		}
;

data_block_list
	:	data_block_list data_block
		{
			my $val = $_[1];
			push( @{$val}, $_[2] );
			return $val;
		}
	|	data_block
		{
			return [ $_[1] ];
		}
;

data_block
	:	data_block_head data_item_list
		{
			my $name = $_[1];
		        my $val = $_[2];
			$val->{name} = $name;
			return $val;
		}
        |       data_block_head # empty data item list
                {
			return
                            { name => $_[1], values => {}, tags => [] };
		}
;

data_item_list
	:	data_item_list data_item
		{
                        my $list = $_[1];
                        my $item = $_[2];
                        $list = merge_data_lists( $_[0], $list, $item );
			return $list;
		}
	|	data_item
		{
		        my $val = $_[1];
			return $val;
		}
;

data_block_head
	:	DATA_
		{
			$_[1] =~ m/^(data_)(.*)/si;
                        $_[0]->{USER}->{CURRENT_DATABLOCK} = $2;
			return $2;
		}
;

data_item
	:	save_item
		{
			return $_[1];
		}
	|	save_block
		{
			return $_[1];
		}
##	|	error
;

save_item_list
	:	save_item_list save_item
		{
		        my $list = $_[1];
			my $item = $_[2];
                        $list = merge_data_lists( $_[0], $list, $item );
			return $list;
		}
	|	save_item
		{
			my $val = $_[1];
			return $val;
		}
;

save_item
	:	cif_entry
		{
		    # Here we convert to new structure:
		        my $entry = $_[1];
			my $item = {
			    values => {
				$entry->{name} => [ $entry->{value} ]
			    },
			    types => {
				$entry->{name} => [ $entry->{type} ]
			    },
			    tags => [ $entry->{name} ]
			};
			if( exists $entry->{precision} ) {
			    $item->{precisions} = {
				$entry->{name} => [ $entry->{precision} ]
			    }
			}
			return $item;
		}
	|	loop
		{
		        return $_[1];
		}
;

cif_entry
	:	TAG cif_value
		{
			my $val;
			if(defined $_[2]->{precision})
			{
				$val = { name => $_[1],
					kind => 'TAG',
					value => $_[2]->{value},
					type => $_[2]->{type},
					precision => $_[2]->{precision}
				};
			} else {
				$val = { name => $_[1],
					kind => 'TAG',
					value => $_[2]->{value},
					type => $_[2]->{type}
				};
			}
			if($CIFParser::debug >= 1 && $CIFParser::debug <= 2)
			{
				showRef($val);
			}
			return $val;
		}
	|	LOCAL TAG cif_value
		{
			my $val;
			if(defined $_[3]->{precision})
			{
				$val = { name => $_[2],
					kind => 'LOCAL',
					value => $_[3]->{value},
					type => $_[3]->{type},
					precision => $_[3]->{precision}
				};
			} else {
				$val = { name => $_[2],
					kind => 'LOCAL',
					value => $_[3]->{value},
					type => $_[3]->{type}
				};
			}
			if($CIFParser::debug >= 1 && $CIFParser::debug <= 2)
			{
				showRef($val);
			}
			return $val;
		}
;

loop
    :	LOOP_ loop_tags loop_values
		{
		        my $val = {};
		        my $tags = $_[2];
			my @values = @{$_[3]};

			## push( @{$val->{loops}}, $tags );
                        $val->{loops} = [ [ @{$tags} ] ];
                        $val->{tags} = $tags;

		      VALUES:
			while( int( @values ) > 0 ) {
			    for my $tag (@{$tags}) {
				my $value = shift( @values );
				if( defined $value ) {
				    push( @{$val->{values}{$tag}},
					  $value->{value} );
				    push( @{$val->{types}{$tag}},
					  $value->{type} );
				    if( exists $value->{precision} ) {
					push( @{$val->{precisionss}{$tag}},
					      $value->{precision} );
				    }
				    $val->{inloop}{$tag} = 0;
				} else {
				    $_[0]->YYData->{ERRMSG} =
					"wrong number of elements in the"
					. " loop block starting in line "
					. $_[0]->YYData->{VARS}{loop_begin};
				    $_[0]->YYError();
				    last VALUES;
				}
			    }
			}
                        return $val;
		}
;

loop_tags
	:	loop_tags TAG
		{
			my $val = $_[1];
			push( @{$val}, $_[2] );
			return $val;
		}
	|	TAG
		{
			my $val = [ $_[1] ];
			return $val;
		}
;

loop_values
	:	loop_values cif_value
		{
			my $arr = $_[1];
			my $val = $_[2];
                        push( @{$arr}, $val );
                        return $arr;
		}
	|	cif_value
		{
			my $val = $_[1];
			return [ $val ];
		}
;

save_block
	:	SAVE_HEAD save_item_list SAVE_FOOT
		{
                        my $val = {
			    save_blocks => [
				{
				    name => $_[1],
				    %{$_[2]}
				}
			    ]
                        };
                        return $val;
		}
;

cif_value
	:	string
		{	print $_[1]->{type} . "\t->\t"
				. $_[1]->{value} . "\n" if( $CIFParser::debug >= 1 && $CIFParser::debug <= 2) ;
			$_[1];
		}
	|	number
		{	print $_[1]->{type} . "\t\t->\t"
				. $_[1]->{value} . " -- "
				. $_[1]->{precision}
				. "\n" if( $CIFParser::debug >= 1 && $CIFParser::debug <= 2);
			$_[1];
		}
	|	textfield
		{	print "TFIELD\t\t->\t" .
				$_[1]->{value} . "\n"
				if( $CIFParser::debug >= 1 && $CIFParser::debug <= 2);
			$_[1];
		}
;

string
	:	SQSTRING
		{
			$_[1] =~ m/^(')(.*)(')$/si;
			return { value => $2,
				type => 'SQSTRING'};
		}
	|	DQSTRING
		{
			$_[1] =~ m/^(")(.*)(")$/si;
			return { value => $2,
				type => 'DQSTRING'};
		}
	|	UQSTRING	{ { value => $_[1],
			type => 'UQSTRING'} }
	|	TEXT_FIELD	{ { value => $_[1],
			type => 'TEXTFIELD' };
		}
;

number
	:	FLOAT
		{
			if( $_[1] =~ m/^(.*)( \( ([0-9]+) \) )$/six )
			{
				my $value	= $1;
				my $precision	= $3;
				#parsing float value:
				# - $1 - part before decimal dot
				# - $2 - decimal dot
				# - $3 - mantissa (part after d-dot)
				# - $4 - exponent
				$value =~ m/
						([-+]?[0-9]*)?
						(\.)?
						([0-9]+)?
						(?:e([+-]?[0-9]+))?
					/six;
				if( defined $2 )
				{
					if( defined $4 )
					{
						if(defined($3))
						{
							$precision /=
							10**(length($3));
						}
						$precision *= 10**($4);
					} else {
						if(defined($3))
						{
							$precision /=
							10**(length($3));
						}
					}
				} else {
					$precision *= 10**($4);
				}
				{	type => 'FLOAT',
					value => $_[1],
					precision => $precision
				}
			} else {
				{	type => 'FLOAT',
					value => $_[1],
					precision => 'undef'
				}
			}
		}
	|	INT
		{
			if( $_[1] =~ m/^(.*)( \( ([0-9]+) \) )$/sx)
			{
				{	type => 'INT',
					value => $_[1],
					precision => $3
				}
			} else {
				{	type => 'INT',
					value => $_[1],
					precision => 'undef'
				}
			}
		}
;

%%
# --------------------------------------------------------------
# begin of footer
# --------------------------------------------------------------

sub _Error
{
        $_[0]->YYData->{ERRCOUNT}++;
	exists $_[0]->YYData->{ERRMSG}
	and do {
	        print STDERR $0, ": ";
	        print STDERR "file '", $_[0]->YYData->{FILENAME}, "'";
		if( defined $_[0]->{USER}->{CURRENT_DATABLOCK} ) {
		    print STDERR " data_",
		        $_[0]->{USER}->{CURRENT_DATABLOCK};
		}
	        print STDERR ", line ", $_[0]->YYData->{VARS}{lines};
		print STDERR ": ";
		print STDERR $_[0]->YYData->{ERRMSG}, "\n";
		delete $_[0]->YYData->{ERRMSG};
		return;
	};
	print STDERR 
            "$0: file '", $_[0]->YYData->{FILENAME}, "'";
        if( defined $_[0]->{USER}->{CURRENT_DATABLOCK} ) {
            print STDERR " data_",
            $_[0]->{USER}->{CURRENT_DATABLOCK};
        }
        print STDERR 
            ", line ", $_[0]->YYData->{VARS}{lines} . ", pos. ",
            $_[0]->YYData->{VARS}{token_prev_pos} . ": ",
            "syntax error:\n",
            $_[0]->YYData->{VARS}{current_line};
	print STDERR "\n";
        print STDERR " " x $_[0]->YYData->{VARS}{token_prev_pos};
	print STDERR "^\n";
}

sub _Lexer
{
	my($parser) = shift;
	
	#trimming tokenized comments
	if( defined $parser->YYData->{INPUT} &&
		$parser->YYData->{INPUT} =~
			s/^(\s*#.*)$//s )
	{
		advance_token($parser);
	}

	if( !defined $parser->YYData->{INPUT} ||
		$parser->YYData->{INPUT} =~ m/^\s*$/ )
	{
		do
		{
			$parser->YYData->{INPUT} = <$CIFParser::FILEIN>;
			$parser->YYData->{VARS}{lines}++;
			if( $parser->YYData->{VARS}{lines} % 100 == 0 &&
			    defined $parser->{reporter} ) {
			    &{$parser->{reporter}}( $parser->YYData->{VARS}{lines} );
			}
		} until ( !defined $parser->YYData->{INPUT} ||
			$parser->YYData->{INPUT} !~ m/^(\s*(#.*)?)$/s );
		if( defined $parser->YYData->{INPUT} )
		{
			chomp $parser->YYData->{INPUT};
			$parser->YYData->{INPUT}=~s/\r$//g;
			$parser->YYData->{INPUT}=~s/\t/    /g;
			$parser->YYData->{VARS}{current_line} = 
				$parser->YYData->{INPUT};
			$parser->YYData->{VARS}{token_pos} = 0;
		} else {
			return('',undef);
		}
	}

#scalars storing regular expressions, common to several matches
my $ORDINARY_CHAR	=	
	qr/[a-zA-Z0-9!%&\(\)\*\+,-\.\/\:<=>\?@\\\^`{\|}~]/is;
my $SPECIAL_CHAR	=	qr/["#\$'_\[\]]/is;
my $NON_BLANK_CHAR	=	qr/(?:$ORDINARY_CHAR|$SPECIAL_CHAR|;)/is;
my $TEXT_LEAD_CHAR	=	qr/(?:$ORDINARY_CHAR|$SPECIAL_CHAR|\s)/s;
my $ANY_PRINT_CHAR	=	qr/(?:$NON_BLANK_CHAR|\s)/is;
my $INTEGER		=	qr/[-+]?[0-9]+/s;
my $EXPONENT		=	qr/e[-+]?[0-9]+/is;
my $FLOAT11		=	qr/(?: $INTEGER $EXPONENT)/ix;
my $FLOAT21		=	qr/(?: [+-]? [0-9]* \. [0-9]+ $EXPONENT ?)/ix;
my $FLOAT31		=	qr/(?: $INTEGER \. $EXPONENT ?)/ix;
my $FLOAT		=	qr/(?: (?: $FLOAT11 | $FLOAT21 | $FLOAT31))/six;

	#matching white space characters
	if( $parser->YYData->{INPUT} =~ s/(\s*)//s )
	{
		advance_token($parser);
	}
		
	if($CIFParser::debug >= 2 && $CIFParser::debug < 3)
	{
		print ">>> '", $parser->YYData->{INPUT}, "'\n";
	}

	for ($parser->YYData->{INPUT})
	{
		#matching floats:
                if( s/^(?: ($FLOAT (?:\([0-9]+\))?) (\s) )/$2/six
                        || s/^($FLOAT (?:\([0-9]+\))?)$//six )
		{
			advance_token($parser);
			return('FLOAT', $1);
		}
		#matching integers:
                if( s/^($INTEGER (?:\([0-9]+\))?)(\s)/$2/sx
                        || s/^($INTEGER (?:\([0-9]+\))?)$//sx )
		{
			advance_token($parser);
			return('INT', $1);
		}
		#matching double quoted strings
		if( s/^("${ANY_PRINT_CHAR}*?")(\s)/$2/s
			|| s/^("${ANY_PRINT_CHAR}*?")$//s )
		{
			advance_token($parser);
			return('DQSTRING', $1);
		}
		#matching single quoted strings
		if( s/^('${ANY_PRINT_CHAR}*?')(\s)/$2/s
			|| s/^('${ANY_PRINT_CHAR}*?')$//s )
		{
			advance_token($parser);
			return('SQSTRING', $1);
		}
		#matching text field
		if( $parser->YYData->{VARS}{token_pos} == 0 )
		{
			if( s/^;(${ANY_PRINT_CHAR}*)$//s )
			{
				my $eotf = 0;
				my $tfield;	#all textfield
				my $tf_line_begin =
					$parser->YYData->{VARS}{lines};
				$tfield = $1;
				while( 1 )
				{
					my $line = <$CIFParser::FILEIN>;
					if( defined $line )
					{
						chomp $line;
						$line=~s/\r$//g;
						$line=~s/\t/    /g;
						$parser->YYData->{VARS}{current_line} = 
							$line;
						$parser->YYData->{VARS}{lines}++;
						if( $line =~
							s/^;//s )
						{
							if( defined $line )
							{
							$parser->YYData->{INPUT}
								= $line;
							$parser->YYData->{VARS}{token_pos} = 1;
							}
							last;
						} else {
							$tfield .= "\n" . $line;
						}
					} else {
						undef $parser->YYData->{INPUT};
						last;
					}
				}
				if( !defined $parser->YYData->{INPUT} )
				{
					$parser->YYData->{ERRMSG} = <<END_M;
end of file encountered while in text field starting in line $tf_line_begin.
Possible runaway closing semicolon (';')
END_M
					$parser->YYError();
				}
				return('TEXT_FIELD', $tfield);
			}
		}
		#matching [local] attribute
		if( s/^(\[local\])//si )
		{
			advance_token($parser);
			return('LOCAL', $1);
		}
		#matching GLOBAL_ field
		if( s/^(global_.*)$//si )
		{
			advance_token($parser);
			$parser->YYData->{ERRMSG} = "GLOBAL_ symbol detected" .
				" in line " .
				$parser->YYData->{VARS}{lines} .
				", pos. " .
				$parser->YYData->{VARS}{token_prev_pos} .
                                ":\n--\n" .
				$parser->YYData->{VARS}{current_line} .
                                "\n--\n" .
				"it is not acceptable in this version";
			$parser->YYError();
			return('GLOBAL_', $1);
		}
		#matching SAVE_ head
		if( s/^(save_${NON_BLANK_CHAR}+)//si )
		{
			advance_token($parser);
			return('SAVE_HEAD', $1);
		}
		#matching SAVE_ foot
		if( s/^(save_)//si )
		{
			advance_token($parser);
			return('SAVE_FOOT', $1);
		}
		#matching STOP_ field
		if( s/^(stop_.*)$//si )
		{
			advance_token($parser);
			$parser->YYData->{ERRMSG} = "STOP_ symbol detected" .
				" in line " .
				$parser->YYData->{VARS}{lines} .
				", pos. " .
				$parser->YYData->{VARS}{token_prev_pos} .
                                ":\n--\n" .
				$parser->YYData->{VARS}{current_line} .
                                "\n--\n" .
				"it is not acceptable in this version";
			$parser->YYError();
			return('STOP_', $1);
		}
		#matching DATA_ field
		if( s/^(data_${NON_BLANK_CHAR}+)//si )
		{
			advance_token($parser);
			return('DATA_', $1);
		}
		#matching LOOP_ begining
		if( s/^(loop_)//si )
		{
			advance_token($parser);
			$parser->YYData->{VARS}{loop_begin} =
					$parser->YYData->{VARS}{lines};
			return('LOOP_', $1);
		}
		#matching TAG's
		if( s/^(_${NON_BLANK_CHAR}+)//si )
		{
			advance_token($parser);
			return('TAG', $1);
		}
		#matching unquoted strings
		if( $parser->YYData->{VARS}{token_pos} == 0 )
		{ #UQSTRING at first pos. of line
			if( s/^(?: ( ($ORDINARY_CHAR | \[ )
				($NON_BLANK_CHAR)*) )
				//sx)
			{
				advance_token($parser);
				return('UQSTRING', $1);
			}
		} else { #UQSTRING in line
			if( s/^(?: ( ($ORDINARY_CHAR | ; | \[ )
				($NON_BLANK_CHAR)*) )
				//sx )
			{
				advance_token($parser);
				return('UQSTRING', $1);
			}
		}
		#matching any still unmatched symbol:
		if( s/^(.)//m )
		{
			advance_token($parser);
			return($1,$1);
		}
	}
}

sub advance_token
{
	my $parser = shift;
	$parser->YYData->{VARS}{token_prev_pos} =
		$parser->YYData->{VARS}{token_pos};
	$parser->YYData->{VARS}{token_pos} += length($1);
}

sub Run
{
	my($self) = shift;
	my($filename) = shift;
	my($reporter) = shift;

	$self->{reporter} = $reporter;

	$filename = "-" unless $filename;

	$self->{USER}{FILENAME} = $filename;

	$CIFParser::FILEIN = new FileHandle $filename;
	$| = 1;
	if( $CIFParser::debug >= 2 && $CIFParser::debug < 3)
	{
		$self->YYParse( yylex => \&_Lexer,
				yyerror => \&_Error,
				yydebug => 0x05 );
	} else {
		$self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
	}
	if( $self->YYNberr() == 0 )
	{
		if( $CIFParser::debug >= 1 && $CIFParser::debug < 3)
		{
			print "File syntax is CORRECT!\n";
		}
		undef $CIFParser::FILEIN;
	} else {
		if( $CIFParser::debug >= 1 && $CIFParser::debug < 3)
		{
			print "Syntax check failed.\n";
		}
		undef $CIFParser::FILEIN;
	}
	return $self->{USER}->{CIFfile};
}

return 1;
