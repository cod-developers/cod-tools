# --------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
# -------------------------------------------------------------- 
#
# parse.yp
#
# CIF structure is stored in parser's object YYData VARS hash in this way:
# $parser->YYData->{VARS}{data_name}
# where data_name is name of DATA_ section (i.e. DATA_mycif
# $parser->YYData->{VARS}{mycif}).
# This element consists of arrays of data elements.
# $parser->YYData->{VARS}{data_name}->[x]
# where x increases from begining to end of CIF data section.
# We provide four elements for this array, which is hash of elements, or
# hash of arrays, for respectivly tags and loops.
# {form}->0 - for TAG or 1 - for loop.
# {name}->"_name_of_tag" or ["_name_1", "_name2", .., "_nameN"]
# {value}->value_of_tag or {"name1", ["value1", "value2", .., "valueN"],
# "name2", ["value1", "value2", .., "valueN"], .., "nameN" [...]]}
# {type}->type_of_tag_value or {"name1", "type1", "name2", type2", ..,
# "nameN", "typeN"}
# Such structure allows to recreate original file, line-by-line.
# --------------------------------------------------------------
# begin of header
# --------------------------------------------------------------
# copy directly to PERL module:
%{
use warnings;

my $SVNID = '$Id$';
%}
# --------------------------------------------------------------

# --------------------------------------------------------------
# begin of body
# --------------------------------------------------------------

%%
cif_file:	#empty
	|	cif_elements
;

cif_elements:	cif_elements cif_value
	|	cif_value	{ $_[0]->YYData->{VARS}{$_[1]} }
;

cif_value:	string
	|	number
;

string:		SQSTRING
	|	DQSTRING
	|	UQSTRING
;

number:		FLOAT
	|	INT
;

%%
# --------------------------------------------------------------
# begin of footer
# --------------------------------------------------------------

sub _Error
{
	exists $_[0]->YYData->{ERRMSG}
	and do {
		print $_[0]->YYData->{ERRMSG};
		delete $_[0]->YYData->{ERRMSG};
		return;
	};
	print "Analyzed symbols line containing bogus data (num. " . 
		$_[0]->YYData->{VARS}{lines} . " pos. " . 
		$_[0]->YYData->{VARS}{token_prev_pos} . ") was:\n" . 
		$_[0]->YYData->{VARS}{current_line} . "\n";
	print " " x $_[0]->YYData->{VARS}{token_prev_pos};
	print "^\n";
}

sub _Lexer
{
	my($parser) = shift;

	if( !defined $parser->YYData->{INPUT} || 
		$parser->YYData->{INPUT} =~ m/^\s*$/ )
	{
		$parser->YYData->{INPUT} = <STDIN>;
		if( defined $parser->YYData->{INPUT} )
		{
			chomp $parser->YYData->{INPUT};
			$parser->YYData->{INPUT}=~s/\t/    /g;
			$parser->YYData->{VARS}{lines}++;
			$parser->YYData->{VARS}{current_line} = 
				$parser->YYData->{INPUT};
		        $parser->YYData->{VARS}{token_pos} = 0;
		} else {
			return('',undef);
		}
	}

	$parser->YYData->{INPUT}=~s/^(\s*)//;
	advance_token($parser);

#function used for debugging purposes only
#	print ">>> '", $parser->YYData->{INPUT}, "'\n";

#scalars storing regular expressions, common to several matches
my $ORDINARY_CHAR	=
	qr/[a-zA-Z0-9!%&\(\)\*\+,-\.\/\:<=>\?@\\\^`{\|}~]/is;
my $SPECIAL_CHAR	=	qr/(["#\$'_\[\]])/is;
my $NON_BLANK_CHAR	=	qr/(?:$ORDINARY_CHAR|$SPECIAL_CHAR|;)/is;
my $TEXT_LEAD_CHAR	=	
qr/(?:$ORDINARY_CHAR|$SPECIAL_CHAR|\s)/is;
my $ANY_PRINT_CHAR	=	qr/(?:$NON_BLANK_CHAR|\s)/is;
my $WHITE_SPACE		=	qr/\s$((\s$)+(#.*))/im;

	for ($parser->YYData->{INPUT})
	{
		#matching integers:
		if ( s/^([\+-]?[0-9]+)// )
		{
			advance_token($parser);
			return('INT', $1);
		}
		#matching floats:
		if( s/^([0-9]*\.[0-9]+)//s )
		{
			advance_token($parser);
			return('FLOAT', $1);
		}
		#matching double quoted strings
		if( s/(
			#DQ string in line
			("$ANY_PRINT_CHAR*"\s+
			#DQ string at the EOL
			| "$ANY_PRINT_CHAR*"$)
		)//x )
		{
			advance_token($parser);
			return('DQSTRING', $1);
		}
		#matching single quoted strings
		if( s/(
                       #SQ string in line
			('$ANY_PRINT_CHAR*'\s+
                        #SQ string at the EOL
                        | '$ANY_PRINT_CHAR*'$)
		)//x )
		{
			advance_token($parser);
			return('SQSTRING', $1);
		}
		#matching unquoted strings
		if( $parser->YYData->{VARS}{token_pos} == 0 )
		{
			if( s/(?:
			#UQ string in first pos. of line
				(^ ($ORDINARY_CHAR
				$NON_BLANK_CHAR* ) )
			)//x)
			{
				advance_token($parser);
				return('UQSTRING', $1);
			}
		} else {
			if( s/(?:
			#UQ string in line
				(^ ($ORDINARY_CHAR|;)
				$NON_BLANK_CHAR* )
			)//x )
			{
				advance_token($parser);
				return('UQSTRING', $1);
			}
		}
		#matching any still unmatched symbol:
		if( s/^(.)//m )
		{
			advance_token($parser);
			return($1,$1);
		}
	}
}

sub advance_token
{
	my $parser = shift;
	$parser->YYData->{VARS}{token_prev_pos} =
		$parser->YYData->{VARS}{token_pos};
	$parser->YYData->{VARS}{token_pos} += length($1);
}

sub Run
{
	my($self) = shift;
#used for debugging purposes only
	$self->YYParse( yylex => \&_Lexer,
			yyerror => \&_Error,
			yydebug => 0x05 );
#	$self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
	foreach my $temp ($self->YYData->{VARS}{cif_elements_hash})
	{
		print "tokia: $temp \n";
	}
	if( $self->YYNberr() == 0 )
	{
		print "File syntax is CORRECT!\n";
	} else {
		print "Syntax check failed.\n";
	}

}

my($prog) = new parse;
$prog->Run;

