# --------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
# -------------------------------------------------------------- 
#
# parse.yp
#
# Parsed CIF file structure overview is described at the end of this file.
# --------------------------------------------------------------
# begin of header
# --------------------------------------------------------------
# copy directly to PERL module:
%{
use warnings;

my $SVNID = '$Id$';
%}
# --------------------------------------------------------------

# --------------------------------------------------------------
# begin of body
# --------------------------------------------------------------

%%
cif_file:	#empty
	|	cif_elements
;

cif_elements:	cif_elements cif_value
	|	cif_value	{ $_[0]->YYData->{VARS}{$_[1]} }
;

cif_value:	string { print $_[1]->{type} . "\t->\t"
			. $_[1]->{value} . "\n" }
	|	number { print $_[1]->{type} . "\t->\t"
			. $_[1]->{value} . "\n" }
;

string:		SQSTRING	{ { value => $_[1], type => 'SQSTRING'} }
	|	DQSTRING	{ { value => $_[1], type => 'DQSTRING'} }
	|	UQSTRING	{ { value => $_[1], type => 'UQSTRING'} }
;

precision:	'(' INT ')'	{ $_[2] };

number:		FLOAT	{ { value  => $_[1], type => 'FLOAT' } }
	|	FLOAT precision { { value => $_[1], type => 'FLOAT', 
precision => $_[2] } }
	|	INT { { value => $_[1], type => 'INT' } }
;

%%
# --------------------------------------------------------------
# begin of footer
# --------------------------------------------------------------

sub _Error
{
	exists $_[0]->YYData->{ERRMSG}
	and do {
		print $_[0]->YYData->{ERRMSG};
		delete $_[0]->YYData->{ERRMSG};
		return;
	};
	print "Analyzed symbols line containing bogus data (num. " . 
		$_[0]->YYData->{VARS}{lines} . " pos. " . 
		$_[0]->YYData->{VARS}{token_prev_pos} . ") was:\n" . 
		$_[0]->YYData->{VARS}{current_line} . "\n";
	print " " x $_[0]->YYData->{VARS}{token_prev_pos};
	print "^\n";
}

sub _Lexer
{
	my($parser) = shift;

	if( !defined $parser->YYData->{INPUT} ||
		$parser->YYData->{INPUT} =~ m/^\s*$/ )
	{
		do
		{
			$parser->YYData->{INPUT} = <STDIN>;
			$parser->YYData->{VARS}{lines}++;
		} until ( !defined $parser->YYData->{INPUT} ||
			$parser->YYData->{INPUT} !~ m/^\s*$/ );
		if( defined $parser->YYData->{INPUT} )
		{
			chomp $parser->YYData->{INPUT};
			$parser->YYData->{INPUT}=~s/\t/    /g;
			$parser->YYData->{VARS}{lines}++;
			$parser->YYData->{VARS}{current_line} = 
				$parser->YYData->{INPUT};
		        $parser->YYData->{VARS}{token_pos} = 0;
		} else {			
			return('',undef);
		}
	}
		$parser->YYData->{INPUT} =~ s/^(\s*)//;
		advance_token($parser);

#function used for debugging purposes only
#	print ">>> '", $parser->YYData->{INPUT}, "'\n";

#scalars storing regular expressions, common to several matches
my $ORDINARY_CHAR	=	
	qr/[a-zA-Z0-9!%&\(\)\*\+,-\.\/\:<=>\?@\\\^`{\|}~]/is;
my $SPECIAL_CHAR	=	qr/(["#\$'_\[\]])/is;
my $NON_BLANK_CHAR	=	qr/(?:$ORDINARY_CHAR|$SPECIAL_CHAR|;)/is;
my $TEXT_LEAD_CHAR	=	qr/(?:$ORDINARY_CHAR|$SPECIAL_CHAR|\s)/is;
my $ANY_PRINT_CHAR	=	qr/(?:$NON_BLANK_CHAR|\s)/is;
my $WHITE_SPACE		=	qr/\s$((\s$)+(#.*))/im;
my $INTEGER		=	qr/[-+]?[0-9]+/is;
my $EXPONENT		=	qr/(e[-+]?[0-9]+)/is;
my $FLOAT11		=	qr/($INTEGER $EXPONENT)/x;
my $FLOAT21		=	qr/([+-]? [0-9]* \. [0-9]+ $EXPONENT ?)/x;
my $FLOAT31		=	qr/($INTEGER \. $EXPONENT ?)/x;
my $FLOAT		=	qr/(?: $FLOAT11 | $FLOAT21 | 
$FLOAT31)/six;

	for ($parser->YYData->{INPUT})
	{
		#matching floats:
		if( s/^(($FLOAT)(?=\s))//sx || s/^($FLOAT)$//sx )
		{
			advance_token($parser);
			return('FLOAT', $1);
		}
		#matching integers:
		if( s/^($INTEGER)(?=\s)/$2/sx || s/^($INTEGER)$//sx )
		{
			advance_token($parser);
			return('INT', $1);
		}
		#matching double quoted strings
		if( s/(
			#DQ string in line
			("$ANY_PRINT_CHAR*"\s+
			#DQ string at the EOL
			| "$ANY_PRINT_CHAR*"$)
		)//x )
		{
			advance_token($parser);
			return('DQSTRING', $1);
		}
		#matching single quoted strings
		if( s/(
                       #SQ string in line
			('$ANY_PRINT_CHAR*'\s+
                        #SQ string at the EOL
                        | '$ANY_PRINT_CHAR*'$)
		)//x )
		{
			advance_token($parser);
			return('SQSTRING', $1);
		}
		#matching unquoted strings
		if( $parser->YYData->{VARS}{token_pos} == 0 )
		{
			if( s/(?:
			#UQ string in first pos. of line
				(^ ($ORDINARY_CHAR
				$NON_BLANK_CHAR* ) )
			)//x)
			{
				advance_token($parser);
				return('UQSTRING', $1);
			}
		} else {
			if( s/(?:
			#UQ string in line
				(^ ($ORDINARY_CHAR|;)
				$NON_BLANK_CHAR* )
			)//x )
			{
				advance_token($parser);
				return('UQSTRING', $1);
			}
		}
		#matching any still unmatched symbol:
		if( s/^(.)//m )
		{
			advance_token($parser);
			return($1,$1);
		}
	}
}

sub advance_token
{
	my $parser = shift;
	$parser->YYData->{VARS}{token_prev_pos} =
		$parser->YYData->{VARS}{token_pos};
	$parser->YYData->{VARS}{token_pos} += length($1);
}

sub Run
{
	my($self) = shift;
#used for debugging purposes only
#	$self->YYParse( yylex => \&_Lexer,
#			yyerror => \&_Error,
#			yydebug => 0x05 );
	$self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
	if( $self->YYNberr() == 0 )
	{
		print "File syntax is CORRECT!\n";
	} else {
		print "Syntax check failed.\n";
	}

}

my($prog) = new parse;
$prog->Run;

__END__
CIF structure is stored in parser's object YYData VARS hash in this way:
$parser->YYData->{VARS}{[CIF_ARRAY]}

Here CIF_ARRAY is array of elements:
        kind
        [type]
        [name]
        value
        [precision]
*NOTE: square brackets ('[' and ']') denotes optional element.

As far as now, 'kind' is one of:
        DATA_
        SAVE_
        LOOP_
        TAG             - for any tag
        LOOPCOL         - for loop column

'type' is type of value stored:
        FLOAT
        INT
        SQSTRING
        DQSTRING
        UQSTRING
        TEXTFIELD

'name' is TAG's name.

'value' is value for TAG, whose name is 'name'.
It could be a list of values, in case of loop.

'precision' - optional component, which defines precision of numerical
values. It could be a single value, or an array of values - array of the
same size, as array for 'value' field.

All this array is recursive - in a block could reside several sections,
each with different values.

Everything goes to array 'value' in case of recursion.
Example with DATA_ section having a loop_:
$parser->YYDATA->{VARS}{myCIF} =
[
        {
#DATA_compound1
                kind = DATA_,
                name= 'compound1'
                value =
                [
                        {
#_chemical_formula_sum 'C2 H2 Ca O4'
                                kind = 'TAG'
                                name = '_chemical_formula_sum'
                                value = 'C2 H2 Ca O4'
                                type = 'SQSTRING'
                        },
                        {
#loop_
#_atom_site_label,
#_atom_site_fract_x
#Ca1 0.0098(2)
#Ca2 0.0093(2)
                                kind = 'LOOP_'
                                value =
                                [
                                        {
                                                kind = 'LOOPCOL'
                                                name = 
'_atom_site_label'
                                                value =
                                                [
                                                        'Ca1',
                                                        'Ca2'
                                                ]
                                        },
                                        {
                                                kind = 'LOOPCOL'
                                                name = 
'_atom_site_fract_x'
                                                value =
                                                [
                                                        0.0098,
                                                        0.0093
                                                ]
                                                precision =
                                                [
                                                        0.00002,
                                                        0.00002
                                                ]
                                        }
                                ]
                        }
                ]
        }
]


