# --------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
# -------------------------------------------------------------- 
#
# parse.yp
#
# --------------------------------------------------------------
# begin of header
# --------------------------------------------------------------
# copy directly to PERL module:
%{
use warnings;

my $SVNID = '$Id$';
%}
# --------------------------------------------------------------

# --------------------------------------------------------------
# begin of body
# --------------------------------------------------------------

%%
cif_file:	#empty
	|	cif_elements
;

cif_elements:	cif_elements FLOAT
	|	cif_elements STRING
	|	STRING
	|	FLOAT	{ $_[0]->YYData->{VARS}{$_[1]} }
;

%%
# --------------------------------------------------------------
# begin of footer
# --------------------------------------------------------------

sub _Error
{
	exists $_[0]->YYData->{ERRMSG}
	and do {
		print $_[0]->YYData->{ERRMSG};
		delete $_[0]->YYData->{ERRMSG};
		return;
	};
	print "Analyzed symbols line containing bogus data (num. " . 
		$_[0]->YYData->{VARS}{lines} . " pos. " . 
		$_[0]->YYData->{VARS}{token_prev_pos} . ") was:\n" . 
		$_[0]->YYData->{VARS}{current_line} . "\n";
	print " " x $_[0]->YYData->{VARS}{token_prev_pos};
	print "^\n";
}

sub _Lexer
{
	my($parser) = shift;

	if( !defined $parser->YYData->{INPUT} || 
		$parser->YYData->{INPUT} =~ m/^\s*$/ )
	{
		$parser->YYData->{INPUT} = <STDIN>;
		if( defined $parser->YYData->{INPUT} )
		{
			chomp $parser->YYData->{INPUT};
			$parser->YYData->{INPUT}=~s/\t/    /g;
			$parser->YYData->{VARS}{lines}++;
			$parser->YYData->{VARS}{current_line} = 
				$parser->YYData->{INPUT};
		        $parser->YYData->{VARS}{token_pos} = 0;
		} else {
			return('',undef);
		}
	}

	$parser->YYData->{INPUT}=~s/^(\s*)//;
	advance_token($parser);

#function used for debugging purposes only
#	print ">>> '", $parser->YYData->{INPUT}, "'\n";

#scalars storing regular expressions, common to several matches
my $ORDINARY_CHAR	=
	qr/[a-zA-Z0-9!%&\(\)\*\+,-\.\/\:<=>\?@\\\^`{\|}~]/is;
my $SPECIAL_CHAR	=	qr/(["#\$'_\[\]])/is;
my $NON_BLANK_CHAR	=	qr/(?:$ORDINARY_CHAR|$SPECIAL_CHAR|;)/is;
my $TEXT_LEAD_CHAR	=	
qr/(?:$ORDINARY_CHAR|$SPECIAL_CHAR|\s)/is;
my $ANY_PRINT_CHAR	=	qr/(?:$NON_BLANK_CHAR|\s)/is;
my $WHITE_SPACE		=	qr/\s$((\s$)+(#.*))/im;

	for ($parser->YYData->{INPUT})
	{
		#matching floats:
		if( s/^([0-9]*\.[0-9]+)//s )
		{
			advance_token($parser);
			return('FLOAT', $1);
		}
		#matching double quoted strings
		if( s/(
			#DQ string in line
			("$ANY_PRINT_CHAR*"\s+
			#DQ string at the EOL
			| "$ANY_PRINT_CHAR*"$)
                       #SQ string in line
			| ('$ANY_PRINT_CHAR*'\s+
                        #SQ string at the EOL
                        | '$ANY_PRINT_CHAR*'$)
		)//x )
		{
			advance_token($parser);
			return('STRING', $1);
		}
		#matching any still unmatched symbol:
		if( s/^(.)//m )
		{
			advance_token($parser);
			return($1,$1);
		}
	}
}

sub advance_token
{
	my $parser = shift;
	$parser->YYData->{VARS}{token_prev_pos} =
		$parser->YYData->{VARS}{token_pos};
	$parser->YYData->{VARS}{token_pos} += length($1);
}

sub Run
{
	my($self) = shift;
#used for debugging purposes only
#	$self->YYParse( yylex => \&_Lexer,
#			yyerror => \&_Error,
#			yydebug => 0x05 );
	$self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
	if( $self->YYNberr() == 0 )
	{
		print "File syntax is CORRECT!\n";
	} else {
		print "Syntax check failed.\n";
	}

}

my($prog) = new parse;
$prog->Run;

