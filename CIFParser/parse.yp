# --------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
# -------------------------------------------------------------- 
#
# parse.yp
#
# --------------------------------------------------------------
# begin of header
# --------------------------------------------------------------
# copy directly to PERL module:
%{
use warnings;

my $SVNID = '$Id$';
%}
# --------------------------------------------------------------

# --------------------------------------------------------------
# begin of body
# --------------------------------------------------------------

%%
cif_file:	#empty
	|	cif_elements
;

cif_elements:	cif_elements FLOAT
	|	cif_elements STRING
	|	STRING
	|	FLOAT	{ $_[0]->YYData->{VARS}{$_[1]} }
;

%%
# --------------------------------------------------------------
# begin of footer
# --------------------------------------------------------------

sub _Error
{
	exists $_[0]->YYData->{ERRMSG}
	and do {
		print $_[0]->YYData->{ERRMSG};
		delete $_[0]->YYData->{ERRMSG};
		return;
	};
	print "Analyzed symbols line containing bogus data (num. " . 
		$_[0]->YYData->{VARS}{'lines'} . " pos. " . 
		$_[0]->YYData->{VARS}{'token_prev_pos'} . ") was:\n" . 
		$_[0]->YYData->{VARS}{'current_line'} . "\n";
	for (my $cPos = 0; $cPos < 
		$_[0]->YYData->{VARS}{'token_prev_pos'}; $cPos++)
		 { print " "; }
	print "^\n";
}

sub _Lexer
{
	my($parser) = shift;

	if( !defined $parser->YYData->{INPUT} || 
		$parser->YYData->{INPUT} =~ m/^\s*$/ )
	{
		$parser->YYData->{INPUT} = <STDIN>;
		if( defined $parser->YYData->{INPUT} )
		{
			chomp $parser->YYData->{INPUT};
			$parser->YYData->{INPUT}=~s/\t/    /g;
			$parser->YYData->{VARS}{'lines'}++;
			$parser->YYData->{VARS}{'current_line'} = 
				$parser->YYData->{INPUT};
		        $parser->YYData->{VARS}{'token_pos'} = 0;
		} else {
			return('',undef);
		}
	}

	$parser->YYData->{INPUT}=~s/^(\s*)//;
	advance_token($parser);

#function used for debugging purposes only
#	print ">>> '", $parser->YYData->{INPUT}, "'\n";

#scalars storing regular expressions, common to several matches
my($EOLMID)		=
	qr/\n|\r\n|\r/is;
my($ORDINARY_CHAR)	=
	qr/a-zA-Z0-9!%&\(\)\*\+,-\.\/\:<=>\?@\\\^`{\|}~/is;
my($NON_BLANK_CHAR)	=
	qr/a-zA-Z0-9!%&\(\)\*\+,-\.\/\:<=>\?@\\\^`{\|}~"#\$'_;\[\]/is;
my($TEXT_LEAD_CHAR)	=
	qr/a-zA-Z0-9!%&\(\)\*\+,-\.\/\:<=>\?@\\\^`{\|}~"#\$'_\[\]\s/is;
my($ANY_PRINT_CHAR)	=
	qr/a-zA-Z0-9!%&\(\)\*\+,-\.\/\:<=>\?@\\\^`{\|}~"#\$'_;\[\]\s/is;
my($WHITE_SPACE)	=
	qr/\s{EOLMID}((\s{EOLMID})+(#.*))/is;

	for ($parser->YYData->{INPUT})
	{
		#matching floats:
		if( s/^([0-9]*\.[0-9]+)//s )
		{
			advance_token($parser);
			return('FLOAT', $1);
		}
		#matching strings
		if( s/(
			("[${ANY_PRINT_CHAR}]*"\s+ #DQ string in line
			| "[${ANY_PRINT_CHAR}]*"$) #DQ string at the EOL
		)//x )
		{
			advance_token($parser);
			return('STRING', $1);
		}
		#matching any still unmatched symbol:
		if( s/^(.)//m )
		{
			advance_token($parser);
			return($1,$1);
		}
	}
}

sub advance_token
{
	my $parser = shift;
	$parser->YYData->{VARS}{'token_prev_pos'} =
		$parser->YYData->{VARS}{'token_pos'};
	$parser->YYData->{VARS}{'token_pos'} += length($1);
}

sub Run
{
	my($self) = shift;
#used for debugging purposes only
#	$self->YYParse( yylex => \&_Lexer,
#			yyerror => \&_Error,
#			yydebug => 0x05 );
	$self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
	if( $self->YYNberr() == 0 )
	{
		print "File syntax is CORRECT!\n";
	} else {
		print "Syntax check failed.\n";
	}

}

my($prog) = new parse;
$prog->Run;

