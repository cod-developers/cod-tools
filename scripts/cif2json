#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Revision$
#$URL$
#$Date$
#$Id$
#------------------------------------------------------------------------------
#*
#  Parse CIF file and print out the structure generated by CIF parser
#**

use strict;
use COD::CIFParser::CIFParser;
use COD::CIF2JSON;
use COD::UserMessage;
use COD::SOptions;
use COD::SUsage;

my $use_parser = 'c';
my %options;
@ARGV = getOptions(

#** USAGE:
#**     $0 [options] input.cif [input2.cif ...]
#** 
#** OPTIONS:
#** --use-c-parser
#**    Use Perl & C parser for CIF parsing (default).
#**
#** --use-perl-parser
#**    Use Perl parser for CIF parsing.
#**
#** --use-json-parser
#**    Use the JSON parser (input is in JSON format).
#**
#** --help,--usage     print short usage message (this message) and exit

    "--use-perl-parser" => sub{ $use_parser = 'perl' },
    "--use-c-parser"    => sub{ $use_parser = 'c' },
    "--use-json-parser" => sub{ $use_parser = 'json' },

    "--do-not-unprefix-text" => sub{ $options{do_not_unprefix_text} = 1 },
    "--do-not-unfold-text"   => sub{ $options{do_not_unfold_text} = 1 },
    "--fix-errors"           => sub{ $options{fix_errors} = 1 },
    "--fix-duplicate-tags-with-same-values"  =>
        sub{ $options{fix_duplicate_tags_with_same_values} = 1 },
    "--fix-duplicate-tags-with-empty-values" =>
        sub{ $options{fix_duplicate_tags_with_empty_values} = 1 },
    "--fix-data-header"     => sub{ $options{fix_data_header} = 1 },
    "--fix-datablock-names" => sub{ $options{fix_datablock_names} = 1 },
    "--fix-string-quotes"   => sub{ $options{fix_string_quotes} = 1 },
    "--fix-missing-closing-double-quote" =>
        sub{ $options{fix_missing_closing_double_quote} = 1 },
    "--fix-missing-closing-single-quote" =>
        sub{ $options{fix_missing_closing_single_quote} = 1 },
    "--fix-ctrl-z"  => sub{ $options{fix_ctrl_z} = 1 },
    "--allow-uqstring-brackets" => sub{ $options{allow_uqstring_brackets} = 1 },

    "--help,--usage"  => sub { usage; exit },
);

@ARGV = ( "-" ) unless @ARGV;

for my $filename (@ARGV) {

    my( $data, $error_count );
    if( $use_parser eq 'perl' ) {
        my $parser = new COD::CIFParser::CIFParser;
        $data = $parser->Run( $filename, \%options );
        if( defined $parser->YYData->{ERRCOUNT} ) {
            $error_count = $parser->YYData->{ERRCOUNT};
        } else {
            $error_count = 0;
        }
    } elsif( $use_parser eq 'c' ) {
        require COD::CCIFParser::CCIFParser;
        ( $data, $error_count ) =
            COD::CCIFParser::CCIFParser::parse( $filename, \%options );
    } elsif( $use_parser eq "json" ) {
        open( my $inp, $filename );
        my $json = join( "\n", <$inp> );
        close( $inp );
        $data = json2cif( $json );
    } else {
        error( $0, $filename, undef, "unknown parser '$use_parser'" );
        die;
    }

    if( defined $error_count && $error_count > 0 ) {
        error( $0, $filename, undef,
               "$error_count error(s) encountered while parsing file '$filename'" );
        next;
    }

    print cif2json( $data );
}
