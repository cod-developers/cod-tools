#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Parse a CIF file, reformat author names in AMCSD convention into
#  COD format.
#**

use strict;
use warnings;
use COD::CIF::Parser qw( parse_cif );
use COD::CIF::Tags::CanonicalNames;
use COD::CIF::Tags::DictTags;
use COD::CIF::Tags::COD;
use COD::CIF::Tags::Print;
use COD::SOptions;
use COD::SUsage qw( usage options );
use COD::UserMessage qw( error );

my $use_parser = 'c';
my $keep_tag_order = 0;

#* USAGE:
#*     $0 --options input1.cif input*.cif
#*
#* OPTIONS:
#*   --keep-tag-order
#*                      Keep the original tag order in CIF file (default).
#*   --sort-tags
#*                      Reorder tags in CIF file according to COD.
#*
#*   --use-perl-parser
#*                      Use Perl parser to parse CIF files.
#*   --use-c-parser
#*                      Use C parser to parse CIF files (default).
#*
#*   --help, --usage
#*                      Print a short usage message (this message) and exit.
#**
@ARGV = getOptions(
    "--keep-tag-order"  => sub { $keep_tag_order = 1; },
    "--sort-tags"       => sub { $keep_tag_order = 0; },
    "--use-perl-parser" => sub { $use_parser = "perl" },
    "--use-c-parser"    => sub { $use_parser = "c" },
    "--options"         => sub { options; exit },
    "--help,--usage"    => sub { usage; exit }
);

my @dictionary_tags = ( @COD::CIF::Tags::DictTags::tag_list,
                        @COD::CIF::Tags::COD::tag_list );
my %dictionary_tags = map { $_, $_ } @dictionary_tags;

@ARGV = ("-") unless @ARGV;

for my $filename (@ARGV) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );

    if ( $err_count > 0 ) {
        print STDERR $_ foreach ( @$messages );
        error( $0, $filename, undef, "$err_count error(s) "
             . "encountered while parsing the file", undef );
        next;
    }
    print STDERR $_ foreach ( @$messages );

    canonicalize_all_names( $data );

    for my $dataset (@$data) {

        my $values = $dataset->{values};

        if( exists $values->{_publ_author_name} ) {
            for my $i (0..$#{$values->{_publ_author_name}}) {
                my $author = $values->{_publ_author_name}[$i];
                if( $author =~
                    /^
                     \s*((?:[A-Z][a-z]+)?[A-Z][a-z\']+)  # Surname
                     \s+((?:[A-Z](?:\s+|-))*[A-Z])\s*$   # Initials
                    /x ) {
                    my $surname = $1;
                    my $initials = $2;
                    $initials =~ s/([A-Z])/$1./g;
                    $values->{_publ_author_name}[$i] =
                        "$surname, $initials";
                }
                if( $author =~
                    /^
                     \s*((?:[A-Za-z][a-z]*\s+)*[A-Za-z]?[a-z]+)  # 'von' prefix
                     \s+((?:[A-Z][a-z]+)?[A-Z][a-z\']+) # Surname
                     \s+((?:[A-Z](?:\s+|-))*[A-Z])\s*$  # Initials
                    /x ) {
                    my $von_prefix = $1;
                    my $surname = $2;
                    my $initials = $3;
                    $initials =~ s/([A-Z])/$1./g;
                    $values->{_publ_author_name}[$i] =
                        "$von_prefix $surname, $initials";
                }
            }
        }

        print_cif( $dataset, {
            exclude_misspelled_tags => 0,
            preserve_loop_order => 1,
            fold_long_fields => 0,
            dictionary_tags => \%dictionary_tags,
            dictionary_tag_list => \@dictionary_tags,
            keep_tag_order => $keep_tag_order,
        } );
    }
}
