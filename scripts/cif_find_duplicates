#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Find COD numbers for the .cif files in given directories of file lists.
#**

use strict;
use warnings;
use File::Basename;
use COD::CIF::Parser::Yapp;
use COD::Formulae::Parser::AdHoc;
use COD::CIF::Data::CellContents qw(cif_cell_contents);
use COD::ErrorHandler qw(process_warnings process_errors);
use COD::CIF::Data::CODNumbers qw(cif_fill_data entries_are_the_same);
use COD::SOptions;
use COD::SUsage;

# default options
my %options = (
    'max_cell_length_diff' => 0.5, # Angstroems
    'max_cell_angle_diff'  => 1.2, # degrees
    'check_bibliography'   => 1,
    'check_sample_history' => 0,
    'ignore_sigma'         => 0
);

my $die_on_errors   = 1;
my $die_on_warnings = 0;
my $die_on_notes    = 0;

#*USAGE:
#*     cif_find_duplicates [options] my-cif-dir1/ my-cif-dir2/files*.cif COD-cif-dir/
#*
#*OPTIONS:
#* -c, --always-continue
#*                     Continue processing and return successful return status
#*                     even if errors are diagnosed.
#* -c-, --always-die
#*                     Stop and return error status if errors are diagnosed.
#*
#* --max-cell-length-difference 0.5
#*                     Maximum difference of unit cell lengths allowed for
#*                     entries regarded as the same, in Angstroems 
#*                     (default 0.5).
#*
#* --max-cell-angle-difference 1.2
#*                     Maximum difference of unit cell angles allowed for
#*                     entries regarded as the same, in Angstroems
#*                     (default 1.2).
#*
#* --check-bibliography
#*                     Only CIFs that have different bibliography data are
#*                     declared different if all other parameters match.
#*                     CIFs with missing bibliographies are assumed to have
#*                     matching bibliographies (default).
#*
#* --dont-check-bibliography, --no-check-bibliography
#*                     Ignore bibliographic data of all CIFs; thus even files
#*                     with different bibliographies will be regared the same
#*                     if their cells, chemical formulae and measurement
#*                     conditions match.
#*
#* --ignore-sigma, --dont-use-sigma, --no-use-sigma
#*                     Ignore standard uncertainties (sigmas) when comparing
#*                     unit cell constants.
#*
#* --dont-ignore-sigma, --no-ignore-sigma, --use-sigma
#*                     Use standard deviations (sigmas) when comparing unit
#*                     cell constants (default).
#*
#* --check-sample-history
#*                     Only CIFs that have different sample history data
#*                     (as recorded in the _exptl_crystal_thermal_history
#*                     and _exptl_crystal_pressure_history tags) are declared
#*                     different if all other parameters match.
#*
#* --dont-check-sample-history,
#* --no-check-sample-history,
#* --disregard-sample-history
#*                     Ignore sample history of all CIFs; thus even files
#*                     with different sample histories will be regared the
#*                     same if their cells, chemical formulae and measurement
#*                     conditions match (default).
#*
#* --continue-on-errors
#*                     Do not terminate script if errors are raised.
#* --die-on-errors, --dont-continue-on-errors,
#* --do-not-continue-on-errors, --no-continue-on-errors
#*                     Terminate script immediately if errors are raised (default).
#* --continue-on-warnings
#*                     Do not terminate script if warnings are raised (default).
#* --die-on-warnings
#*                     Terminate script immediately if warnings are raised.
#* --continue-on-notes
#*                     Do not terminate script if notes are raised (default).
#* --die-on-notes
#*                     Terminate script immediately if notes are raised.
#*
#* --help,--usage  print a short usage message (this message) and exit.
#**

@ARGV = getOptions(
    "--max-cell-length-difference" => \$options{max_cell_length_diff},
    "--max-cell-angle-difference"  => \$options{max_cell_angle_diff},

    "--check-bibliography"      => sub { $options{check_bibliography} = 1 },
    "--dont-check-bibliography" => sub { $options{check_bibliography} = 0 },
    "--no-check-bibliography"   => sub { $options{check_bibliography} = 0 },

    "--check-sample-history"      => sub { $options{check_sample_history} = 1 },
    "--dont-check-sample-history" => sub { $options{check_sample_history} = 0 },
    "--no-check-sample-history"   => sub { $options{check_sample_history} = 0 },
    "--disregard-sample-history"  => sub { $options{check_sample_history} = 0 },

    "--ignore-sigma"        => sub{ $options{ignore_sigma} = 1 },
    "--dont-ignore-sigma"   => sub{ $options{ignore_sigma} = 0 },
    "--no-ignore-sigma"     => sub{ $options{ignore_sigma} = 0 },

    "--use-sigma"       => sub{ $options{ignore_sigma} = 0 },
    "--dont-use-sigma"  => sub{ $options{ignore_sigma} = 1 },
    "--no-use-sigma"    => sub{ $options{ignore_sigma} = 1 },

    "-c,--always-continue"              => sub { $die_on_errors   = 0;
                                                 $die_on_warnings = 0;
                                                 $die_on_notes    = 0 },
    "-c-,--always-die"                  => sub { $die_on_errors   = 1;
                                                 $die_on_warnings = 1;
                                                 $die_on_notes    = 1 },

    "--continue-on-errors"          => sub { $die_on_errors = 0 },
    "--dont-continue-on-errors"     => sub { $die_on_errors = 1 },
    "--die-on-errors"               => sub { $die_on_errors = 1 },
    "--do-not-continue-on-errors"   => sub { $die_on_errors = 1 },
    "--no-continue-on-errors"       => sub { $die_on_errors = 1 },

    "--continue-on-warnings" => sub { $die_on_warnings = 0 },
    "--die-on-warnings"      => sub { $die_on_warnings = 1 },

    "--continue-on-notes"    => sub { $die_on_notes = 0 },
    "--die-on-notes"         => sub { $die_on_notes = 1 },

    "--help,--usage" => sub { usage; exit },
);

my %has_numeric_value = (
    "_journal_year"   => 1,
    "_journal_volume" => 1,
    "_journal_issue"  => 1,
);

my %skip_tag = (
    "_journal_name_full" => 0,
);

my %COD = ();

if( @ARGV < 2 ) {
    print STDERR "$0: please supply two directory names on the command line:\n";
    print STDERR "first directory with the analysed CIF files,\n";
    print STDERR "and the second with the COD CIF files.\n";
    exit -1;
}

my $COD_cif_dir = pop( @ARGV );
my @COD_cif_files = `find $COD_cif_dir -name "*.cif" -o -name "*.CIF" | sort`;

do {
    print int(@COD_cif_files), "\n";
    print "@COD_cif_files";
} if 0;

for my $filename (@COD_cif_files) {

    chomp $filename;

    my @data;

    eval {
        @data = load_cif_file( $filename );
    };
    next if $@;

    if( !@data || !defined $data[0] || !defined $data[0]->{name} ) {
        warn( "file '$filename' seems to be empty" );
    }

    my %structures = ();
    my $index = 0;

    foreach my $dataset ( @data ) {

        my $dataname = 'data_' . $dataset->{name} if defined $dataset->{name};

        local $SIG{__WARN__} = sub { process_warnings( {
                                       'message'       => @_,
                                       'program'       => $0,
                                       'filename'      => $filename,
                                       'add_pos'       => $dataname
                                     }, {
                                       'WARNING' => $die_on_warnings,
                                       'NOTE'    => $die_on_notes
                                     } ) };

        eval {
            my $structure = cif_fill_data( $dataset, $filename, $index );
            if ( defined $structure ) {
                $structures{$structure->{id}} = $structure;
                $index++;
            }
        };
        if ( $@ ) {
            process_errors( {
              'message'  => $@,
              'program'  => $0,
              'filename' => $filename,
              'add_pos'  => $dataname
            }, $die_on_errors );
        };
    };

    my $basename = File::Basename::basename( $filename );
    for my $id (keys %structures) {
        my $formula = $structures{$id}{chemical_formula_sum};

        $formula = '?' unless defined $formula;

        push( @{$COD{$formula}}, $structures{$id} );

        if( exists $structures{$id}{cell_contents} &&
            $structures{$id}{cell_contents} ne $formula ) {
            my $cell_contents = $structures{$id}{cell_contents};
            push( @{$COD{$cell_contents}}, $structures{$id} );
        }
    }

}

do {
    use COD::Serialise;
    serialiseRef( \%COD );
} if 0;

#------------------------------------------------------------------------------

my @cif_files = `find @ARGV -name "*.cif" -o -name "*.CIF" | sort`;

for my $filename (@cif_files) {

    chomp $filename;
    my @data;

    eval {
        @data = load_cif_file( $filename );
    };
    next if $@;

    if( !@data || !defined $data[0] || !defined $data[0]->{name} ) {
        warn( "file '$filename' seems to be empty" );
    }

    my %structures = ();
    my $index = 0;

    foreach my $dataset ( @data ) {

        my $dataname = 'data_' . $dataset->{name} if defined $dataset->{name};

        local $SIG{__WARN__} = sub { process_warnings( {
                                       'message'  => @_,
                                       'program'  => $0,
                                       'filename' => $filename,
                                       'add_pos'  => $dataname
                                     }, {
                                       'WARNING' => $die_on_warnings,
                                       'NOTE'    => $die_on_notes
                                     } ) };

        eval {
            my $structure = cif_fill_data( $dataset, $filename, $index );
            if ( defined $structure ) {
                $structures{$structure->{id}} = $structure;
                $index++;
            }
        };
        if ( $@ ) {
            process_errors( {
              'message'  => $@,
              'program'  => $0,
              'filename' => $filename,
              'add_pos'  => $dataname
            }, $die_on_errors );
        };
    };

    for my $id (keys %structures) {
        my $formula = $structures{$id}{chemical_formula_sum};
        my $cell_contents = $structures{$id}{cell_contents};

        $formula = '?' unless defined $formula || defined $cell_contents;

        my $final_formula = $formula;
        $final_formula =~ s/\s/_/g;

        my %structures_found = ();

        if( defined $formula && defined $COD{$formula} ) {
            for my $COD_entry (@{$COD{$formula}}) {
                if( entries_are_the_same( $structures{$id},
                                          $COD_entry,
                                          \%options )) {
                    my $COD_key = $COD_entry->{filename};
                    $structures_found{$COD_key} = $COD_entry;
                }
            }
        }
        if( defined $cell_contents && defined $COD{$cell_contents} &&
            $formula ne $cell_contents ) {
            ## print ">>> formula: '$formula', contents: '$cell_contents'\n";
            for my $COD_entry (@{$COD{$cell_contents}}) {
                if( entries_are_the_same( $structures{$id},
                                          $COD_entry,
                                          \%options )) {
                    my $COD_key = $COD_entry->{filename};
                    if( !exists $structures_found{$COD_key} ) {
                        $structures_found{$COD_key} = $COD_entry;
                    }
                }
            }
        }

        my $n = keys %structures_found;

        if( $n > 0 ) {
            for my $key (sort keys %structures_found) {
                my $COD_entry = $structures_found{$key};
                printf
                    "%-35s %15s %3d %s\n",
                    $final_formula, 
                    $COD_entry->{filename}, $n, $filename;
            }
        } else {
            printf "%-35s %15s %3d %s\n", $final_formula, "?", 0, $filename;
        }
    }
}

#------------------------------------------------------------------------------

sub load_cif_file
{
    my ( $file ) = @_;

    my $parser = new COD::CIF::Parser::Yapp;
    my @data = @{$parser->Run($file, {no_print => 1})};

    print STDERR $_ foreach @{$parser->YYData->{ERROR_MESSAGES}};

    if( defined $parser->YYData->{ERRCOUNT} && $parser->YYData->{ERRCOUNT} > 0 ) {
        print STDERR "$0: ", $parser->YYData->{ERRCOUNT},
        " error(s) encountered while parsing file '${file}'\n";
        die;
    }

    return @data;
}
