#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Overlay atoms from each pair of CIFs given on the command line.
#**

use strict;
use warnings;
use COD::AtomProperties;
use COD::CIF::Parser::Yapp;
use COD::CIF::Data qw( get_cell );
use COD::CIF::Data::AtomList qw( atom_array_from_cif );
use COD::Spacegroups::Symop::Algebra qw( symop_apply symop_mul
                                         symop_invert symop_det );
use COD::Overlays::Kabsch qw( overlay_atoms );
use COD::Fractional;
use COD::ShowStruct;
use COD::SOptions;
use COD::SUsage;

#* USAGE:
#*     $0 input1.cif input1_alt.cif
#*
#* OPTIONS:
#*
#* --help, --usage     Print a short usage message (this message) and exit.
#**
@ARGV = getOptions(
    "--help,--usage"    => sub { usage; exit }
);

my $exclude_zero_occupancies = 0;
my $cif_atom_list_options = {
    allow_unknown_chemical_types => 1,
    homogenize_transform_matrices => 1,
    exclude_zero_occupancies => $exclude_zero_occupancies,
};

while( @ARGV > 0 ) {

    my $filename1 = shift(@ARGV);
    my $filename2 = shift(@ARGV);

    if( !defined $filename2 ) {
        die "Even number of files required on the command line"
    }

    my $parser;

    $parser = new COD::CIF::Parser::Yapp;
    my $data1 = $parser->Run($filename1);

    $parser = new COD::CIF::Parser::Yapp;
    my $data2 = $parser->Run($filename2);

    if( @$data1 < @$data2 ) {
        warn "file '$filename2' has more data blocks than '$filename1', " .
            "some will stay unused";
    }

    for my $dataset1 (@$data1) {
        my $dataset2 = shift( @$data2 );
        if( !defined $dataset2 ) {
            warn "file '$filename1' has more data blocks than '$filename2'";
            last;
        }
        print "FILE1\t", $filename1, "\n";
        print "FILE2\t", $filename2, "\n";
        print "DBLOCK1\t", $dataset1->{name}, "\n";
        print "DBLOCK2\t", $dataset2->{name}, "\n";
        my $atoms1 = atom_array_from_cif( $dataset1,
                                          \%COD::AtomProperties::atoms,
                                          $cif_atom_list_options );
        my $atoms2 = atom_array_from_cif( $dataset2,
                                          \%COD::AtomProperties::atoms,
                                          $cif_atom_list_options );

        print "ATMCNTS\t", int(@$atoms1), " ", int(@$atoms2), "\n";

        my $overlay_symop = overlay_atoms( $atoms1, $atoms2 );
        printf "RDET\t%8.6f\n", symop_det( $overlay_symop );

        ## use COD::Serialise;
        ## serialiseRef( $atoms1->[0]{f2o} );

        my $fract_overlay = symop_mul( symop_invert($atoms1->[0]{f2o}),
                                       symop_mul( $overlay_symop,
                                                  $atoms1->[0]{f2o} ));

        do {
            local $, = "\t";
            local $\ = "\n";
            printf "SYMOP1\t%9.6f\t%9.6f\t%9.6f\t%9.6f\n", @{$fract_overlay->[0]};
            printf "SYMOP2\t%9.6f\t%9.6f\t%9.6f\t%9.6f\n", @{$fract_overlay->[1]};
            printf "SYMOP3\t%9.6f\t%9.6f\t%9.6f\t%9.6f\n", @{$fract_overlay->[2]};
            print "SYMOP4", @{$fract_overlay->[3]};
        };

        my $atoms1_on_atoms2 = symop_apply_to_atoms( $atoms1, $fract_overlay );

        ## use COD::Serialise;
        ## serialiseRef( $atoms1_on_atoms2 );

        printf "RMS\t%8.6f\n", atom_rms( $atoms2, $atoms1_on_atoms2 );
    }
}

#===============================================================#
# Apply symmetry operator to all atoms in the list
#
# Accepts
#     $atoms -- a reference to an atom array
#     $symop -- a symmetry operator to be applied to all atoms
# Returns
#     a reference to an array with copies of atoms transformed 
#     by $symop.

sub symop_apply_to_atoms
{
    my ($atoms, $symop) = @_;

    my @applied;

    for my $atom (@{$atoms}) {
        my %new_atom = %$atom;

        $new_atom{coordinates_fract} =
            symop_apply( $symop, $atom->{coordinates_fract} );

        $new_atom{coordinates_ortho} =
            symop_apply( $atom->{f2o}, $new_atom{coordinates_fract} );

        push( @applied, \%new_atom );
    }

    return \@applied;
}

#===============================================================#
# Apply symmetry operator to all atoms in the list
#
# Accepts
#     $atoms1, $atoms2 -- references to two atom arrays
# Returns
#     an RMS deviation between atoms
sub atom_rms
{
    my ( $atoms1, $atoms2 ) = @_;

    my $N = @$atoms1 < @$atoms2 ? @$atoms1 : @$atoms2;
    my $sum = 0.0;

    return 0.0 if $N == 0;

    for( my $i = 0; $i < $N; $i++ ) {
        my $a1 = $atoms1->[$i];
        my $a2 = $atoms2->[$i];

        $sum +=
            ($a1->{coordinates_ortho}[0]-$a2->{coordinates_ortho}[0])**2 +
            ($a1->{coordinates_ortho}[1]-$a2->{coordinates_ortho}[1])**2 +
            ($a1->{coordinates_ortho}[2]-$a2->{coordinates_ortho}[2])**2;
    }
    return sqrt($sum/$N);
}
