#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Revision$
#$URL$
#$Date$
#$Id$
#------------------------------------------------------------------------------
#*
#  Parse CIF file and print out the structure generated by CIF parser
#**

use strict;
use COD::CIFParser::CIFParser;
use COD::CIF2JSON;
use COD::CIFData::CIFDiff;
use COD::SOptions;
use COD::SUsage;

my $use_parser = 'c';
my $input_json  = 0;
my $output_json = 0;
my %options;
@ARGV = getOptions(

#** USAGE:
#**     $0 [options] input.cif [input2.cif ...]
#** 
#** OPTIONS:
#** --input-cif,
#** --input-json
#**    Specify the format of input file(s). Default CIF.
#**
#** --output-cif,
#** --output-json
#**    Specify the format for output. Default CIF.
#**
#** --cif
#**    Set both input and output formats to CIF.
#**
#** --json
#**    Set both input and output formats to JSON.
#**
#** --use-perl-parser
#**    Use Perl parser for CIF parsing.
#**
#** --use-c-parser
#**    Use Perl & C parser for CIF parsing.
#**
#** --help,--usage     print short usage message (this message) and exit

    "--use-perl-parser" => sub{ $use_parser = 'perl' },
    "--use-c-parser"    => sub{ $use_parser = 'c' },
    "--do-not-unprefix-text" => sub{ $options{do_not_unprefix_text} = 1 },
    "--do-not-unfold-text"   => sub{ $options{do_not_unfold_text} = 1 },
    "--fix-errors"           => sub{ $options{fix_errors} = 1 },
    "--fix-duplicate-tags-with-same-values"  =>
        sub{ $options{fix_duplicate_tags_with_same_values} = 1 },
    "--fix-duplicate-tags-with-empty-values" =>
        sub{ $options{fix_duplicate_tags_with_empty_values} = 1 },
    "--fix-data-header"     => sub{ $options{fix_data_header} = 1 },
    "--fix-datablock-names" => sub{ $options{fix_datablock_names} = 1 },
    "--fix-string-quotes"   => sub{ $options{fix_string_quotes} = 1 },
    "--fix-missing-closing-double-quote" =>
        sub{ $options{fix_missing_closing_double_quote} = 1 },
    "--fix-missing-closing-single-quote" =>
        sub{ $options{fix_missing_closing_single_quote} = 1 },
    "--fix-ctrl-z"  => sub{ $options{fix_ctrl_z} = 1 },
    "--allow-uqstring-brackets" => sub{ $options{allow_uqstring_brackets} = 1 },

    "--input-json"  => sub { $input_json  = 1 },
    "--input-cif"   => sub { $input_json  = 0 },

    "--output-json" => sub { $output_json = 1 },
    "--output-cif"  => sub { $output_json = 0 },

    "--cif"  => sub { $input_json = 0; $output_json = 0 },
    "--json" => sub { $input_json = 1; $output_json = 1 },

    "--help,--usage"  => sub { usage; exit },
);

@ARGV = ( "-" ) unless @ARGV;

foreach( @ARGV ) {

    my( $data, $errcount );
    if( $input_json ) {
        local $SIG{__DIE__} =
            sub { my( $msg ) = @_;
                  $msg =~ s/at \S+ line \d+(, <[^>]*> line \d+.?)?$//;
                  die "$0: $_: $msg"
            };
        open( my $inp, $_ );
        $data = json2cif( join( "\n", <$inp> ) );
        close( $inp );
        $errcount = 0;
    } else {
        if( $use_parser eq 'perl' ) {
            my $parser = new COD::CIFParser::CIFParser;
            $data = $parser->Run( $_, \%options );
            if( defined $parser->YYData->{ERRCOUNT} ) {
                $errcount = $parser->YYData->{ERRCOUNT};
            } else {
                $errcount = 0;
            }
        } elsif( $use_parser eq 'c' ) {
            require COD::CCIFParser::CCIFParser;
            ( $data, $errcount ) = COD::CCIFParser::CCIFParser::parse( $_, \%options );
        } else {
            die( "$0: unknown parser: $use_parser" );
        }
    }

    if( $output_json ) {
        print cif2json( $data );
    } else {
        foreach my $datablock ( @$data ) {
            print  $datablock->{name} . "\n";
            print "Values:\n";
            foreach my $tag ( sort { lc( $a ) cmp lc( $b ) } @{$datablock->{tags}} ) {
                print "    " . $tag . " ("
                    . scalar( @{$datablock->{values}{$tag}} ) . ") ";
                print join( " ", map{ "[$_]" } @{$datablock->{values}{$tag}} )
                    . "\n";
            }
            if( exists $datablock->{precisions} ) {
                print "Precisions:\n";
                foreach my $tag ( sort keys %{$datablock->{precisions}} ) {
                    print "    " . $tag . " ("
                        . scalar( @{$datablock->{precisions}{$tag}} ) . ") ";
                    print join( " ", map{ ( defined $_ ) ? $_ : "undef" }
                        @{$datablock->{precisions}{$tag}} ) . "\n";
                }
            }
            if( exists $datablock->{types} ) {
                print "Types:\n";
                foreach my $tag ( sort keys %{$datablock->{types}} ) {
                    print "    " . $tag . " ";
                    print join( " ", @{$datablock->{types}{$tag}} ) . "\n";
                }
            }
            print "Inloops:\n";
            foreach my $tag ( sort keys %{$datablock->{inloop}} ) {
                print "    " . $tag . " " . $datablock->{inloop}{$tag} . "\n";
            }
            print "Loops:\n";
            foreach my $loop ( @{$datablock->{loops}} ) {
                print join( " ", @$loop ) . "\n";
            }
        }
    }
    print STDERR "$errcount error(s) detected\n";
}
