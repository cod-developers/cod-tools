#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Marks disorder in CIF files judging by distance and occupancy.
#**

use strict;
use warnings;
use COD::AtomBricks qw(build_bricks get_atom_index get_search_span);
use COD::AtomProperties;
use COD::CIFParser::CIFParser;
use COD::CIFData::CIFSymmetryGenerator qw( get_cell mat_vect_mul distance );
use COD::CIFData::CIFAtomList qw( atom_array_from_cif );
use COD::CIFTags::CIFTagCanonicalNames;
use COD::CIFTags::CIFTagManage;
use COD::CIFTags::CIFTagPrint;
use COD::Fractional;
use COD::UserMessage;
use COD::SOptions;
use COD::SUsage;

my $Id = '$Id$';

my $same_site_distance_sensivity = 0.000001;
my $same_site_occupancy_sensivity = 0.01;
my $brick_size = 1;
my $cif_header_file;
my $use_parser = "c";
my $exclude_zero_occupancies = 1;
my $report_marked_disorders = 1;
my $ignore_occupancies = 0;
my $messages_to_depositor_comments = 1;

#* USAGE:
#*     $0 [options] input1.cif [input2.cif ...]
#* 
#* OPTIONS:
#*     -d, --distance-sensivity  0.000001
#*        Specify maximum distance between two atoms that should be
#*        perceived as belonging to the same atom site.
#*
#*     --occupancy-sensivity  0.01
#*        Set maximum deviation for the sum of occupancies of the atoms
#*        from the same atom site from 1.
#*
#*     -h, --add-cif-header
#*        Comments from the beginning of this file wil be prepended
#*        to the output.
#*
#*     --exclude-zero-occupancies
#*        Do not use atoms with 0 occupancies in calculations (default).
#*
#*     --no-exclude-zero-occupancies
#*     --dont-exclude-zero-occupancies
#*        Use atoms with zero (0) occupancies in the calculations.
#*
#*     --ignore-occupancies
#*        Do not require occupancies of the atoms in the same atom site
#*        to sum up to 1.
#*
#*     --no-ignore-occupancies
#*     --dont-ignore-occupancies
#*        Require the occupancies of the atoms in the same atom site to
#*        sum up to 1 to be recognised as disorder. Default option.
#*
#*     --report-marked-disorders
#*        Print each of the marked disorder assemblies to the standard
#*        error, listing atom labels. Default option.
#*        
#*     --no-report-marked-disorders
#*     --dont-report-marked-disorders
#*        Do not print marked disorder assemblies to the standard error.
#*
#*     --add-depositor-comments
#*        Append reports about newly marked disorder assemblies together
#*        with the signature of this script to the
#*        '_cod_depositor_comments' value. Default option.
#*
#*     --no-add-depositor-comments
#*     --dont-add-depositor-comments
#*        Do not append anything to the value of '_cod_depositor_comments'.
#*
#*     --brick-size  1
#*        Brick size parameter for 'AtomBricks' algorithm.
#*
#*     --use-perl-parser
#*        Use Perl parser for CIF parsing.
#*
#*     --use-c-parser
#*        Use Perl & C parser for CIF parsing.
#*
#*     --help,--usage
#*        Print short usage message (this message) and exit.
#**

@ARGV = getOptions
(
    "-d,--distance-sensivity" => \$same_site_distance_sensivity,
    "--occupancy-sensivity" => \$same_site_occupancy_sensivity,

    "-h,--add-cif-header" => \$cif_header_file,

    "--exclude-zero-occupancies"    => sub { $exclude_zero_occupancies = 1; },
    "--no-exclude-zero-occupancies" => sub { $exclude_zero_occupancies = 0; },
    "--dont-exclude-zero-occupancies" => sub { $exclude_zero_occupancies = 0; },

    "--ignore-occupancies" => sub { $ignore_occupancies = 1 },
    "--no-ignore-occupancies" => sub { $ignore_occupancies = 0 },
    "--dont-ignore-occupancies" => sub { $ignore_occupancies = 0 },

    "--report-marked-disorders" => sub { $report_marked_disorders = 1 },
    "--no-report-marked-disorders" =>
        sub { $report_marked_disorders = 0 },
    "--dont-report-marked-disorders" =>
        sub { $report_marked_disorders = 0 },

    "--add-depositor-comments" =>
        sub { $messages_to_depositor_comments = 1 },
    "--no-add-depositor-comments" =>
        sub { $messages_to_depositor_comments = 0 },
    "--dont-add-depositor-comments" =>
        sub { $messages_to_depositor_comments = 0 },

    "--brick-size" => \$brick_size,

    "--use-perl-parser" => sub{ $use_parser = "perl" },
    "--use-c-parser"    => sub{ $use_parser = "c" },

    "--help,--usage" => sub { usage; exit },
);

my $cif_header;

if( $cif_header_file ) {
    open( HDR, "$cif_header_file" ) or
        die( "$0: could not open header file '$cif_header_file' " .
             "for input - $!" );

    $cif_header = "";
    while( <HDR> ) {
        last unless /^#/;
        $cif_header .= $_;
    }

    close( HDR ) or
        die( "$0: error reading header file '$cif_header_file' - $!" );
}

@ARGV = ("-") unless @ARGV;

my $cif_atom_list_options = {
    ignore_unknown_chemical_types => 1,
    continue_on_unknown_atom_type => 1,
    stop_if_coordinates_unknown => 1,
    assume_full_occupancy => 1,
};

for my $filename (@ARGV) {
    my $data;
    if( $use_parser eq "perl" ) {
        my $parser = new COD::CIFParser::CIFParser;
        $data = $parser->Run($filename);
    } else {
        require COD::CCIFParser::CCIFParser;
        $data = COD::CCIFParser::CCIFParser::parse($filename);
    }

    canonicalize_all_names( $data );

    print $cif_header if $cif_header;
    for my $dataset (@$data) {
        # extracts atom site label or atom site type symbol
        my $values = $dataset->{values};
        my $dataname = $dataset->{name};
        
        # Get cell angles(alpha, beta, gama) and lengths(a, b, c)
        my @cell = get_cell( $values, $filename, $dataname );

        # Make a matric to convert from fractional coordinates to
        # orthogonal:
        my $f2o = symop_ortho_from_fract(@cell);

        # Extract atoms fract coordinates
        my $atom_list = atom_array_from_cif( $dataset,
                                             \%COD::AtomProperties::atoms,
                                             $filename,
                                             $cif_atom_list_options );

        my %assemblies = map{ $_->{assembly} => 1 }
                         grep{ $_->{assembly} ne '.' ||
                               $_->{group} ne '.' }
                         @$atom_list;
        my @all_assemblies = sort {($a =~ /^\d+$/ && $b =~ /^\d+$/)
                                        ? $a <=> $b
                                        : $a cmp $b} keys %assemblies;
        my $assembly_count = scalar @all_assemblies;

        my $bricks = build_bricks( $atom_list, $brick_size );

        my $alternatives = get_alternatives( $atom_list,
                                             $bricks,
                                             $filename,
                                             $dataname,
                                             $f2o );

        my @new_assemblies;
        for my $atom_index (keys %$alternatives) {
            my $assembly_nr = $alternatives->{$atom_index}[0];
            if( !defined $new_assemblies[$assembly_nr] ) {
                $new_assemblies[$assembly_nr] = [];
            }
            push( @{$new_assemblies[$assembly_nr]}, $atom_index );
        }

        my $has_dot_assembly = exists $assemblies{'.'};
        my $rename_dot_assembly_with;
        if( $has_dot_assembly && ($assembly_count > 1 ||
                                   scalar( keys %$alternatives ) > 0) ) {
            if( $all_assemblies[-1] eq '.' ) {
                $rename_dot_assembly_with = 'A';
            } elsif( grep { !/^[A-Y]$/ } @all_assemblies == 0 ) {
                $rename_dot_assembly_with =
                    chr( ord( $all_assemblies[-1] ) + 1 );
            } else {
                my @numeric = grep { /^\d+$/ } @all_assemblies;
                $rename_dot_assembly_with = $all_assemblies[-1] + 1;
            }
            @all_assemblies = sort {($a =~ /^\d+$/ && $b =~ /^\d+$/)
                                        ? $a <=> $b
                                        : $a cmp $b}
                              (@all_assemblies, $rename_dot_assembly_with );
        }

        my @assembly_names;
        if( @all_assemblies == 0 &&
            ord( 'A' ) + @new_assemblies <= ord( 'Z' ) ) {
            @assembly_names = map { chr( ord( 'A' ) + $_ - 1 ) }
                                  1..@new_assemblies;
        } elsif( @all_assemblies > 0 &&
                 scalar( grep { !/^[A-Z\.]$/ } @all_assemblies ) == 0 &&
                 ord( $all_assemblies[-1] ) + @new_assemblies <= ord( 'Z' ) ) {
            @assembly_names = map { chr( ord( $all_assemblies[-1] ) + $_ ) }
                                  1..@new_assemblies;
        } else {
            my @numeric = grep { /^\d+$/ } @all_assemblies;
            my $first = (@numeric > 0) ? $numeric[-1] : 0;
            @assembly_names = map { $first + $_ } 1..@new_assemblies;
        }

        my @assemblies;
        my @groups;
        for my $atom (@$atom_list) {
            my $name = $atom->{name};
            my $index = $atom->{index};
            if( exists $alternatives->{$index} ) {
                push( @assemblies,
                      $assembly_names[$alternatives->{$index}[0]] );
                push( @groups, $alternatives->{$index}[1] );
            } elsif( exists $atom->{assembly} &&
                     exists $atom->{group} &&
                     $atom->{assembly} ne '.' ) {
                push( @assemblies, $atom->{assembly} );
                push( @groups, $atom->{group} );
            } elsif( defined $rename_dot_assembly_with &&
                     exists $atom->{assembly} &&
                     exists $atom->{group} &&
                     $atom->{assembly} eq '.' &&
                     $atom->{group} ne '.' ) {
                push( @assemblies,
                      $rename_dot_assembly_with );
                push( @groups, $atom->{group} );
            } else {
                push( @assemblies, '.' );
                push( @groups, '.' );
            }
        }

        if( @new_assemblies > 0 || defined $rename_dot_assembly_with ) {

            my @messages;
            if( defined $rename_dot_assembly_with ) {
                my $msg = "disorder assembly '.' was renamed to " .
                          "'$rename_dot_assembly_with'";
                push( @messages, $msg );
                note( $0, $filename, $dataname, $msg );
            }

            for my $assembly (@new_assemblies) {
                my @names = sort map( $atom_list->[$_]{name},
                                      @$assembly );
                my $msg = "atoms " . join( ", ",
                                           map( "'$_'", @names ) ) .
                          " were marked as alternatives";
                push( @messages, $msg );
                if( $report_marked_disorders ) {
                    note( $0, $filename, $dataname, $msg );
                }
            }

            if( @new_assemblies > 0 ) {
                note( $0, $filename, $dataname,
                      scalar( @new_assemblies ) . " site(s) " .
                      "were marked as disorder assemblies" );
            }

            my $atom_site_tag;

            if( exists $values->{"_atom_site_label"} ) {
                $atom_site_tag = "_atom_site_label";
            } else {
                $atom_site_tag = "_atom_site_type_symbol";
            }

            set_loop_tag( $dataset,
                          '_atom_site_disorder_assembly',
                          $atom_site_tag,
                          \@assemblies );
            set_loop_tag( $dataset,
                          '_atom_site_disorder_group',
                          $atom_site_tag,
                          \@groups );

            if( $messages_to_depositor_comments ) {
                my $signature = $Id;
                $signature =~ s/^\$|\$$//g;
                my $comment = "  The following automatic conversions " .
                              "were performed:\n\n";
                $comment .= join( "\n", map( "  " . ucfirst($_) . ".",
                                             @messages ) ) . "\n\n";
                $comment .= "  Automatic conversion script\n  $signature";
                if( !$values->{_cod_depositor_comments} ) {
                    set_tag( $dataset,
                             '_cod_depositor_comments',
                             "\n$comment" );
                } else {
                    $values->{_cod_depositor_comments}[-1] .=
                        "\n\n$comment";
                }
            }
        }

        print_cif( $dataset,
                   {
                        preserve_loop_order => 1,
                        keep_tag_order => 1
                   }
                 );
    }
}

#==============================================================================#
# Find alternatives among CIF atoms
# Accepts
#    atom_list - CIF atom list, as returned by initial_atoms()
#    bricks    - CIF atom bricks, as returned by build_bricks()
#    filename  - CIF file name
#    dataname  - CIF datablock name
# Returns
#    $alternatives = {
#       $atom_number => [ $assembly, $group ]
#    }
sub get_alternatives
{
    my( $atom_list, $bricks, $filename, $dataname, $f2o ) = @_;
    my @assemblies;
    my %in_assembly;

    for my $current_atom (@$atom_list) {
        # Skipping dummy atoms
        if( $current_atom->{coordinates_fract}[0] eq '.' ||
            $current_atom->{coordinates_fract}[1] eq '.' ||
            $current_atom->{coordinates_fract}[2] eq '.' ) {
            next;
        }

        my $atom_in_unit_cell_coords_ortho =
            mat_vect_mul( $f2o, $current_atom->{coordinates_fract} );

        my ($i, $j, $k) =
            get_atom_index( $bricks, @{$atom_in_unit_cell_coords_ortho});

        my( $min_i, $max_i, $min_j, $max_j, $min_k, $max_k ) =
                get_search_span( $bricks, $i, $j, $k );

        my $name1 = $current_atom->{name};
        my $index1 = $current_atom->{index};

        for $i ($min_i .. $max_i) {
        for $j ($min_j .. $max_j) {
        for $k ($min_k .. $max_k) {
            for my $atom ( @{$bricks->{atoms}[$i][$j][$k]} ) {
                my $atom_coords_ortho = $atom->{coordinates_ortho};
                my $name2 = $atom->{name};
                my $index2 = $atom->{index};

                next if $index1 ge $index2;
                next if !exists $atom->{atom_site_occupancy} ||
                       ($atom->{atom_site_occupancy} eq '0.0' &&
                        $exclude_zero_occupancies) || 
                        $atom->{atom_site_occupancy} eq '?' ||
                        $atom->{atom_site_occupancy} eq '.';

                my $dist = distance( $atom_in_unit_cell_coords_ortho,
                                     $atom_coords_ortho );
                next if $dist > $same_site_distance_sensivity;

                # Skipping initially marked disordered atoms:
                if( exists $current_atom->{assembly} &&
                    exists $atom->{assembly} &&
                    $current_atom->{assembly} eq $atom->{assembly} &&
                    exists $current_atom->{group} &&
                    exists $atom->{group} &&
                    $current_atom->{group} ne $atom->{group} ) {
                    next;
                }

                if( !exists $in_assembly{$index1} &&
                    !exists $in_assembly{$index2} ) {
                    # Creating new assembly
                    $in_assembly{$index1} = scalar @assemblies;
                    $in_assembly{$index2} = scalar @assemblies;
                    push( @assemblies, [ $index1, $index2 ] );
                } elsif( exists $in_assembly{$index1} &&
                         exists $in_assembly{$index2} ) {
                    my $assembly1 = $in_assembly{$index1};
                    my $assembly2 = $in_assembly{$index2};
                    next if $assembly1 == $assembly2;

                    # Merging two assemblies
                    my @new_assembly;
                    foreach( @{$assemblies[$assembly1]} ) {
                        $in_assembly{$_} = scalar @assemblies;                        
                        push( @new_assembly, $_ );
                    }
                    $assemblies[$assembly1] = [];
                    foreach( @{$assemblies[$assembly2]} ) {
                        $in_assembly{$_} = scalar @assemblies;
                        push( @new_assembly, $_ );
                    }
                    $assemblies[$assembly2] = [];
                    push( @assemblies, \@new_assembly );
                } else {
                    # Joining one atom to the assembly
                    if( exists $in_assembly{$index1} ) {
                        push( @{$assemblies[$in_assembly{$index1}]},
                              $index2 );
                        $in_assembly{$index2} = $in_assembly{$index1};
                    } else {
                        push( @{$assemblies[$in_assembly{$index2}]},
                              $index1 );
                        $in_assembly{$index1} = $in_assembly{$index2};
                    }
                }
            }
        }}}
    }

    my $count = 0;
    my %assemblies_now;

    for my $assembly (@assemblies) {
        next if @$assembly == 0;
        my $occupancy_sum =
            sum( map { /(.*?)(\(\d+\))?$/; $1 }
                 map { $atom_list->[$_]{atom_site_occupancy} }
                 @$assembly );
        if( abs( $occupancy_sum - 1 ) > $same_site_occupancy_sensivity &&
            !$ignore_occupancies ) {
            my @names = sort map( $atom_list->[$_]{name},
                                  @$assembly );
            warning( $0, $filename, $dataname,
                     "atoms " . join( ", ", map( "'$_'", @names ) ) .
                     " share the same site, but the sum of their " .
                     "occupancies is $occupancy_sum" );
            next;
        }
        my $group_nr = 1;
        foreach( sort @$assembly ) {
            $assemblies_now{$_} = [ $count, $group_nr ];
            $group_nr++;
        }
        $count++;
    }

    return \%assemblies_now;
}

sub sum
{
    my $sum = 0.0;
    foreach( @_ ) { $sum += $_; }
    return $sum;
}
