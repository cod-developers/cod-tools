#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Parse CIF file(s) and CIF dictionary(ies).
#  Check CIF file against CIF dictionaries.
#**

use strict;
use warnings;
use Scalar::Util;
use COD::CIF::Parser qw( parse_cif );
use COD::CIF::Tags::CanonicalNames;
use COD::SOptions;
use COD::SUsage;
use COD::UserMessage qw( note warning error debug_note prefix_dataname );

my $version = 0.1;

my @dictFiles;
my $use_parser = "c";
my $setOfEnum  = ['_atom_site_refinement_flags'];
my $caseSensitive    = 1;
my $reportLocalTags  = 0;
my $reportDeprecated = 0;
my $debug   = 0;

sub VersionMessage();
sub severityName($);
sub getDict($);
sub checkAgainstRange($$$$);
sub checkAgainstRangeNumb($$$);
sub checkAgainstRangeChar($$);
sub getListReferenceTags($$);
sub getReplacementTags($$);

#* USAGE:
#*     $0 --dictionaries "cif_core.dic,cif_cod.dic" [options] input.cif [input2.cif ...]
#*
#** OPTIONS:
#** -d, --dictionaries "cif_core.dic,cif_cod.dic"
#**                     A list of CIF dictionary files (according to DDL2)
#**                     to be used in CIF file validation. List elements
#**                     are separated by either by "," or by " ". To include
#**                     dictionaries with filenames containing these symbols,
#**                     the --add-dictionary option is used.
#** -D, --add-dictionary "cif new dictionary.dic"
#**                     Add additional CIF dictionary to the list.
#** --clear-dictionaries
#**                     Remove all CIF dictionaries from the list.
#** --treat-as-set _atom_site_refinement_flags
#**                     Treat values of given tags as a set. For example,
#**                     more than one enumeration value could be defined
#**                     for a single element. Any number of tags can be
#**                     provided in the following way:
#**                     $0 --treat-as-set _tag_1 --treat-as-set _tag_2
#**                     Default is the '_atom_site_refinement_flags' tag.
#** --no-treat-as-set, dont-treat-as-set
#**                     Do not treat values of any tags as sets.
#**                     (see --treat-as-set).
#** --report-local-tags
#**                     Validate tags prefixed with '_[local]'. This prefix
#**                     was used in COD to denote locally used tags prior to
#**                     the creation of cif_cod.dic. The default is to ignore
#**                     these tags.
#** --no-report-local-tags, --ignore-local-tags
#**                     Ignore tags prefixed with '_[local]'. Default.
#** --ignore-case
#**                     Ignore letter case while validating enumeration values.
#**                     For example, even though '_atom_site_adp_type' is
#**                     restricted to values ('Uani', 'Uiso', 'Uovl', ...),
#**                     value 'UANI' would still be treated as valid.
#** --respect-case, --case-sensitive, --dont-ignore-case
#**                     Respect letter case while validating enumeration 
#**                     values. Default.
#** --report-deprecated
#**                     Report tags that are marked as deprecated in the 
#**                     dictionaries. Tag deprecation usually means that it 
#**                     has been replaced with an another tag(s).
#** --ignore-deprecated
#**                     Do not report tags that are marked as deprecated in the 
#**                     dictionaries. Default.
#** --use-perl-parser
#**                     Use Perl parser to parse CIF files.
#** --use-c-parser
#**                     Use C parser to parse CIF files. Default option.
#** --debug
#**                     Output extra information for debugging purposes.
#** -v, --version
#**                     Print version message and exits.
#** --help, --usage
#**                     Print short usage message (this message) and exit.

# check parameters passed
@ARGV = getOptions(
    "-d,--dictionaries"    => sub{ @dictFiles = split( ',|\s+', &get_value ) },
    "-D,--add-dictionary"  => sub{ push( @dictFiles, &get_value ) },
    "--clear-dictionaries" => sub{ @dictFiles = () },

    "--treat-as-set"                    => $setOfEnum,
    "--no-treat-as-set"                 => sub{ $setOfEnum = [] },

    "--ignore-case"                     => sub{ $caseSensitive = 0 },
    "--dont-ignore-case,--respect-case" => sub{ $caseSensitive = 1 },
    "--case-sensitive"                  => sub{ $caseSensitive = 1 },

    "--report-local-tags"               => sub{ $reportLocalTags = 1 },
    "--no-report-local-tags"            => sub{ $reportLocalTags = 0 },
    "--ignore-local-tags"               => sub{ $reportLocalTags = 0 },

    "--report-deprecated"               => sub{ $reportDeprecated = 1 },
    "--ignore-deprecated"               => sub{ $reportDeprecated = 0 },

    "--use-perl-parser"                 => sub{ $use_parser = "perl" },
    "--use-c-parser"                    => sub{ $use_parser = "c" },

    "-v,--version"      => sub{ VersionMessage(); exit; },
    "--help,--usage"    => sub{ usage; exit; },
    "--debug"           => sub{ $debug = 1 }
);

my %dictTags;

if( @dictFiles ) {
    my $tag_count = 0;
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    foreach my $dict ( @dictFiles ) {
        my ( $data, $err_count, $messages ) = parse_cif( $dict, $options );

        if ( $err_count > 0 ) {
            print STDERR $_ foreach ( @$messages );
            error( $0, $dict, undef, "$err_count error(s) "
                 . "encountered while parsing the file", undef );
            next;
        }
        print STDERR $_ foreach ( @$messages );

        $dictTags{$dict} = getDict( $data );
        if ( scalar( keys( $dictTags{$dict} ) ) == 0 ) {
            warning( $0, $dict, undef, "no tag definitions found", undef )
        }
        $tag_count += scalar( keys( $dictTags{$dict} ) );
    }

    if( $tag_count == 0 ) {
        error( $0, undef, undef, 'no tag definitions were ' .
               "found in the provided dictionary files ('" .
                join( "', '", @dictFiles ) . "')", undef );
        exit 1;
    }
} else {
    error( $0, undef, undef, "at least one dictionary file should be " .
           "provided by using the '--dictionaries' option. Automatic " .
           "dictionary download is not implemeted yet", undef );
    my $dictIUCRURI = "ftp://ftp.iucr.org/pub/cif_core.dic";
    exit 1;
}

@ARGV = ("-") unless @ARGV;
# start-iterate-through-CIF-files
CIFFILEANAL: for my $filename ( @ARGV ) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );

    if ( $err_count > 0 ) {
        print STDERR $_ foreach ( @$messages );
        error( $0, $filename, undef, "$err_count error(s) "
             . "encountered while parsing the file", undef );
        next;
    }
    print STDERR $_ foreach ( @$messages );

    # convert all tags to a "cannonical" form
    canonicalize_all_names( $data );
    next CIFFILEANAL if ( !defined $data || $data == 1 );

    for my $block ( @$data ) {

        my $dataname = prefix_dataname($block->{name});

        if( $debug ) {
            debug_note( $0, $filename, $dataname, 'analysis start', undef );
        }
        # 2-D array ( [loop_number][list_of_tags] ) to store names of looped 
        # list reference tags that have been reported as missing
        my @reportedBlockReferences;
        #
        # start iteration through CIF values
        #
        for my $tagAnalysed ( @{$block->{tags}} ) {
            if(!defined $block->{types}{$tagAnalysed}) {
                if ( $debug ) {
                    warning( $0, $filename, $dataname,
                      "tag '$tagAnalysed' has no associated type ",
                      'an error in CIF parser had probably occured' );
                }
            }
            my $lc_tagAnalysed = lc $tagAnalysed;
            my $defined = 0;
            if( ! $reportLocalTags && $lc_tagAnalysed =~ m/^_\[local\]/ ) {
                ++$defined;
            }
            #
            # start iteration through dictionaries
            #
            for my $dictF ( sort keys %dictTags ) {
                my $dictD = $dictTags{$dictF};
                # check if tags are defined in the dictionary
                if( exists $$dictD{$lc_tagAnalysed} ) {
                    $defined = 1;
                    if ( $debug ) {
                      debug_note( $0, $filename, $dataname, "tag '$tagAnalysed' "
                                . "is defined in dictionary $dictF", undef );
                    }
                } else {
                    if ( $debug ) {
                      debug_note( $0, $filename, $dataname, "tag '$tagAnalysed' "
                               . "is not defined in dictionary $dictF", undef );
                    }
                    next;
                }

                # check if tags are deprecated (replaced with other tags)
                my $replTags = getReplacementTags($dictD, $lc_tagAnalysed);
                if( $reportDeprecated && @$replTags != 0 ) {
                    note( $0, $filename, $dataname,
                          "tag '$tagAnalysed' has been replaced by tag(-s) "
                        . '[' . join(', ', @$replTags) . '] '
                        . "according to $dictF", undef );
                }

                # check if looped lists contain reference tags required by 
                # other tags in the looped list (together acting as a unique key)
                my $dictTagValues = $dictD->{$lc_tagAnalysed}{values};

                if ( exists $block->{inloop}{$tagAnalysed} ) {
                    my $refTags = getListReferenceTags($dictD, $lc_tagAnalysed);
                    for ( my $i = 0; $i < @{$block->{loops}}; $i++ ) {
                      if( grep $_ eq $tagAnalysed, @{$block->{loops}[$i]} ) {
                        foreach my $loopRefTag (@$refTags) {
                            # TO-DO: the reference property is also transitional 
                            # to the 'alternate' tags and this must be tested
                            if( grep lc($_) eq $loopRefTag, @{$block->{loops}[$i]} ) {
                                if ( $debug ) {
                                    debug_note ( $0, $filename, $dataname,
                                       "tag '$loopRefTag' is mandatory "
                                     . 'in loop when tag(s) ['
                                     . join(', ', @{$dictTagValues->{_name}})
                                     . '] are defined according to '
                                     . "$dictF and was found", undef );
                                }
                            } elsif (!grep { $_ eq $loopRefTag }
                                                 @{$reportedBlockReferences[$i]}) {
                                    note( $0, $filename, $dataname,
                                       "tag '$loopRefTag' is mandatory in loop "
                                     . "when tag(s) ["
                                     . join(', ', @{$dictTagValues->{_name}})
                                     . "] are defined according to $dictF "
                                     . 'but was not found', undef );
                                    push $reportedBlockReferences[$i], $loopRefTag;
                            }
                        }
                      }
                    }
                } elsif( $debug ) {
                    debug_note( $0, $filename, $dataname, "tag $tagAnalysed "
                              . 'is not in loop', 'test for missing looped '
                              . 'list reference tags will be skipped' );
                }

                # check list mandatory
                if( exists $dictD->{$lc_tagAnalysed}
                    && exists $dictD->{$lc_tagAnalysed}{values}{_list}
                    && $dictD->{$lc_tagAnalysed}{values}{_list}[0] eq 'yes' )
                {
                    if( exists $block->{inloop}{$tagAnalysed} ) {
                        if ( $debug ) {
                            debug_note( $0, $filename, $dataname,
                                "tag '$tagAnalysed' must be in a loop " .
                                "according to $dictF and is in a loop", undef );
                        }
                    } else {
                        note( $0, $filename, $dataname,
                              "tag '$tagAnalysed' must be in a loop " .
                              "according to $dictF but is not in a loop", undef );
                    }
                }
                # check types of values
                my $range = {};
                my %rangeForPrint;
                if( exists $dictD->{$lc_tagAnalysed} &&
                    exists $dictD->{$lc_tagAnalysed}{values}{_enumeration_range} ) {
                    ($$range{min}, $$range{max}) = split(/:/, 
                        $dictD->{$lc_tagAnalysed}{values}{_enumeration_range}[0],
                        2);
                    %rangeForPrint = %$range;
                    if( length($$range{min}) == 0 ) {
                        delete $$range{min};
                        $rangeForPrint{min} = '<any>';
                    }
                    if( length($$range{max}) == 0 ) {
                        delete $$range{max};
                        $rangeForPrint{max} = '<any>';
                    }
                }

                CIFVALUE: for my $tagIndex ( 0..$#{$block->{values}{$tagAnalysed}} ) {
                    my $tagValue = $block->{values}{$tagAnalysed}[$tagIndex];

                    next CIFVALUE if $tagValue eq '.' or $tagValue eq '?';
                    my $value = $tagValue;

                    #
                    # if check values in enumeration list
                    #
                    if( exists $dictD->{$lc_tagAnalysed} &&
                        exists $dictD->{$lc_tagAnalysed}{values}{_enumeration} ) {
                        my $listEnumValuesForTag = join(', ',
                            @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}}
                        );
                        my $valueFoundInList = 0;
                        my $emulateSet = 0;
                        if(  grep lc($_) eq $lc_tagAnalysed, @{$setOfEnum} ) {
                            $emulateSet = 1;
                            my $setOfEnumValues = join '|',
                               @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}};
                            $setOfEnumValues =~ s/\./\\./;
                            my $regexpSetOfEnumValues = 
                                                 qr/^($setOfEnumValues)+$/s;
                            if( $caseSensitive ) {
                                if( $value =~ m/$regexpSetOfEnumValues/s ) {
                                        $valueFoundInList = 1;
                                }
                            } else {
                                if( $value =~ m/$regexpSetOfEnumValues/is ) {
                                    $valueFoundInList = 1;
                                }
                            }
                        } else {
                            if( $caseSensitive ) {
                                if( grep $_ eq $value, 
                                    @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}} ) {
                                    $valueFoundInList = 1;
                                }
                            } else {
                                my $lcValue = lc $value;
                                if( grep lc($_) eq $lcValue, 
                                    @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}} ) {
                                    $valueFoundInList = 1;
                                }
                           }
                       }

                       if( $valueFoundInList == 0 ) {
                            note( $0, $filename, $dataname,
                                  "tag '$tagAnalysed' value \"$value\" must "
                                . 'be one of the enumeration values '
                                . "[$listEnumValuesForTag]", undef );
                       } else {
                            my $message = "tag '$tagAnalysed' value \"$value\" "
                                        . 'is one of the enumeration '
                                        . "values [$listEnumValuesForTag]";

                            $message .= ' (case ignored)' if( !$caseSensitive );

                            $message .= ', enum was treated as set'
                                                              if( $emulateSet );

                            if ($debug) {
                                debug_note( $0, $filename, $dataname, $message, undef );
                            }
                       }
                    }
                    #
                    # Check if values match the declared types:
                    #

                    if( exists $dictD->{$lc_tagAnalysed} && (
                            defined $dictD->{$lc_tagAnalysed}{values}{_type} &&
                            $dictD->{$lc_tagAnalysed}{values}{_type}[0] eq 'numb' ||
                            defined $dictD->{$lc_tagAnalysed}{values}{"_item_type.code"} &&
                            ($dictD->{$lc_tagAnalysed}{values}{"_item_type.code"}[0] eq "float" ||
                             $dictD->{$lc_tagAnalysed}{values}{"_item_type.code"}[0] eq "int")
                        )) {

                        if(defined $block->{types}{$tagAnalysed}) {
                            if('FLOAT' ne $block->{types}{$tagAnalysed}[$tagIndex]
                                && 'INT' ne $block->{types}{$tagAnalysed}[$tagIndex]) {
                                note( $0, $filename, $dataname,
                                      "tag '$tagAnalysed' value \"" . 
                                     $block->{values}{$tagAnalysed}[$tagIndex] .
                                     "\" is of type '" .
                                     $block->{types}{$tagAnalysed}[$tagIndex] .
                                     "' while it should be numeric, i.e. " .
                                     "'FLOAT', or 'INT'", undef );
                            } elsif( $debug ) {
                                debug_note( $0, $filename, $dataname,
                                            "tag '$tagAnalysed' is of type '" .
                                            $block->{types}{$tagAnalysed}[$tagIndex] .
                                            "' as expected, as it should be either " .
                                            "'FLOAT' or 'INT'", undef );
                            }
                        }
                    }

                    # check if standard uncertainty is permitted
                    # some non 'numb' type values might have been parsed
                    # as numbers (s.u. values recorded separately) so
                    # type checking is used to avoid false positive alert
                    my $su_permitted = 0;
                    if ( defined $dictTagValues->{_type} ) {
                        if ( $dictTagValues->{_type}[0] ne 'numb' ) {
                            $su_permitted = 1
                        } elsif (defined $dictTagValues->{_type_conditions} ) {
                            foreach (@{$dictTagValues->{_type_conditions}}) {
                                if ( $_ eq 'esd' || $_ eq 'su' ) {
                                    $su_permitted = 1 ;
                                }
                            }
                        }
                    }

                    my $sigma = $block->{precisions}{$tagAnalysed}[$tagIndex];
                    if ( defined $sigma && !$su_permitted ) {
                        $value =~ /(\(\d+\))$/;
                        note( $0, $filename, $dataname,
                              "tag '$tagAnalysed' value \"$value\" is not "
                            . 'permitted to contain standard uncertainty '
                            . '"' . $1 . '"', 'standard uncertainty will '
                            . 'be ignored in further validation' );
                        $sigma = undef;
                    }

                    #
                    # Check values against enumeration_range
                    #
                    if( %$range ) {
                        my $valueWOPrecision = $value;
                        if( exists $dictD->{$lc_tagAnalysed} &&
                            $dictD->{$lc_tagAnalysed}{values}{_type}[0]
                            eq 'numb' ) {
                            $valueWOPrecision =~ s/\s*\(.*$//;
                        }
                        if( exists $dictD->{$lc_tagAnalysed} &&
                            checkAgainstRange(
                                $dictD->{$lc_tagAnalysed}{values}{_type}[0],
                                $range, $valueWOPrecision, $sigma) <= 0 ) {
                                note( $0, $filename, $dataname,
                                      "tag '$tagAnalysed' value " .
                                      "\"$value\" should be in range (" .
                                      $rangeForPrint{min} .
                                      ', ' . $rangeForPrint{max} . ')', undef );
                        } elsif( $debug ) {
                            debug_note( $0, $filename, $dataname,
                                        "tag '$tagAnalysed' value " .
                                        "\"$value\" is in range (" .
                                        "$rangeForPrint{min}, " .
                                        "$rangeForPrint{max})", undef );
                        }
                    } elsif( $debug ) {
                        debug_note( $0, $filename, $dataname,
                                    'there are no range restrictions ' .
                                    "for tag \"$tagAnalysed\"",
                                    'skipping range test' );
                    }
                }
            }

            if( !$defined ) {
                note( $0, $filename, $dataname, "tag '$tagAnalysed' "
                    . "was not found in dictionaries", undef );
            }
        }
    }
}

##
# Prints program version message.
##
sub VersionMessage()
{
print <<END_M;
cif_validate (using CIF::Parser::Yapp v.$COD::CIF::Parser::Yapp::version) v.$version

END_M
}

##
# Returns a string that describes "severity level" in a human readable
# form (for discussions of severity levels, see ../doc/error-levels.txt.
# @params $severity
#       Code number of the error severity level.
# @return
#       Error severity level text string.
##
sub severityName($)
{
    my ($severity) = @_;

    if( $severity & 1 ) {
        return "ERROR";
    } elsif( $severity & 2 ) {
        return "WARNING";
    } elsif( $severity & 4 ) {
        return "NOTE";
    } elsif( $severity & 8 ) {
        return "INFO-ERROR";
    } elsif( $severity & 16 ) {
        return "INFO-WARNING";
    } elsif( $severity & 32 ) {
        return "INFO-NOTICE";
    } elsif( $severity & 64 ) {
        return "INFO-INDICATOR";
    } else {
        return "ERROR-LEVEL=$severity";
    }
}

##
# Extracts tags from dictionary (parsed using COD::CIF::Parser).
# @param $dictF
#       Reference to COD::CIF::Parser output CIF object.
# @return
#       Hash of tags and related references to parsed data blocks.
##
sub getDict($)
{
    my ($dictF) = @_;
    my $tags = {};
    my $datan = 0;
    while( $datan < @$dictF ) {
        if( exists $dictF->[$datan]{save_blocks} ) {
            for my $saveblk ( @{$dictF->[$datan]{save_blocks}} ) {
                ## print ">>>> processing save block '$saveblk->{name}'\n";
                next if !exists $saveblk->{values}{"_item.name"};
                for ( @{$saveblk->{values}{"_item.name"}} ) {
                    ## print ">>> defining '$_'\n";
                    $$tags{lc $_} = $saveblk;
                    $$tags{lc $_}{values}{_dataname} = $_;
                }
            }
        }

        $datan++ and next if
            !exists $$dictF[$datan]{values}{_type};
        for ( @{$$dictF[$datan]{values}{_name}} ) {
            $$tags{lc $_} = $$dictF[$datan];
            $$tags{lc $_}{values}{_dataname} = $$dictF[$datan]{name};
        }
        $datan++;
    }


    return $tags;
}

##
# Returns tag names that have superseded the tag.
# @param $dict
#       Reference to a dictionary object as returned by 'getDict' subroutine.
# @param $tag
#       Name of the tag.
# @return
#       Array of tag names that have superseded the tag. If the tag has not
#       been deprecated, an empty array is returned.
##
sub getReplacementTags($$)
{
    my ( $dict, $tag, ) = @_;

    my $tagValues = $dict->{lc $tag}{values};

    my @replaceWith;
    # check if tags are deprecated (replaced with other tags)
    if( defined $tagValues->{_related_item} ) {
        for( my $i = 0; $i < @{$tagValues->{_related_item}}; $i++ ) {
            if( $tagValues->{_related_function}[$i] eq 'replace') {
                push @replaceWith, $tagValues->{_related_item}[$i];
            }
        }
    }
    return \@replaceWith;
}

##
# Check value against range (defined in dictionary).
# @param $type
#       String, representing the type of value ("numb" or "char").
# @param $range
#       Reference to range hash as $$range{min} and $$range{max}.
# @param $value
#       Value that must be checked.
# @param $sigma
#       Standard deviation to be used when comparing numbers.
# @return
#       -1 if no ranges were provided for the value;
#        0 if the value is out of the provided range;
#        1 if the value is in the provided range.
##
sub checkAgainstRange($$$$)
{
    my ($type, $range, $value, $sigma) = @_;

    if( !exists $$range{min} &&
        !exists $$range{max} ) {
        return -1;
    }
    if( $type eq 'numb' ) {
        return checkAgainstRangeNumb( $range, $value, $sigma );
    } else {
        return checkAgainstRangeChar( $range, $value );
    }
}

##
# Checks number value against range (defined in dictionary).
# @param $range
#       Reference to range hash as $$range{min} and $$range{max}.
# @param $value
#       Value, that must be checked.
# @param $sigma
#       Standard deviation to be used when comparing numeric values
#       (3 sigma rule). If sigma is set to 'undef', values are compared 
#       disregarding standard deviation.
# @return
#        0 if the value is out of the provided range or is not a number
#          at all;
#        1 if the value is in the provided range.
##
sub checkAgainstRangeNumb($$$)
{
    my ( $range, $value, $sigma ) = @_;

    if( ! Scalar::Util::looks_like_number($value) ) {
        return 0;
    }

    my ($min,$max);

    if( defined $sigma ) {
        $min = $$range{min} - 3 * $sigma if exists $$range{min};
        $max = $$range{max} + 3 * $sigma if exists $$range{max};
    } else {
        $min = $$range{min} if exists $$range{min};
        $max = $$range{max} if exists $$range{max};
    }

    if(
        ( !defined $max || $value <= $max )
        &&
        ( !defined $min || $value >= $min )
    ) {
        return 1;
    }
    return 0;
}

##
# Check character value against range (defined in dictionary).
# @param $range
#       Reference to range hash as $$range{min} and $$range{max}.
# @param $value
#       Value, that must be checked.
# @return
#       0 if the value is out of the provided range;
#       1 if the value is in the provided range.
##
sub checkAgainstRangeChar($$)
{
    my ( $range, $value ) = @_;

    if(
        ( !exists $$range{max} || $value le $$range{max} )
        &&
        ( !exists $$range{min} || $value ge $$range{min} )
    ) {
        return 1;
    }
    return 0;
}

##
# Returns an array of tags that are required to be present in the loop 
# containing the analyzed tag.
# @param $dict
#       Reference to a dictionary object as returned by 'getDict' subroutine.
# @param $tag
#       Name of the tag to analyze.
# @return $listReferenceTags;
#       A reference to an array of tags that are required to be present in the 
#       loop containing the analyzed tag.
##
sub getListReferenceTags($$)
{
    my ( $dict, $tag ) = @_;

    my $tagValues = $dict->{lc $tag}{values};
    my @listReferenceTags;
    if ( defined $tagValues && defined $tagValues->{_list_reference} ) {
        # _list_reference identifies data item(s) that must collectively be
        # in a loop. They are referenced by the names of their data blocks
        foreach my $refDataname (@{$tagValues->{_list_reference}}) {
          foreach my $tags ( sort keys $dict ) {
              if ( "_" . $dict->{$tags}{values}{_dataname} eq $refDataname ) {
                  push @listReferenceTags, $tags;
              }
          }
        }
    }

    return \@listReferenceTags;
}
