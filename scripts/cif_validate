#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;

#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Parse CIF file(s) and CIF dictionary(ies).
#  Check CIF file against CIF dictionaries.
#**

use strict;
use warnings;
use Scalar::Util;
use COD::CIFParser::CIFParser;
use COD::CIFTags::CIFTagCanonicalNames;
use COD::ShowStruct;
use COD::SOptions;
use COD::SUsage;
use COD::UserMessage qw( note warning error debug_note );

#
# here we define variables
#        first - constant values
#        then  - common variables
#
my $version = 0.1;

my $CIFfile = ();
my $CIFtags;
my $dictFiles = [];
my $setOfEnum = [];
my $dictFilesParsed = [];
my $dictTags = {};
my $verbose  = 1;
my $use_parser = "perl";
my $caseSensitive    = 1;
my $reportLocalTags  = 0;
my $reportDeprecated = 0;
my $debug = 0;

# TODO: 'errorLevel' and 'quiet' options must be removed later in 
# accordance to this option. Some 'debug' option might be created, to 
# report more information than it is necessary to understand validation 
# errors.
#

# subroutine to print module version and copyright notice
sub VersionMessage;

# subroutine to extract tags from dictionary (parsed using CIFParser)
# it takes reference to CIFParser output
# returns hash of tags and related references to parsed data blocks
sub getDict;

# subroutine to check value against range (defined in dictionary)
# Arguments:
#   1. type of value (numb or char);
#   2. reference to range as $$range{min} and $$range{max};
#   3. value, that must be checked.
sub checkAgainstRange;

# subroutine to check number value against range (defined in dictionary)
# Arguments:
#   1. reference to range as $$range{min} and $$range{max};
#   2. value, that must be checked.
sub checkAgainstRangeNumb;

# subroutine to check character value against range (defined in dictionary)
# Arguments:
#   1. reference to range as $$range{min} and $$range{max};
#   2. value, that must be checked.
sub checkAgainstRangeChar;

# subroutine to return name of closest (according to dictionary) 
#     mandatory tag, if applicable. Return undef, if no mandatory tag is 
#     related to tag analysed
# Arguments:
#   1. reference to dictionary
#   2. lowercased name of currently analysed tag
sub getRelatedMandatory;

# Treat '_atom_site_refinement_flags' by default, as it is so documented 
# in CIF core dictionary.
push @$setOfEnum, '_atom_site_refinement_flags';

# // adds a new dict --add-dictionary | --dictionaries priima tarpais ar kableliais priskirtus

#** OPTIONS:
#** --dictionary cif_core.dic
#**                     Any valid CIF file, with CIF dictionary (according 
#**                     to DDL2). You can define any number of CIF 
#**                     dictionaries, in a way like this:
#**                     $0 --dictionary cif_core.dic --dictionary cod_core.dic
#** --quiet
#**                     Minimize program output.
#** --no-quiet, --not-quiet, --verbose
#**                     Maximize program output.
#** -v, --version
#**                     Print version message and exits.
#** --help, --usage
#**                     Print short usage message (this message) and exit.
#** --treat-as-set
#**                     If tag name is given to this parameter and tag 
#**                     specified has some enumeration values to check 
#**                     against, they are treated as set, i.e. more than one 
#**                     of enumeration values could be defined for one single 
#**                     element. By default it is turned on for tag 
#**                     '_atom_site_refinement_flags', which is documented as 
#**                     set, but only in it's description.
#** --no-treat-as-set, dont-treat-as-set
#**                     This parameter turns off all so far defined exceptions, 
#**                     that emulates enumeration treating as set 
#**                     (see --treat-as-set).
#** --report-local-tags
#**                     Turn on test 'tag-exists-local'. This test enforces 
#**                     check of tags marked as local, i.e. 
#**                     _[local]_cod_depositor_comments. Otherwise these tags 
#**                     are ignored.
#** --no-report-local-tags, --ignore-local-tags
#**                     Turn off test 'tag-exists-local'. Default.
#** --ignore-case
#**                     Turn on tests 'values-enum-nocase' and 'values-enum'.
#**                     This is a test option, indicating that case must be 
#**                     ignored, while checking them against list 
#**                     (see 'values-enum'). This option is only actual if 
#**                     values-enum test is ON. I.e. '_atom_site_adp_type'
#**                     is restricted to values ('Uani', 'Uiso', 'Uovl', ...) 
#**                     and 'UANI' would be incorrect, if values-enum-nocase 
#**                     is turned off.
#** --respect-case, --case-sensitive, --dont-ignore-case
#**                     Turn off test 'values-enum-nocase'. Default.
#** --report-deprecated
#**                     Turn on test 'tag-deprecated'. This test checks 
#**                     whereas tag was not replaced by new one.
#** --ignore-deprecated
#**                     Turn off test 'tag-deprecated'. Default.
#** --debug
#**                     Output extra information for debugging purposes.
#** --use-perl-parser
#**                     Use Perl parser to parse CIF files. Default option.
#** --use-c-parser
#**                     Use C parser to parse CIF files.

# check parameters passed
@ARGV = getOptions(
        "--dictionary"
            => $dictFiles,

        "--treat-as-set"    => $setOfEnum,
        "--no-treat-as-set" => sub{ $setOfEnum = [] },

        "--ignore-case"                     => sub{ $caseSensitive = 0 },
        "--dont-ignore-case,--respect-case" => sub{ $caseSensitive = 1 },
        "--case-sensitive"                  => sub{ $caseSensitive = 1 },

        "--report-local-tags"               => sub{ $reportLocalTags = 1 },
        "--no-report-local-tags"            => sub{ $reportLocalTags = 0 },
        "--ignore-local-tags"               => sub{ $reportLocalTags = 0 },

        "--report-deprecated"               => sub{ $reportDeprecated = 1},
        "--ignore-deprecated"               => sub{ $reportDeprecated = 0},

        "--quiet"                           => sub{ $verbose = 0 },
        "--verbose,--no-quiet,--not-quiet"  => sub{ $verbose = 1 },

        "--use-perl-parser"                 => sub{ $use_parser = "perl" },
        "--use-c-parser"                    => sub{ $use_parser = "c" },

        "-v,--version"      => sub{ VersionMessage(), exit; },
        "--help,--usage"    => sub{ usage; exit; },
        "--debug"           => sub{ $debug = 1 }
    );

if( @$dictFiles ) {
    my $tag_count = 0;
    foreach ( @{$dictFiles} ) {
        my $parsed;
        if( $use_parser eq "perl" ) {
            my $parser = new COD::CIFParser::CIFParser;
            $parsed = $parser->Run( $_ );
            next if $parsed == 1;
        } else {
            require COD::CCIFParser::CCIFParser;
            my $error_count;
            ( $parsed, $error_count ) = COD::CCIFParser::CCIFParser::parse( $_ );
            next if $error_count > 0;
        }
        push( @$dictFilesParsed, $parsed );
        $$dictTags{$_} = getDict( $parsed );
        if ( scalar( keys( $$dictTags{$_} ) ) == 0 ) {
            warning( $0, $_, undef, "no tag definitions found." )
        }
        $tag_count += scalar( keys( $$dictTags{$_} ) );
    }

    if( ! $tag_count ) {
        error( $0, undef, undef, 'no tag definitions were ' .
               "found in the provided dictionary files ('" .
                join( "', '", @$dictFiles ) . "')" );
        exit 1;
    }
} else {
    error( $0, undef, undef, "at least one dictionary file should be " .
           "provided by using the '--dictionary' option. Automatic " .
           "dictionary download is not implemeted yet." );
    my $dictIUCRURI = "ftp://ftp.iucr.org/pub/cif_core.dic";
    exit 1;
}

@ARGV = ("-") unless @ARGV;

#
# start-iterate-through-CIF-files
#
CIFFILEANAL: for my $cifF ( @ARGV ) {
    my $data;
    if( $use_parser eq "perl" ) {
        my $parser = new COD::CIFParser::CIFParser;
        $data = $parser->Run( $cifF );
    } else {
        $data = COD::CCIFParser::CCIFParser::parse( $cifF );
    }
    # convert all tags to a "cannonical" form (the one used in the
    # CIFTags modules ;):
    canonicalize_all_names( $data );
    next CIFFILEANAL if ( !defined $data || $data == 1 );
    #
    # start-iterate-trough-CIF-file-data-blocks
    #
    for my $block ( @$data ) {
        if( $debug ) {
            debug_note( $0, $cifF, $$block{name}, 'analysis start' );
        }
        #
        # hash tagsListedInLoops
        # If a tag (key is lowercased tag name) appears in this hash it 
        # means, that it must appear within loop.
        # Value is enum('yes', 'no'). Depending on this we know, whereas 
        # tag was correctly (i.e. together with other tags) defined 
        # within some loop.
        #
        my %tagsListedInLoops;
        #
        # hash baseNamesOfRefTags
        # A tag listed in this hash depends on some other loop_ tag, and
        # is correctly referenced (parent tag is defined within same 
        # loop). Value is enum('yes', 'no').
        #
        my %baseNamesOfRefTags;
        #
        # start iteration through CIF values
        #
        for my $tagAnalysed ( @{$block->{tags}} ) {
            if(!defined $block->{types}{$tagAnalysed}) {
                if ( $debug ) {
                    warning( $0, $cifF, $$block{name},
                      "tag '$tagAnalysed' has no associated type which," .
                      'probably, means that error in CIFParser had occured' );
                }
            }
            my $lc_tagAnalysed = lc $tagAnalysed;
            my $defined = 0;
            if( ! $reportLocalTags && $lc_tagAnalysed =~ m/^_\[local\]/ ) {
                ++$defined;
            }
            #
            # start-iterate-through-dictionaries
            #
            while( my($dictF, $dictD) = each %$dictTags ) {
                # check if tags are defined in the dictionary
                if( exists $$dictD{$lc_tagAnalysed} ) {
                    $defined = 1;
                    if ( $debug ) {
                      debug_note( $0, $cifF, $$block{name},
                      "tag '$tagAnalysed' is defined in dictionary $dictF" );
                    }
                } else {
                    if ( $debug ) {
                      debug_note( $0, $cifF, $$block{name},
                      "tag '$tagAnalysed' is not defined in dictionary $dictF" );
                    }
                    next;
                }

                # check if tags are deprecated (replaced with other tags)
                if( exists $$dictD{$lc_tagAnalysed} &&
                    exists $dictD->{$lc_tagAnalysed}{values}{_related_item}) {
                    my $replaceWith = [];
                    for( my $i = 0;
                         $i < @{$dictD->{$lc_tagAnalysed}{values}{_related_item}};
                         $i++ )
                    {
                        if($dictD->{$lc_tagAnalysed}{values}{_related_function}[$i]
                           eq 'replace') {
                            push @{$replaceWith},
                            $dictD->{$lc_tagAnalysed}{values}{_related_item}[$i];
                        }
                    }
                    if( $reportDeprecated && @$replaceWith != 0 ) {
                        note( $0, $cifF, $$block{name},
                              "tag '" . $tagAnalysed . "' has been" .
                              ' replaced by tag(-s): [' .
                              join(', ', @$replaceWith) .
                              '] according to ' . $dictF );
                    }
                }

                # check referenced list mandatory
                my $mandatoryRTag = getRelatedMandatory($dictD, $lc_tagAnalysed);
                if( defined $mandatoryRTag
                    && !exists($baseNamesOfRefTags{$mandatoryRTag})
                 ) {
                  for my $loopAnalysed ( @{$block->{loops}} ) {
                    if( grep $_ eq $tagAnalysed, @{$loopAnalysed} ) {
                        if( grep lc($_) eq $mandatoryRTag, @{$loopAnalysed} ) {
                            if ( $debug ) {
                                debug_note ( $0, $cifF, $$block{name},
                                  "tag '$mandatoryRTag' is mandatory " .
                                  "in loop when tag(s) [" .
                                  join(', ', 
                                  @{$dictD->{$lc_tagAnalysed}{values}{_name}}) .
                                  "] are defined according to $dictF and was" .
                                  ' found' );
                            }
                            $baseNamesOfRefTags{$mandatoryRTag} = 'yes';
                            last;
                        } else {
                            note( $0, $cifF, $$block{name},
                                  "tag '$mandatoryRTag' is mandatory in loop " .
                                  "when tag(s) [" .
                                  join(', ', 
                                  @{$dictD->{$lc_tagAnalysed}{values}{_name}}) .
                                  '] are defined according to ' . $dictF .
                                  ' but was not found' );
                            $baseNamesOfRefTags{$mandatoryRTag} = 'no';
                            last;
                        }
                    }
                  }
                }
                # check list mandatory
                if( exists $dictD->{$lc_tagAnalysed}
                    && exists $dictD->{$lc_tagAnalysed}{values}{_list}
                    && $dictD->{$lc_tagAnalysed}{values}{_list}[0] eq 'yes' )
                {
                    if( exists $block->{inloop}{$tagAnalysed} ) {
                        if ( $debug ) {
                            debug_note( $0, $cifF, $$block{name}, 
                                "tag '$tagAnalysed' must be in a loop " .
                                "according to $dictF and is in a loop" );
                        }
                    } else {
                        note( $0, $cifF, $$block{name},
                              "tag '$tagAnalysed' must be in a loop " .
                              "according to $dictF but is not in a loop" );
                    }
                }
                # check types of values
                my $range = {};
                my %rangeForPrint;
                if( exists $dictD->{$lc_tagAnalysed} &&
                    exists $dictD->{$lc_tagAnalysed}{values}{_enumeration_range} ) {
                    ($$range{min}, $$range{max}) = split(/:/, 
                        $dictD->{$lc_tagAnalysed}{values}{_enumeration_range}[0],
                        2);
                    %rangeForPrint = %$range;
                    if( length($$range{min}) == 0 ) {
                        delete $$range{min};
                        $rangeForPrint{min} = '<any>';
                    }
                    if( length($$range{max}) == 0 ) {
                        delete $$range{max};
                        $rangeForPrint{max} = '<any>';
                    }
                }
                CIFVALUE: for my $tagIndex ( 0..$#{$block->{values}{$tagAnalysed}} ) {
                    my $tagValue = $block->{values}{$tagAnalysed}[$tagIndex];
                    next CIFVALUE if $tagValue eq '.' or $tagValue eq '?';
                    my $value = $tagValue;
                    my $sigma = $block->{precisions}{$tagAnalysed}[$tagIndex];
                    #
                    # if check values in enumeration list
                    #
                    if( exists $dictD->{$lc_tagAnalysed} &&
                        exists $dictD->{$lc_tagAnalysed}{values}{_enumeration} ) {
                        my $listEnumValuesForTag = join(', ',
                            @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}}
                        );
                        my $valueFoundInList = 0;
                        my $emulateSet = 0;
                        if(  grep lc($_) eq $lc_tagAnalysed, @{$setOfEnum} ) {
                            $emulateSet = 1;
                            my $setOfEnumValues = join '|',
                               @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}};
                            $setOfEnumValues =~ s/\./\\./;
                            my $regexpSetOfEnumValues = 
                                                 qr/^($setOfEnumValues)+$/s;
                            if( $caseSensitive ) {
                                if( $value =~ m/$regexpSetOfEnumValues/s ) {
                                        $valueFoundInList = 1;
                                }
                            } else {
                                if( $value =~ m/$regexpSetOfEnumValues/is ) {
                                    $valueFoundInList = 1;
                                }
                            }
                        } else {
                            if( $caseSensitive ) {
                                if( grep $_ eq $value, 
                                    @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}} ) {
                                    $valueFoundInList = 1;
                                }
                            } else {
                                my $lcValue = lc $value;
                                if( grep lc($_) eq $lcValue, 
                                    @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}} ) {
                                    $valueFoundInList = 1;
                                }
                           }
                       }

                       if( $valueFoundInList == 0 ) {
                            note( $0, $cifF, $$block{name},
                                  "tag '$tagAnalysed' value \"$value\" " .
                                  "should be one of these: [" .
                                   $listEnumValuesForTag . '] values' );
                       } else {
                            my $message = "tag '$tagAnalysed' value " .
                                          '"' . $value . '" is one of these: ' .
                                          "[$listEnumValuesForTag] values";

                            $message .= ' (case ignored)' if( !$caseSensitive );

                            $message .= ', enum was treated as set'
                                                              if( $emulateSet );

                            if ($debug) {
                                debug_note( $0, $cifF, $$block{name}, $message );
                            }
                     }

                    #
                    # Check if values match the declared types:
                    #
                    if( exists $dictD->{$lc_tagAnalysed} &&
                        defined $dictD->{$lc_tagAnalysed}{values}{_type} &&
                        $dictD->{$lc_tagAnalysed}{values}{_type}[0] eq 'numb' ) {
                        if(defined $block->{types}{$tagAnalysed}) {
                            if('FLOAT' ne $block->{types}{$tagAnalysed}[$tagIndex]
                                && 'INT' ne $block->{types}{$tagAnalysed}[$tagIndex]) {
                                note( $0, $cifF, $$block{name},
                                      "tag '$tagAnalysed' value \"" . 
                                     $block->{values}{$tagAnalysed}[$tagIndex] .
                                     "\" is of type '" .
                                     $block->{types}{$tagAnalysed}[$tagIndex] .
                                     "' while it should be numeric, i.e. " .
                                     "'FLOAT', or 'INT'" );
                            } else {
                                if ( $debug ) {
                                    debug_note( $0, $cifF, $$block{name}, 
                                      "tag '$tagAnalysed' is of type '" .
                                      $block->{types}{$tagAnalysed}[$tagIndex] .
                                      "' as expected, as it should be one of: " .
                                      "'FLOAT', 'INT'" );
                                }
                            }
                        }
                    }

                    #
                    # Check values against enumeration_range
                    #
                    if( %$range ) {
                        my $valueWOPrecision = $value;
                        if( exists $dictD->{$lc_tagAnalysed} &&
                            $dictD->{$lc_tagAnalysed}{values}{_type}[0] 
                            eq 'numb' ) {
                            $valueWOPrecision =~ s/\s*\(.*$//;
                        }
                        if( exists $dictD->{$lc_tagAnalysed} &&
                            checkAgainstRange(
                                $dictD->{$lc_tagAnalysed}{values}{_type}[0],
                                $range, $valueWOPrecision, $sigma) <= 0 ) {
                                note( $0, $cifF, $$block{name},
                                      "tag '$tagAnalysed' value " .
                                      "\"$value\" should be in range (" .
                                      $rangeForPrint{min} .
                                      ', ' . $rangeForPrint{max} . ')' );
                        } else { 
                            if ( $debug ) {
                                 debug_note( $0, $cifF, $$block{name},
                                            "tag '$tagAnalysed' value " .
                                            "\"$value\" is in range (" .
                                            "$rangeForPrint{min}, " .
                                            "$rangeForPrint{max})" );
                            }
                        }
                    } else { 
                        if ( $debug) {
                            debug_note( $0, $cifF, $$block{name},
                                        'there are no range restrictions ' .
                                        "for tag \"$tagAnalysed\" -- " .
                                        "skipping range test" );
                        }
                    }
                }
            }

            }
            if( !$defined ) {
                note( $0, $cifF, $$block{name}, 
                     "tag '$tagAnalysed' was not found in dictionaries" );
            }
        }
    }
}

#
# here goes all subroutines bodies
#
sub VersionMessage
{
print <<END_M;
cif_validate (using CIFParser v.$COD::CIFParser::CIFParser::version) v.$version

END_M
}

# Return a string that describes "severity level" in a human readable
# form (for discussions of severity levels, see
# ../doc/error-levels.txt.

sub severityName($)
{
    my $severity = $_[0];

    if( $severity & 1 ) {
        return "ERROR";
    } elsif( $severity & 2 ) {
        return "WARNING";
    } elsif( $severity & 4 ) {
        return "NOTE";
    } elsif( $severity & 8 ) {
        return "INFO-ERROR";
    } elsif( $severity & 16 ) {
        return "INFO-WARNING";
    } elsif( $severity & 32 ) {
        return "INFO-NOTICE";
    } elsif( $severity & 64 ) {
        return "INFO-INDICATOR";
    } else {
        return "ERROR-LEVEL=$severity";
    }
}

sub getDict
{
    my $dictF = shift;
    my $tags = {};
    my $datan = 0;
    while( $datan < @$dictF ) {
        $datan++ and next if
            !exists $$dictF[$datan]{values}{_type};
        for ( @{$$dictF[$datan]{values}{_name}} ) {
            $$tags{lc $_} = $$dictF[$datan];
        }
        $datan++;
    }
    return $tags;
}

sub checkAgainstRange
{
    my $type  = shift; # char or numb
    my $range = shift;
    my $value = shift;
    my $sigma = shift;
    if( !exists $$range{min} &&
        !exists $$range{max} ) {
        return -1;
    }
    if( $type eq 'numb' ) {
        return checkAgainstRangeNumb( $range, $value, $sigma );
    } else {
        return checkAgainstRangeChar( $range, $value );
    }
    return 0;
}

sub checkAgainstRangeNumb
{
    my ( $range, $value, $sigma ) = @_;

    if( ! Scalar::Util::looks_like_number($value) ) {
        return 0;
    }

    my ($min,$max);

    if( defined $sigma ) {
        $min = $$range{min} - 3 * $sigma if exists $$range{min};
        $max = $$range{max} + 3 * $sigma if exists $$range{max};
    } else {
        $min = $$range{min} if exists $$range{min};
        $max = $$range{max} if exists $$range{max};
    }

    if(
        ( !defined $max || $value <= $max )
        &&
        ( !defined $min || $value >= $min )
    ) {
        return 1;
    }
    return 0;
}

sub checkAgainstRangeChar
{
    my ( $range, $value ) = @_;

    if(
        ( !exists $$range{max} || $value le $$range{max} )
        &&
        ( !exists $$range{min} || $value ge $$range{min} )
    ) {
        return 1;
    }
    return 0;
}

sub getRelatedMandatory
{
    my ( $dict, $tag, $reccurentCall ) = @_;

    $tag = lc $tag;
    my $requeryTag = undef;
    if( !exists $dict->{$tag} ) {
        return undef;
    }
    if( defined $reccurentCall
        && exists $dict->{$tag}{values}{_list_mandatory}
        && $dict->{$tag}{values}{_list_mandatory}[0] eq 'yes' ) {
        return $tag;
    }
    if( exists $dict->{$tag}{values}{_list_reference} ) {
        $requeryTag = $dict->{$tag}{values}{_list_reference}[0];
    }
    if( !defined $requeryTag ) {
        return undef;
    }
    return getRelatedMandatory( $dict, $requeryTag, 1 );
}
