#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;

#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Parse CIF file(s) and CIF dictionary(ies).
#  Check CIF file against CIF dictionaries.
#**

#
# here we link libraries
#
use strict;
use warnings;
use Scalar::Util;
use COD::CIFParser::CIFParser;
use COD::CIFTags::CIFTagCanonicalNames;
use COD::ShowStruct;
use COD::SOptions;
use COD::SUsage;
use COD::UserMessage;

#
# here we define variables
#        first - constant values
#        then  - common variables
#
my $version = 0.1;

my $CIFfile = ();
my $CIFtags;
my $dictFiles = [];
my $setOfEnum = [];
my $dictFilesParsed = [];
my $dictTags = {};
my $quiet = 0;
my $use_parser = "perl";
my $errorLevel = 4;
my $caseSensitive = 1;
my $checkLocalTags = 0;
#
# We read user requested options into an array-ref in this case user can 
# define '--check' many times with different or same options, that are 
# parsed later.
#
my $outputOptions = [];
#
# Errors reporting and CIF validation is performed according to this 
# hash entries.
# All possible options MUST be listed here, because no checking whereas 
# option exists will be made (it MUST be NOT necessary).
# NOTE: please update 'HelpMessage' subroutine when adding new option, 
# so that user would know what options are possible.
# TODO: 'errorLevel' and 'quiet' options must be removed later in 
# accordance to this option. Some 'debug' option might be created, to 
# report more information than it is necessary to understand validation 
# errors.
#
my %showMap = (
        #
        # some private tags
        '_debug'             => 1,
        #
        # tag name checking related options
        'tag-exists-local'   => 0,
        'tag-deprecated'     => 0,
        #
        # value checking related options
        'values-enum-nocase' => 0,
        'value-type'         => 1,
        'values-range'       => 1
    );

#
# here we declare subroutines
#

# subroutine to print module version and copyright notice
sub VersionMessage;

# subroutine to print validation message (for SPOT purposes)
# list of arguments:
#     1. severity level (# ../doc/error-levels.txt)
#     2. CIF file analysed
#     3. CIF data block analysed
#     4. error message experienced
sub showValidationMessage;

# subroutine to extract tags from dictionary (parsed using CIFParser)
# it takes reference to CIFParser output
# returns hash of tags and related references to parsed data blocks
sub getDict;

# subroutine to check value against range (defined in dictionary)
# Arguments:
#   1. type of value (numb or char);
#   2. reference to range as $$range{min} and $$range{max};
#   3. value, that must be checked.
sub checkAgainstRange;

# subroutine to check number value against range (defined in dictionary)
# Arguments:
#   1. reference to range as $$range{min} and $$range{max};
#   2. value, that must be checked.
sub checkAgainstRangeNumb;

# subroutine to check character value against range (defined in dictionary)
# Arguments:
#   1. reference to range as $$range{min} and $$range{max};
#   2. value, that must be checked.
sub checkAgainstRangeChar;

# subroutine to return name of closest (according to dictionary) 
#     mandatory tag, if applicable. Return undef, if no mandatory tag is 
#     related to tag analysed
# Arguments:
#   1. reference to dictionary
#   2. lowercased name of currently analysed tag
sub getRelatedMandatory;

#
# main program code
#

# Treat '_atom_site_refinement_flags' by default, as it is so documented 
# in CIF core dictionary.
push @$setOfEnum, '_atom_site_refinement_flags';

#** OPTIONS:
#** --dictionary cif_core.dic // adds a new dict --add-dictionary | --dictionaries priima tarpais ar kableliais priskirtus
#**                     Any valid CIF file, with CIF dictionary (according 
#**                     to DDL2). You can define any number of CIF 
#**                     dictionaries, in a way like this:
#**                     $0 --dictionary cif_core.dic --dictionary cod_core.dic
#** --quiet
#**                     Minimize program output.
#** --no-quiet, --not-quiet, --verbose
#**                     Maximize program output.
#** --version
#**                     Print version message and exits.
#** --help, --usage
#**                     Print short usage message (this message) and exit.
#** --treat-as-set, --set-of-enum
#**                     If tag name is given to this parameter and tag 
#**                     specified has some enumeration values to check 
#**                     against, they are treated as set, i.e. more than one 
#**                     of enumeration values could be defined for one single 
#**                     element. By default it is turned on for tag 
#**                     '_atom_site_refinement_flags', which is documented as 
#**                     set, but only in it's description.
#** --no-treat-as-set, --no-set-of-enum //dont-treat-as-set
#**                     This parameter turns off all so far defined exceptions, 
#**                     that emulates enumeration treating as set 
#                       (see --treat-as-set).
#** --check-tag-deprecated
#**                     Turn on test 'tag-deprecated'. This test checks 
#**                     whereas tag was not replaced by new one.
#** --do-not-check-tag-deprecated
#**                     Turn off test 'tag-deprecated'. Default.
#** --do-not-check-tag-exists
#**                     Turn off test 'tag-exists'.
#** --check-local-tags
#**                     Turn on test 'tag-exists-local'. This test enforces 
#**                     check of tags marked as local, i.e. 
#**                     _[local]_cod_depositor_comments. Otherwise these tags 
#**                     are ignored.
#** --no-check-local-tags, --ignore-local-tags
#**                     Turn off test 'tag-exists-local'. Default.
#** --ignore-case
#**                     Turn on tests 'values-enum-nocase' and 'values-enum'.
#**                     This is a test option, indicating that case must be 
#**                     ignored, while checking them against list 
#**                     (see 'values-enum'). This option is only actual if 
#**                     values-enum test is ON. I.e. '_atom_site_adp_type'
#**                     is restricted to values ('Uani', 'Uiso', 'Uovl', ...) 
#**                     and 'UANI' would be incorrect, if values-enum-nocase 
#**                     is turned off.
#** --dont-ignore-case, --respect-case, --case-sensitive
#**                     Turn off test 'values-enum-nocase'. Default.
#** --use-perl-parser
#**             Use Perl parser to parse CIF files. Default option.
#** --use-c-parser
#**             Use C parser to parse CIF files.

# check parameters passed
@ARGV = getOptions(
        "--dictionary"
            => $dictFiles,
        "--treat-as-set,--set-of-enum"
            => $setOfEnum,
        "--no-treat-as-set,--no-set-emulation"
            => sub{ $setOfEnum = [] },
        "--version"
            => sub{ VersionMessage() },
        "--quiet"
            => sub{ $errorLevel *= 2; },
        "--no-quiet,--not-quiet,--verbose"
            => sub{ $errorLevel /= 2; },
        "--help"
            => sub{ usage; exit; },
        # turn on check options
        "--check-all"
            => sub{ while ( my($k,$v) = each(%showMap) ) {
                        $showMap{$k} = 1;
                    }
                  },

        "--check-local-tags"        => sub{ $checkLocalTags = 1 },
        "--no-check-local-tags"     => sub{ $checkLocalTags = 0 },
        "--ignore-local-tags"       => sub{ $checkLocalTags = 0 },

        "--check-tag-deprecated"     => sub{ $showMap{'tag-deprecated'} = 1 },
        "--ignore-case"                     => sub{ $caseSensitive = 0 },
        "--dont-ignore-case,--respect-case" => sub{ $caseSensitive = 1 },
        "--case-sensitive"                  => sub{ $caseSensitive = 1 },
        "--check-values-range"       => sub{ $showMap{'values-range'} = 1 },
        "--check-value-type"         => sub{ $showMap{'values-enum'} = 1;
                                             $showMap{'value-type'} = 1 },
        # turn off check options
        "--check-none"
            => sub{ while ( my($k,$v) = each(%showMap) ) {
                        $showMap{$k} = 0;
                    }
                  },
        "--do-not-check-tag-deprecated"     => sub{ $showMap{'tag-deprecated'} = 0 },
        "--do-not-check-values-range"       => sub{ $showMap{'values-range'} = 0 },
        "--do-not-check-value-type"         => sub{ $showMap{'value-type'} = 0 },
        "--use-perl-parser"                 => sub{ $use_parser = "perl" },
        "--use-c-parser"                    => sub{ $use_parser = "c" },
    );

if( @$dictFiles )
{
    DICTFILE: for( @{$dictFiles} ) {
        my $parsed;
        if( $use_parser eq "perl" ) {
            my $parser = new COD::CIFParser::CIFParser;
            $parsed = $parser->Run( $_ );
            next DICTFILE if $parsed == 1;
        } else {
            require COD::CCIFParser::CCIFParser;
            my $error_count;
            ( $parsed, $error_count ) = COD::CCIFParser::CCIFParser::parse( $_ );
            next DICTFILE if $error_count > 0;
        }
        push( @$dictFilesParsed, $parsed );
        $$dictTags{$_} = getDict( $parsed );
        undef $parsed;
    }
    if( keys( %$dictTags ) == 0 ) {
        print_message( $0, undef, undef, undef,
                       join( ",", @$dictFiles ) .
                       ': No tags were defined in dictionaries.' );
        exit 1;
    }
} else {
    die "You must specify dictionary using '--dictionary'. Automatic "
            . "dictionary download is not implemeted yet.\n";
    my $dictIUCRURI = "ftp://ftp.iucr.org/pub/cif_core.dic";
}

@ARGV = ("-") unless @ARGV;

#
# start-iterate-trough-CIF-files
#
CIFFILEANAL: for my $cifF ( @ARGV ) {
    my $data;
    if( $use_parser eq "perl" ) {
        my $parser = new COD::CIFParser::CIFParser;
        $data = $parser->Run( $cifF );
    } else {
        $data = COD::CCIFParser::CCIFParser::parse( $cifF );
    }
    # convert all tags to a "cannonical" form (the one used in the
    # CIFTags modules ;):
    canonicalize_all_names( $data );
    next CIFFILEANAL if ( !defined $data || $data == 1 );
    #
    # start-iterate-trough-CIF-file-data-blocks
    #    
    for my $block ( @$data ) {
        if( $quiet == 0 ) {
            showValidationMessage 64, $cifF, $$block{name}, 'analysis start';
        }
        #
        # hash tagsListedInLoops
        # If a tag (key is lowercased tag name) appears in this hash it 
        # means, that it must appear within loop.
        # Value is enum('yes', 'no'). Depending on this we know, whereas 
        # tag was correctly (i.e. together with other tags) defined 
        # within some loop.
        #
        my %tagsListedInLoops;
        #
        # hash baseNamesOfRefTags
        # A tag listed in this hash depends on some other loop_ tag, and
        # is correctly referenced (parent tag is defined within same 
        # loop). Value is enum('yes', 'no').
        #
        my %baseNamesOfRefTags;
        #
        # start-iterate-trough-CIF-values
        #
        for my $tagAnalysed ( @{$block->{tags}} ) {
            if(!defined $block->{types}{$tagAnalysed}) {
                showValidationMessage 64, 
                    $cifF, $$block{name},
                    "tag '" . $tagAnalysed . "' has no associated type"
                    . ' which, probably, means that error in CIFParser occured';
            }
            my $lc_tagAnalysed = lc $tagAnalysed;
            my $defined = 0;
            if( ! $checkLocalTags && $lc_tagAnalysed =~ m/^_\[local\]/ ) {
                ++$defined;
            }
            my $correctDataType = 0;
            #
            # start-iterate-through-dictionaries
            #
            while( my($dictF, $dictD) = each %$dictTags ) {
                # check tags
                if( exists $$dictD{$lc_tagAnalysed} ) {
                    $defined++;
                    showValidationMessage 64, $cifF, 
                            $$block{name}, "tag '" . $tagAnalysed . "'"
                            . ' do exist in dictionary ' . $dictF;
                } else {
                    showValidationMessage 16, $cifF, 
                        $$block{name}, "tag '" . $tagAnalysed . "'"
                        . ' does not exist in dictionary ' . $dictF;
                }

                # check tags deprecation (replacements)
                if( $showMap{'tag-deprecated'} ) {
                    if( exists $dictD->{$lc_tagAnalysed} &&
                        exists $dictD->{$lc_tagAnalysed}{values}{_related_item}) {
                        my $replaceWith = [];
                        for( my $i = 0;
                            $i < @{$dictD->{$lc_tagAnalysed}{values}{_related_item}};
                            $i++ )
                            {
                            if($dictD->{$lc_tagAnalysed}{values}{_related_function}[$i]
                                eq 'replace') {
                                push @{$replaceWith},
                                    $dictD->{$lc_tagAnalysed}{values}{_related_item}[$i];
                            }
                        }
                        if( @$replaceWith != 0 ) {
                            showValidationMessage 8, 
                                $cifF, $$block{name},
                                "tag '" . $tagAnalysed . "' has been"
                                . ' replaced by tag(-s): ['
                                . join(', ', @$replaceWith)
                                . '] according to ' . $dictF;
                        }
                    }
                }

                # check referenced list mandatory
                my $mandatoryRTag = getRelatedMandatory($dictD, $lc_tagAnalysed);
                if( defined $mandatoryRTag
                    && !exists($baseNamesOfRefTags{$mandatoryRTag})
                 ) {
                   for my $loopAnalysed ( @{$block->{loops}} ) {
                    if( grep $_ eq $tagAnalysed, @{$loopAnalysed} ) {
                        if( grep lc($_) eq $mandatoryRTag, @{$loopAnalysed} ) {
                            showValidationMessage 64,
                            $cifF, $$block{name}, "tag '" . $mandatoryRTag
                            . "' is mandatory in loop when tag(s) ["
                            . join(', ', 
                            @{$dictD->{$lc_tagAnalysed}{values}{_name}})
                            . '] are defined according to ' . $dictF
                            . ' and was found';
                            $baseNamesOfRefTags{$mandatoryRTag} = 'yes';
                            last;
                        } else {
                            showValidationMessage 4, 
                            $cifF, $$block{name},
                            "tag '" . $mandatoryRTag
                            . "' is mandatory in loop when tag(s) ["
                            . join(', ', 
                            @{$dictD->{$lc_tagAnalysed}{values}{_name}})
                            . '] are defined according to ' . $dictF
                            . ' but was not found';
                            $baseNamesOfRefTags{$mandatoryRTag} = 'no';
                            last;
                        }
                    }
                 }
                }
                # check list mandatory
                if( exists $dictD->{$lc_tagAnalysed}
                    && exists $dictD->{$lc_tagAnalysed}{values}{_list}
                    && $dictD->{$lc_tagAnalysed}{values}{_list}[0] eq 'yes' )
                {
                    if( exists $block->{inloop}{$tagAnalysed} ) {
                        showValidationMessage 64,  $cifF, 
                            $$block{name}, "tag '" . $tagAnalysed . 
                            "' must be in a loop" . " according to $dictF " . 
                            "and is in a loop";
                        } else {
                            showValidationMessage 4, 
                                $cifF, $$block{name},
                                "tag '" . $tagAnalysed . "' must be in a loop"
                                . " according to $dictF but is not in a loop";
                        }
                }
                # check types of values
                my $range = {};
                my %rangeForPrint;
                if( exists $dictD->{$lc_tagAnalysed} &&
                    exists $dictD->{$lc_tagAnalysed}{values}{_enumeration_range} ) {
                    ($$range{min}, $$range{max}) = split(/:/, 
                        $dictD->{$lc_tagAnalysed}{values}{_enumeration_range}[0],
                        2);
                    %rangeForPrint = %$range;
                    if( length($$range{min}) == 0 ) {
                        delete $$range{min};
                        $rangeForPrint{min} = '<any>';
                    }
                    if( length($$range{max}) == 0 ) {
                        delete $$range{max};
                        $rangeForPrint{max} = '<any>';
                    }
                }
                CIFVALUE: for my $tagIndex ( 0..$#{$block->{values}{$tagAnalysed}} ) {
                    my $tagValue = $block->{values}{$tagAnalysed}[$tagIndex];
                    next CIFVALUE if $tagValue eq '.' or $tagValue eq '?';
                    my $value = $tagValue;
                    my $sigma = $block->{precisions}{$tagAnalysed}[$tagIndex];
                    #
                    # if check values in enumeration list
                    #
                    if( exists $dictD->{$lc_tagAnalysed} &&
                        exists $dictD->{$lc_tagAnalysed}{values}{_enumeration} ) {
                        my $listEnumValuesForTag = join(', ',
                            @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}}
                        );
                        my $valueFoundInList = 0;
                        my $emulateSet = 0;
                        if(  grep lc($_) eq $lc_tagAnalysed, @{$setOfEnum} ) {
                            $emulateSet = 1;
                            my $setOfEnumValues = join '|',
                               @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}};
                            $setOfEnumValues =~ s/\./\\./;
                            my $regexpSetOfEnumValues = 
                                                 qr/^($setOfEnumValues)+$/s;
                            if( $caseSensitive ) {
                                if( $value =~ m/$regexpSetOfEnumValues/s ) {
                                        $valueFoundInList = 1;
                                }
                            } else {
                                if( $value =~ m/$regexpSetOfEnumValues/is ) {
                                    $valueFoundInList = 1;
                                }
                            }
                        } else {
                            if( $caseSensitive ) {
                                if( grep $_ eq $value, 
                                    @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}} ) {
                                    $valueFoundInList = 1;
                                }
                            } else {
                                my $lcValue = lc $value;
                                if( grep lc($_) eq $lcValue, 
                                    @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}} ) {
                                    $valueFoundInList = 1;
                                }
                           }
                       }

                       if( $valueFoundInList == 0 ) {
                        showValidationMessage 4, 
                                    $cifF, $$block{name},
                                    "tag '" . $tagAnalysed . "' value "
                                    . '"'. $value . '" should be one of '
                                    . "these: ["
                                    . $listEnumValuesForTag . '] values';
                       } else {
                            my $message = "tag '" . $tagAnalysed
                                    . "' value "
                                    . '"'
                                    . $value
                                    . '" is one of these: ['
                                    . $listEnumValuesForTag
                                    . '] values';
                            if( !$caseSensitive ) {
                                $message .= ' (case ignored)';
                            }

                            if( $emulateSet ) {
                                $message .= ', enum was treated as set';
                            }

                            showValidationMessage 24, 
                                $cifF, $$block{name}, $message;
                                undef $message;
                     }

                    #
                    # Check if values match the declared types:
                    #
                    if( $showMap{'value-type'} ) {
                        if( exists $dictD->{$lc_tagAnalysed} &&
                            defined $dictD->{$lc_tagAnalysed}{values}{_type} &&
                            $dictD->{$lc_tagAnalysed}{values}{_type}[0] eq 'numb' ) {
                            if(defined $block->{types}{$tagAnalysed}) {
                                if('FLOAT'  ne $block->{types}{$tagAnalysed}[$tagIndex]
                                   && 'INT' ne $block->{types}{$tagAnalysed}[$tagIndex]) {
                                    showValidationMessage 4, 
                                    $cifF, $$block{name},
                                    "tag '" . $tagAnalysed . "' " .
                                        "value \"" . 
                                        $block->{values}{$tagAnalysed}[$tagIndex] .
                                        "\" " .
                                        "is of type "
                                        . "'"
                                        . $block->{types}{$tagAnalysed}[$tagIndex]
                                        . "' while it should be numeric, i.e. 'FLOAT', or 'INT'";
                                } else {
                                    showValidationMessage 64, 
                                    $cifF, $$block{name},
                                    "tag '" . $tagAnalysed . "' is of type "
                                        . "'"
                                        . $block->{types}{$tagAnalysed}[$tagIndex]
                                        . "' as expected, as it should be one of: 'FLOAT', 'INT'";
                                }
                            }
                        }
                    }
                    
                    #
                    # Check values against enumeration_range
                    #
                    if( $showMap{'values-range'} ) {
                        if( %$range ) {
                            my $valueWOPrecision = $value;
                            if( exists $dictD->{$lc_tagAnalysed} &&
                                $dictD->{$lc_tagAnalysed}{values}{_type}[0] 
                                eq 'numb' ) {
                                $valueWOPrecision =~ s/\s*\(.*$//;
                            }
                            if( exists $dictD->{$lc_tagAnalysed} &&
                                checkAgainstRange(
                                    $dictD->{$lc_tagAnalysed}{values}{_type}[0],
                                    $range, $valueWOPrecision, $sigma) <= 0 ) {
                                showValidationMessage 4, 
                                    $cifF, $$block{name},
                                    "tag '" . $tagAnalysed . "' value "
                                    . '"'
                                    . $value
                                    . '" should be in range ('
                                    .  $rangeForPrint{min}
                                    . ', ' . $rangeForPrint{max} . ')';
                            } else {
                                    showValidationMessage 64, $cifF, 
                                        $$block{name},
                                        "tag '" . $tagAnalysed . "'"
                                        . ' value '
                                        . '"'
                                        . $value
                                        . '" is in range ('
                                        . $rangeForPrint{min}
                                        . ', '
                                        . $rangeForPrint{max}
                                        . ')';
                            }
                        } else {
                            showValidationMessage 64, 
                                $cifF, $$block{name},
                                'there are no range restrictions'
                                . " for tag '"
                                . $tagAnalysed
                                . "', skipping range test";
                        }
                    }
                    #
                    # end-if check values against enumeration_range
                    #
                }
                }
                # end-if check types of values
                
                # -----------------------------------------------------
                # -----------------------------------------------------
                # -----------------------------------------------------
            }
            #
            # end-iterate-through-dictionaries
            #
            if( !$defined ) {
                showValidationMessage 4, $cifF, $$block{name}, 
                     "tag '$tagAnalysed' was not found in dictionaries";
            }
            
        }
        #
        # end-iterate-trough-CIF-values
        #
    }
    #
    # end-iterate-trough-CIF-file-data-blocks
    #    
}
#
# end-iterate-trough-CIF-files
#    

#
# here goes all subroutines bodies
#

sub VersionMessage
{
        print <<END_M;
cif_check_dict (using CIFParser v.$COD::CIFParser::CIFParser::version) v.$version
Copyright (C) 2007 ???
This is free software. You may redistribute copies of it under the terms of
the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
There is NO WARRANTY, to the extent permitted by law.

Written by Justas Butkus.

NOTICE: this is a development version.
Any interfaces are a matter to change.
Please be careful not to include it in any public system, or carefully 
revise in case of updates.

END_M
    exit 0;
}

# Return a string that describes "severity level" in a human readable
# form (for discussions of severity levels, see
# ../doc/error-levels.txt.

sub severityName($)
{
    my $severity = $_[0];

    if( $severity & 1 ) {
        return "ERROR";
    } elsif( $severity & 2 ) {
        return "WARNING";
    } elsif( $severity & 4 ) {
        return "NOTE";
    } elsif( $severity & 8 ) {
        return "INFO-ERROR";
    } elsif( $severity & 16 ) {
        return "INFO-WARNING";
    } elsif( $severity & 32 ) {
        return "INFO-NOTICE";
    } elsif( $severity & 64 ) {
        return "INFO-INDICATOR";
    } else {
        return "ERROR-LEVEL=$severity";
    }
}

sub showValidationMessage {
    my ($severity, $file, $dataBlockName, $message)
        = (shift, shift, shift, shift);
    if( $severity > $errorLevel ) {
        return 0;
    }

    $message =~ s/\n/\\n/g;
    my $formatted =
        sprint_message( $0, $file, $dataBlockName,
                                     (defined $severity
                                        ? severityName( $severity )
                                        : undef),
                                     $message );
    $formatted =~ s/\.?\n$/\n/;
    print $formatted;

}

sub getDict
{
        my $dictF = shift;
        my $tags = {};
        my $datan = 0;
           while( $datan < @$dictF )
    {
        $datan++ and next if
            !exists $$dictF[$datan]{values}{_type};
        for ( @{$$dictF[$datan]{values}{_name}} ) {
            $$tags{lc $_} = $$dictF[$datan];
        }
        $datan++;
        }
        return $tags;
}

sub checkAgainstRange {
    my $type  = shift; # char or numb
    my $range = shift;
    my $value = shift;
    my $sigma = shift;
    if( !exists $$range{min} &&
        !exists $$range{max} ) {
        return -1;
    }
    if( $type eq 'numb' ) {
        return checkAgainstRangeNumb( $range, $value, $sigma );
    } else {
        return checkAgainstRangeChar( $range, $value );
    }
    return 0;
}

sub checkAgainstRangeNumb {
    my $range = shift;
    my $value = shift;
    my $sigma = shift;
    if( ! Scalar::Util::looks_like_number($value) ) {
        return 0;
    }

    my ($min,$max);

    if( defined $sigma ) {
        $min = $$range{min} - 3 * $sigma if exists $$range{min};
        $max = $$range{max} + 3 * $sigma if exists $$range{max};
    } else {
        $min = $$range{min} if exists $$range{min};
        $max = $$range{max} if exists $$range{max};
    }

    if(
        ( !defined $max || $value <= $max )
        &&
        ( !defined $min || $value >= $min )
    ) {
        return 1;
    }
    return 0;
}

sub checkAgainstRangeChar {
    my $range = shift;
    my $value = shift;
    if(
        ( !exists $$range{max} || $value le $$range{max} )
        &&
        ( !exists $$range{min} || $value ge $$range{min} )
    ) {
        return 1;
    }
    return 0;
}

sub getRelatedMandatory {
    my $dict = shift;
    my $tag = shift;
    $tag = lc $tag;
    my $reccurentCall = shift;
    my $requeryTag = undef;
    if( !exists $dict->{$tag} ) {
        return undef;
    }
    if( defined $reccurentCall
        && exists $dict->{$tag}{values}{_list_mandatory}
        && $dict->{$tag}{values}{_list_mandatory}[0] eq 'yes' ) {
        return $tag;
    }
    if( exists $dict->{$tag}{values}{_list_reference} ) {
        $requeryTag = $dict->{$tag}{values}{_list_reference}[0];
    }
    if( !defined $requeryTag ) {
        return undef;
    }
    return getRelatedMandatory $dict, $requeryTag, 1;
}
