#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;

#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Parse CIF file(s) and CIF dictionary(ies).
#  Check CIF file against CIF dictionaries.
#**

use strict;
use warnings;
use Scalar::Util;
use COD::CIFParser::CIFParser;
use COD::CIFTags::CIFTagCanonicalNames;
use COD::ShowStruct;
use COD::SOptions;
use COD::SUsage;
use COD::UserMessage qw( note warning error debug_note );

#
# here we define variables
#        first - constant values
#        then  - common variables
#
my $version = 0.1;

my $CIFfile = ();
my $CIFtags;
my @dictFiles;
my $setOfEnum = [];
my $dictFilesParsed = [];
my $dictTags = {};
my $verbose  = 1;
my $use_parser = "perl";
my $caseSensitive    = 1;
my $reportLocalTags  = 0;
my $reportDeprecated = 0;
my $debug = 0;

# TODO: 'errorLevel' and 'quiet' options must be removed later in 
# accordance to this option. Some 'debug' option might be created, to 
# report more information than it is necessary to understand validation 
# errors.
#
sub VersionMessage();
sub severityName($);
sub getDict($);
sub checkAgainstRange($$$$);
sub checkAgainstRangeNumb($$$);
sub checkAgainstRangeChar($$);
sub getRelatedMandatory($$$);

# Treat '_atom_site_refinement_flags' by default, as it is so documented 
# in CIF core dictionary.
push @$setOfEnum, '_atom_site_refinement_flags';

#** OPTIONS:
#** -d, --dictionaries "cif_core.dic,cif_cod.dic"
#**                     A list of CIF dictionary files (according to DDL2)
#**                     to be used in CIF file validation. List elements
#**                     are separated by either by "," or by " ". To include
#**                     dictionaries with filenames containing these symbols,
#**                     the --add-dictionary option is used.
#** -D, --add-dictionary "cif new dictionary.dic"
#**                     Add additional CIF dictionary to the list.
#** --clear-dictionaries
#**                     Remove all CIF dictionaries from the list.
#** --treat-as-set _atom_site_refinement_flags
#**                     Treat values of given tags as a set. For example,
#**                     more than one enumeration value could be defined
#**                     for a single element. Any number of tags can be
#**                     provided in the following way:
#**                     $0 --treat-as-set _tag_1 --treat-as-set _tag_2
#**                     Default is the '_atom_site_refinement_flags' tag.
#** --no-treat-as-set, dont-treat-as-set
#**                     Do not treat values of any tags as sets.
#**                     (see --treat-as-set).
#** --report-local-tags
#**                     Validate tags prefixed with '_[local]'. This prefix
#**                     was used in COD to denote locally used tags prior to
#**                     the creation of cif_cod.dic. The default is to ignore
#**                     these tags.
#** --no-report-local-tags, --ignore-local-tags
#**                     Ignore tags prefixed with '_[local]'. Default.
#** --ignore-case
#**                     Ignore letter case while validating enumeration values.
#**                     For example, even though '_atom_site_adp_type' is
#**                     restricted to values ('Uani', 'Uiso', 'Uovl', ...),
#**                     value 'UANI' would still be treated as valid.
#** --respect-case, --case-sensitive, --dont-ignore-case
#**                     Respect letter case while validating enumeration 
#**                     values. Default.
#** --report-deprecated
#**                     Report tags that are marked as deprecated in the 
#**                     dictionaries. Tag deprecation usually means that it 
#**                     has been replaced with an another tag(s).
#** --ignore-deprecated
#**                     Do not report tags that are marked as deprecated in the 
#**                     dictionaries. Default.
#** --use-perl-parser
#**                     Use Perl parser to parse CIF files. Default option.
#** --use-c-parser
#**                     Use C parser to parse CIF files.
#** --quiet
#**                     Minimize program output.
#** --no-quiet, --not-quiet, --verbose
#**                     Maximize program output.
#** --debug
#**                     Output extra information for debugging purposes.
#** -v, --version
#**                     Print version message and exits.
#** --help, --usage
#**                     Print short usage message (this message) and exit.

# check parameters passed
@ARGV = getOptions(
        "-d,--dictionaries"    => sub{ @dictFiles = split( ',|\s+', &get_value );},
        "-D,--add-dictionary"  => sub{ push( @dictFiles, &get_value ); },
        "--clear-dictionaries" => sub{ @dictFiles = (); },

        "--treat-as-set"                    => $setOfEnum,
        "--no-treat-as-set"                 => sub{ $setOfEnum = [] },

        "--ignore-case"                     => sub{ $caseSensitive = 0 },
        "--dont-ignore-case,--respect-case" => sub{ $caseSensitive = 1 },
        "--case-sensitive"                  => sub{ $caseSensitive = 1 },

        "--report-local-tags"               => sub{ $reportLocalTags = 1 },
        "--no-report-local-tags"            => sub{ $reportLocalTags = 0 },
        "--ignore-local-tags"               => sub{ $reportLocalTags = 0 },

        "--report-deprecated"               => sub{ $reportDeprecated = 1},
        "--ignore-deprecated"               => sub{ $reportDeprecated = 0},

        "--quiet"                           => sub{ $verbose = 0 },
        "--verbose,--no-quiet,--not-quiet"  => sub{ $verbose = 1 },

        "--use-perl-parser"                 => sub{ $use_parser = "perl" },
        "--use-c-parser"                    => sub{ $use_parser = "c" },

        "-v,--version"      => sub{ VersionMessage(), exit; },
        "--help,--usage"    => sub{ usage; exit; },
        "--debug"           => sub{ $debug = 1 }
    );

if( @dictFiles ) {
    my $tag_count = 0;
    foreach ( @dictFiles ) {
        my $parsed;
        if( $use_parser eq "perl" ) {
            my $parser = new COD::CIFParser::CIFParser;
            $parsed = $parser->Run( $_ );
            next if $parsed == 1;
        } else {
            require COD::CCIFParser::CCIFParser;
            my $error_count;
            ( $parsed, $error_count ) = COD::CCIFParser::CCIFParser::parse( $_ );
            next if $error_count > 0;
        }
        push( @$dictFilesParsed, $parsed );
        $$dictTags{$_} = getDict( $parsed );
        if ( scalar( keys( $$dictTags{$_} ) ) == 0 ) {
            warning( $0, $_, undef, "no tag definitions found." )
        }
        $tag_count += scalar( keys( $$dictTags{$_} ) );
    }

    if( ! $tag_count ) {
        error( $0, undef, undef, 'no tag definitions were ' .
               "found in the provided dictionary files ('" .
                join( "', '", @dictFiles ) . "')" );
        exit 1;
    }
} else {
    error( $0, undef, undef, "at least one dictionary file should be " .
           "provided by using the '--dictionaryies' option. Automatic " .
           "dictionary download is not implemeted yet." );
    my $dictIUCRURI = "ftp://ftp.iucr.org/pub/cif_core.dic";
    exit 1;
}

@ARGV = ("-") unless @ARGV;

#
# start-iterate-through-CIF-files
#
CIFFILEANAL: for my $cifF ( @ARGV ) {
    my $data;
    if( $use_parser eq "perl" ) {
        my $parser = new COD::CIFParser::CIFParser;
        $data = $parser->Run( $cifF );
    } else {
        $data = COD::CCIFParser::CCIFParser::parse( $cifF );
    }
    # convert all tags to a "cannonical" form (the one used in the
    # CIFTags modules ;):
    canonicalize_all_names( $data );
    next CIFFILEANAL if ( !defined $data || $data == 1 );
    #
    # start-iterate-trough-CIF-file-data-blocks
    #
    for my $block ( @$data ) {
        if( $debug ) {
            debug_note( $0, $cifF, $$block{name}, 'analysis start' );
        }
        #
        # hash tagsListedInLoops
        # If a tag (key is lowercased tag name) appears in this hash it 
        # means, that it must appear within loop.
        # Value is enum('yes', 'no'). Depending on this we know, whereas 
        # tag was correctly (i.e. together with other tags) defined 
        # within some loop.
        #
        my %tagsListedInLoops;
        #
        # hash baseNamesOfRefTags
        # A tag listed in this hash depends on some other loop_ tag, and
        # is correctly referenced (parent tag is defined within same 
        # loop). Value is enum('yes', 'no').
        #
        my %baseNamesOfRefTags;
        #
        # start iteration through CIF values
        #
        for my $tagAnalysed ( @{$block->{tags}} ) {
            if(!defined $block->{types}{$tagAnalysed}) {
                if ( $debug ) {
                    warning( $0, $cifF, $$block{name},
                      "tag '$tagAnalysed' has no associated type which," .
                      'probably, means that error in CIFParser had occured' );
                }
            }
            my $lc_tagAnalysed = lc $tagAnalysed;
            my $defined = 0;
            if( ! $reportLocalTags && $lc_tagAnalysed =~ m/^_\[local\]/ ) {
                ++$defined;
            }
            #
            # start-iterate-through-dictionaries
            #
            while( my($dictF, $dictD) = each %$dictTags ) {
                # check if tags are defined in the dictionary
                if( exists $$dictD{$lc_tagAnalysed} ) {
                    $defined = 1;
                    if ( $debug ) {
                      debug_note( $0, $cifF, $$block{name},
                      "tag '$tagAnalysed' is defined in dictionary $dictF" );
                    }
                } else {
                    if ( $debug ) {
                      debug_note( $0, $cifF, $$block{name},
                      "tag '$tagAnalysed' is not defined in dictionary $dictF" );
                    }
                    next;
                }

                # check if tags are deprecated (replaced with other tags)
                if( exists $$dictD{$lc_tagAnalysed} &&
                    exists $dictD->{$lc_tagAnalysed}{values}{_related_item}) {
                    my $replaceWith = [];
                    for( my $i = 0;
                         $i < @{$dictD->{$lc_tagAnalysed}{values}{_related_item}};
                         $i++ )
                    {
                        if($dictD->{$lc_tagAnalysed}{values}{_related_function}[$i]
                           eq 'replace') {
                            push @{$replaceWith},
                            $dictD->{$lc_tagAnalysed}{values}{_related_item}[$i];
                        }
                    }
                    if( $reportDeprecated && @$replaceWith != 0 ) {
                        note( $0, $cifF, $$block{name},
                              "tag '" . $tagAnalysed . "' has been" .
                              ' replaced by tag(-s): [' .
                              join(', ', @$replaceWith) .
                              '] according to ' . $dictF );
                    }
                }

                # check referenced list mandatory
                my $mandatoryRTag = getRelatedMandatory($dictD, $lc_tagAnalysed, 0);
                if( defined $mandatoryRTag
                    && !exists($baseNamesOfRefTags{$mandatoryRTag})
                 ) {
                  for my $loopAnalysed ( @{$block->{loops}} ) {
                    if( grep $_ eq $tagAnalysed, @{$loopAnalysed} ) {
                        if( grep lc($_) eq $mandatoryRTag, @{$loopAnalysed} ) {
                            if ( $debug ) {
                                debug_note ( $0, $cifF, $$block{name},
                                  "tag '$mandatoryRTag' is mandatory " .
                                  "in loop when tag(s) [" .
                                  join(', ', 
                                  @{$dictD->{$lc_tagAnalysed}{values}{_name}}) .
                                  "] are defined according to $dictF and was" .
                                  ' found' );
                            }
                            $baseNamesOfRefTags{$mandatoryRTag} = 'yes';
                            last;
                        } else {
                            note( $0, $cifF, $$block{name},
                                  "tag '$mandatoryRTag' is mandatory in loop " .
                                  "when tag(s) [" .
                                  join(', ', 
                                  @{$dictD->{$lc_tagAnalysed}{values}{_name}}) .
                                  '] are defined according to ' . $dictF .
                                  ' but was not found' );
                            $baseNamesOfRefTags{$mandatoryRTag} = 'no';
                            last;
                        }
                    }
                  }
                }
                # check list mandatory
                if( exists $dictD->{$lc_tagAnalysed}
                    && exists $dictD->{$lc_tagAnalysed}{values}{_list}
                    && $dictD->{$lc_tagAnalysed}{values}{_list}[0] eq 'yes' )
                {
                    if( exists $block->{inloop}{$tagAnalysed} ) {
                        if ( $debug ) {
                            debug_note( $0, $cifF, $$block{name}, 
                                "tag '$tagAnalysed' must be in a loop " .
                                "according to $dictF and is in a loop" );
                        }
                    } else {
                        note( $0, $cifF, $$block{name},
                              "tag '$tagAnalysed' must be in a loop " .
                              "according to $dictF but is not in a loop" );
                    }
                }
                # check types of values
                my $range = {};
                my %rangeForPrint;
                if( exists $dictD->{$lc_tagAnalysed} &&
                    exists $dictD->{$lc_tagAnalysed}{values}{_enumeration_range} ) {
                    ($$range{min}, $$range{max}) = split(/:/, 
                        $dictD->{$lc_tagAnalysed}{values}{_enumeration_range}[0],
                        2);
                    %rangeForPrint = %$range;
                    if( length($$range{min}) == 0 ) {
                        delete $$range{min};
                        $rangeForPrint{min} = '<any>';
                    }
                    if( length($$range{max}) == 0 ) {
                        delete $$range{max};
                        $rangeForPrint{max} = '<any>';
                    }
                }
                CIFVALUE: for my $tagIndex ( 0..$#{$block->{values}{$tagAnalysed}} ) {
                    my $tagValue = $block->{values}{$tagAnalysed}[$tagIndex];
                    next CIFVALUE if $tagValue eq '.' or $tagValue eq '?';
                    my $value = $tagValue;
                    my $sigma = $block->{precisions}{$tagAnalysed}[$tagIndex];
                    #
                    # if check values in enumeration list
                    #
                    if( exists $dictD->{$lc_tagAnalysed} &&
                        exists $dictD->{$lc_tagAnalysed}{values}{_enumeration} ) {
                        my $listEnumValuesForTag = join(', ',
                            @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}}
                        );
                        my $valueFoundInList = 0;
                        my $emulateSet = 0;
                        if(  grep lc($_) eq $lc_tagAnalysed, @{$setOfEnum} ) {
                            $emulateSet = 1;
                            my $setOfEnumValues = join '|',
                               @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}};
                            $setOfEnumValues =~ s/\./\\./;
                            my $regexpSetOfEnumValues = 
                                                 qr/^($setOfEnumValues)+$/s;
                            if( $caseSensitive ) {
                                if( $value =~ m/$regexpSetOfEnumValues/s ) {
                                        $valueFoundInList = 1;
                                }
                            } else {
                                if( $value =~ m/$regexpSetOfEnumValues/is ) {
                                    $valueFoundInList = 1;
                                }
                            }
                        } else {
                            if( $caseSensitive ) {
                                if( grep $_ eq $value, 
                                    @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}} ) {
                                    $valueFoundInList = 1;
                                }
                            } else {
                                my $lcValue = lc $value;
                                if( grep lc($_) eq $lcValue, 
                                    @{$dictD->{$lc_tagAnalysed}{values}{_enumeration}} ) {
                                    $valueFoundInList = 1;
                                }
                           }
                       }

                       if( $valueFoundInList == 0 ) {
                            note( $0, $cifF, $$block{name},
                                  "tag '$tagAnalysed' value \"$value\" " .
                                  "should be one of these: [" .
                                   $listEnumValuesForTag . '] values' );
                       } else {
                            my $message = "tag '$tagAnalysed' value " .
                                          '"' . $value . '" is one of these: ' .
                                          "[$listEnumValuesForTag] values";

                            $message .= ' (case ignored)' if( !$caseSensitive );

                            $message .= ', enum was treated as set'
                                                              if( $emulateSet );

                            if ($debug) {
                                debug_note( $0, $cifF, $$block{name}, $message );
                            }
                     }

                    #
                    # Check if values match the declared types:
                    #
                    if( exists $dictD->{$lc_tagAnalysed} &&
                        defined $dictD->{$lc_tagAnalysed}{values}{_type} &&
                        $dictD->{$lc_tagAnalysed}{values}{_type}[0] eq 'numb' ) {
                        if(defined $block->{types}{$tagAnalysed}) {
                            if('FLOAT' ne $block->{types}{$tagAnalysed}[$tagIndex]
                                && 'INT' ne $block->{types}{$tagAnalysed}[$tagIndex]) {
                                note( $0, $cifF, $$block{name},
                                      "tag '$tagAnalysed' value \"" . 
                                     $block->{values}{$tagAnalysed}[$tagIndex] .
                                     "\" is of type '" .
                                     $block->{types}{$tagAnalysed}[$tagIndex] .
                                     "' while it should be numeric, i.e. " .
                                     "'FLOAT', or 'INT'" );
                            } else {
                                if ( $debug ) {
                                    debug_note( $0, $cifF, $$block{name}, 
                                      "tag '$tagAnalysed' is of type '" .
                                      $block->{types}{$tagAnalysed}[$tagIndex] .
                                      "' as expected, as it should be one of: " .
                                      "'FLOAT', 'INT'" );
                                }
                            }
                        }
                    }

                    #
                    # Check values against enumeration_range
                    #
                    if( %$range ) {
                        my $valueWOPrecision = $value;
                        if( exists $dictD->{$lc_tagAnalysed} &&
                            $dictD->{$lc_tagAnalysed}{values}{_type}[0] 
                            eq 'numb' ) {
                            $valueWOPrecision =~ s/\s*\(.*$//;
                        }
                        if( exists $dictD->{$lc_tagAnalysed} &&
                            checkAgainstRange(
                                $dictD->{$lc_tagAnalysed}{values}{_type}[0],
                                $range, $valueWOPrecision, $sigma) <= 0 ) {
                                note( $0, $cifF, $$block{name},
                                      "tag '$tagAnalysed' value " .
                                      "\"$value\" should be in range (" .
                                      $rangeForPrint{min} .
                                      ', ' . $rangeForPrint{max} . ')' );
                        } else { 
                            if ( $debug ) {
                                 debug_note( $0, $cifF, $$block{name},
                                            "tag '$tagAnalysed' value " .
                                            "\"$value\" is in range (" .
                                            "$rangeForPrint{min}, " .
                                            "$rangeForPrint{max})" );
                            }
                        }
                    } else { 
                        if ( $debug) {
                            debug_note( $0, $cifF, $$block{name},
                                        'there are no range restrictions ' .
                                        "for tag \"$tagAnalysed\" -- " .
                                        "skipping range test" );
                        }
                    }
                }
            }

            }
            if( !$defined ) {
                note( $0, $cifF, $$block{name}, 
                     "tag '$tagAnalysed' was not found in dictionaries" );
            }
        }
    }
}

##
# Prints program version message.
##
sub VersionMessage()
{
print <<END_M;
cif_validate (using CIFParser v.$COD::CIFParser::CIFParser::version) v.$version

END_M
}

##
# Returns a string that describes "severity level" in a human readable
# form (for discussions of severity levels, see ../doc/error-levels.txt.
# @params $severity
#       Code number of the error severity level.
# @return
#       Error severity level text string.
##
sub severityName($)
{
    my ($severity) = @_;

    if( $severity & 1 ) {
        return "ERROR";
    } elsif( $severity & 2 ) {
        return "WARNING";
    } elsif( $severity & 4 ) {
        return "NOTE";
    } elsif( $severity & 8 ) {
        return "INFO-ERROR";
    } elsif( $severity & 16 ) {
        return "INFO-WARNING";
    } elsif( $severity & 32 ) {
        return "INFO-NOTICE";
    } elsif( $severity & 64 ) {
        return "INFO-INDICATOR";
    } else {
        return "ERROR-LEVEL=$severity";
    }
}

##
# Extracts tags from dictionary (parsed using CIFParser).
# @param $dictF
#       Reference to CIFParser output CIF object.
# @return
#       Hash of tags and related references to parsed data blocks.
##
sub getDict($)
{
    my ($dictF) = @_;
    my $tags = {};
    my $datan = 0;
    while( $datan < @$dictF ) {
        $datan++ and next if
            !exists $$dictF[$datan]{values}{_type};
        for ( @{$$dictF[$datan]{values}{_name}} ) {
            $$tags{lc $_} = $$dictF[$datan];
        }
        $datan++;
    }
    return $tags;
}

##
# Check value against range (defined in dictionary).
# @param $type
#       String, representing the type of value ("numb" or "char").
# @param $range
#       Reference to range hash as $$range{min} and $$range{max}.
# @param $value
#       Value that must be checked.
# @param $sigma
#       Standard deviation to be used when comparing numbers.
# @return
#       -1 if no ranges were provided for the value;
#        0 if the value is out of the provided range;
#        1 if the value is in the provided range.
##
sub checkAgainstRange($$$$)
{
    my ($type, $range, $value, $sigma) = @_;

    if( !exists $$range{min} &&
        !exists $$range{max} ) {
        return -1;
    }
    if( $type eq 'numb' ) {
        return checkAgainstRangeNumb( $range, $value, $sigma );
    } else {
        return checkAgainstRangeChar( $range, $value );
    }
}

##
# Checks number value against range (defined in dictionary).
# @param $range
#       Reference to range hash as $$range{min} and $$range{max}.
# @param $value
#       Value, that must be checked.
# @param $sigma
#       Standard deviation to be used when comparing numeric values
#       (3 sigma rule). If sigma is set to 'undef', values are compared 
#       disregarding standard deviation.
# @return
#        0 if the value is out of the provided range or is not a number
#          at all;
#        1 if the value is in the provided range.
##
sub checkAgainstRangeNumb($$$)
{
    my ( $range, $value, $sigma ) = @_;

    if( ! Scalar::Util::looks_like_number($value) ) {
        return 0;
    }

    my ($min,$max);

    if( defined $sigma ) {
        $min = $$range{min} - 3 * $sigma if exists $$range{min};
        $max = $$range{max} + 3 * $sigma if exists $$range{max};
    } else {
        $min = $$range{min} if exists $$range{min};
        $max = $$range{max} if exists $$range{max};
    }

    if(
        ( !defined $max || $value <= $max )
        &&
        ( !defined $min || $value >= $min )
    ) {
        return 1;
    }
    return 0;
}

##
# Check character value against range (defined in dictionary).
# @param $range
#       Reference to range hash as $$range{min} and $$range{max}.
# @param $value
#       Value, that must be checked.
# @return
#       0 if the value is out of the provided range;
#       1 if the value is in the provided range.
##
sub checkAgainstRangeChar($$)
{
    my ( $range, $value ) = @_;

    if(
        ( !exists $$range{max} || $value le $$range{max} )
        &&
        ( !exists $$range{min} || $value ge $$range{min} )
    ) {
        return 1;
    }
    return 0;
}

##
# Returns name of the closest (according to dictionary) mandatory tag
# (if applicable).
# @param $dict
#       Reference to a parsed dictionary object.
# @param $tag
#       Lowercased name of the tag to analyse.
# @param reccurentCall
#       Logical value to distinguish if the subroutine call is reccursive.
# @return
#       Closest mandatory tag or 'undef' if no mandatory tag is related to 
#       the analysed tag.
##
sub getRelatedMandatory($$$)
{
    my ( $dict, $tag, $reccurentCall ) = @_;

    $tag = lc $tag;
    my $requeryTag = undef;
    if( !exists $dict->{$tag} ) {
        return undef;
    }
    if( $reccurentCall
        && exists $dict->{$tag}{values}{_list_mandatory}
        && $dict->{$tag}{values}{_list_mandatory}[0] eq 'yes' ) {
        return $tag;
    }
    if( exists $dict->{$tag}{values}{_list_reference} ) {
        $requeryTag = $dict->{$tag}{values}{_list_reference}[0];
    }
    if( !defined $requeryTag ) {
        return undef;
    }
    return getRelatedMandatory( $dict, $requeryTag, 1 );
}
