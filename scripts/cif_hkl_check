#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Check the correspondence between CIF and diffraction data files, taking
#  datablock names, cell parameters, author lists and symmetry group names
#  into account.
#**

use strict;
use warnings;
use COD::CIF::Parser qw( parse_cif );
use COD::CIF::Data::Diff qw( comm );
use COD::CIF::Data::CODFlags qw( has_hkl
                                 has_powder_diffraction_intensities
                                 @hkl_tags
                                 @powder_diffraction_intensity_tags );
use COD::CIF::Tags::CanonicalNames qw( canonicalize_all_names );
use COD::Precision qw( cmp_cif_numbers );
use COD::SOptions qw( getOptions );
use COD::SUsage qw( usage options );
use COD::UserMessage qw( note warning error prefix_dataname );

my $use_parser = "c";

#* USAGE:
#*     $0 --options input.cif input.hkl input2.cif input2.hkl input*.{cif,hkl}
#*
#* OPTIONS:
#*     --use-perl-parser
#*        Use Perl parser for CIF parsing.
#*
#*     --use-c-parser
#*        Use Perl & C parser for CIF parsing.
#*
#*     --help, --usage
#*        Print short usage message (this message) and exit.
#**
@ARGV = getOptions(
    "--use-perl-parser" => sub { $use_parser = "perl" },
    "--use-c-parser"    => sub { $use_parser = "c" },
    "--options"         => sub { options; exit },
    "--help,--usage"    => sub { usage; exit }
);

PAIR:
while( @ARGV > 0 ) {
    my $cif_file = shift( @ARGV );
    if( @ARGV == 0 ) {
        error( $0, $cif_file, undef, "missing diffraction data file", undef );
        die;
    }

    my $options = { 'parser' => $use_parser, 'no_print' => 1 };

    my $hkl_file = shift( @ARGV );
    my( $cif_data, $cif_err_count, $cif_messages ) = parse_cif( $cif_file );
    if ( $cif_err_count > 0 ) {
        print STDERR $_ foreach ( @$cif_messages );
        error( $0, $cif_file, undef, "$cif_err_count error(s) "
             . "encountered while parsing the file", undef );
        next;
    }
    print STDERR $_ foreach ( @$cif_messages );

    if( !@$cif_data || !defined $cif_data->[0] ||
        !defined $cif_data->[0]{name} ) {
        warning( $0, $cif_file, undef, 'file seems to be empty', undef );
        next;
    }

    canonicalize_all_names( $cif_data );

    my( $hkl_data, $hkl_err_count, $hkl_messages ) = parse_cif( $hkl_file );
    if ( $hkl_err_count > 0 ) {
        print STDERR $_ foreach ( @$hkl_messages );
        error( $0, $cif_file, undef, "$hkl_err_count error(s) "
             . "encountered while parsing the file", undef );
        next;
    }
    print STDERR $_ foreach ( @$hkl_messages );

    if( !@$hkl_data || !defined $hkl_data->[0] ||
        !defined $hkl_data->[0]{name} ) {
        warning( $0, $hkl_file, undef, 'file seems to be empty', undef );
        next;
    }

    canonicalize_all_names( $hkl_data );

    if( @$hkl_data > 1 ) {
        warning( $0, $hkl_file, undef,
                 'file contains more than one datablock', undef );
        next;
    }
    my $hkl_dataset = $hkl_data->[0];
    my $hkl_values = $hkl_dataset->{values};
    if( !has_hkl( $hkl_dataset ) &&
        !has_powder_diffraction_intensities( $hkl_dataset ) ) {
        warning( $0, $hkl_file, undef,
                 "cannot confirm that file '$hkl_file' contains " .
                 'Fobs or powder diffraction data', 'one or more tags ' .
                 "from list ( " .
                 join( ", ",
                       map { "'$_'" } @hkl_tags ) .
                 " ) or all tags from list ( " .
                 join( ", ",
                       map { "'$_'" } @powder_diffraction_intensity_tags ) .
                 " ) are missing" );
        next PAIR;
    }
    my $hkl_dataname = get_source_block_name( $hkl_dataset );
    my $cif_index;
    my @cif_datanames;
    for( my $i = 0; $i < @$cif_data; $i++ ) {
        my $cif_dataname = get_source_block_name( $cif_data->[$i] );
        push( @cif_datanames, $cif_dataname );
        if( $cif_dataname eq $hkl_dataname ) {
            $cif_index = $i;
            last;
        }
    }
    if( !defined $cif_index ) {
        warning( $0, $cif_file, undef,
                 "cannot confirm relation between any datablocks in CIF "
               . 'and diffraction data files', 'there are no datablocks '
               . "with the same name in both files (" 
               . join( ", ", map { "'$_'" } @cif_datanames )
               . " (CIF datablock(s)) and '$hkl_dataname' "
               . "(diffraction data datablock))" );
        next PAIR;
    }
    my $comm = comm( $cif_data->[$cif_index], $hkl_dataset,
        {
            'compare_only' =>
                [
                    '_cell_length_a',
                    '_cell_length_b',
                    '_cell_length_c',
                    '_cell_angle_alpha',
                    '_cell_angle_beta',
                    '_cell_angle_gamma',
                    '_publ_author_name',
                    '_symmetry_space_group_name_Hall',
                    '_symmetry_space_group_name_H-M',
                ],
            'comparators'  =>
                {
                    '_cell_length_a' => \&cmp_cif_numbers,
                    '_cell_length_b' => \&cmp_cif_numbers,
                    '_cell_length_c' => \&cmp_cif_numbers,
                    '_cell_angle_alpha' => \&cmp_cif_numbers,
                    '_cell_angle_beta'  => \&cmp_cif_numbers,
                    '_cell_angle_gamma' => \&cmp_cif_numbers,
                    '_publ_author_name' => \&compare_lc_strings,
                }
        } );
    foreach my $line ( @$comm ) {
        if( defined $line->[0] && defined $line->[2] ) {
            my $reason;
            if( $line->[0] eq '_publ_author_name' ) {
                $reason = "publication author lists differ";
            } else {
                $reason = "values of tag '$line->[0]' differ";
            }
            $reason .= " ('" . join( ', ', map { "'$_'" }
                  @{$cif_data->[$cif_index]{values}{$line->[0]}} ) .
                  "' (CIF) and '" . join( ', ', map { "'$_'" }
                  @{$hkl_values->{$line->[0]}} ) .
                  "' (diffraction data))";
            warning( $0, $cif_file, prefix_dataname($hkl_dataname),
                     "can not confirm relation between datablocks named " .
                     "'$hkl_dataname' from supplied CIF and diffraction " .
                     "data files", $reason );
            next PAIR;
        }
    }
    note( $0, $cif_file, undef, "OK", undef );
}

sub compare_lc_strings
{
    my( $a, $b ) = @_;
    return lc( $a ) cmp lc( $b );
}

# Returns datablock name. Original source data block name, if specified, is
# prefered. If not specified, current data block name is returned.
sub get_source_block_name
{
    my( $datablock ) = @_;
    my $values = $datablock->{values};
    if( exists $values->{'_cod_data_source_block'} ) {
        return $values->{'_cod_data_source_block'}[0];
    }
    if( exists $values->{'_[local]_cod_data_source_block'} ) {
        return $values->{'_[local]_cod_data_source_block'}[0];
    }
    return $datablock->{name};
}
