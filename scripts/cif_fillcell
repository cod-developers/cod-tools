#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#*  Generates symmetric atoms from a CIF file.
#*
#* USAGE:
#*    $0 --options input.cif inputs*.cif
#**

use strict;
use warnings;
use COD::CIF::Parser qw(parse_cif);
use COD::CIF::Tags::CanonicalNames;
use COD::ShowStruct;
use COD::CIF::Data qw( get_symmetry_operators );
use COD::Spacegroups::Symop::Parse;
use COD::Spacegroups::Lookup::COD;
use COD::ErrorHandler qw(process_warnings process_errors);
use COD::SOptions;
use COD::SUsage;
use File::Basename;

my $Id = '$Id$';
my $use_parser = 'c';
my $die_on_errors    = 1;
my $die_on_warnings  = 0;
my $die_on_notes     = 0;

@ARGV = getOptions(
    "--use-perl-parser" => sub{ $use_parser = "perl" },
    "--use-c-parser"    => sub{ $use_parser = "c" },

    "--help,--usage" => sub { usage; exit }
);

#* OPTIONS:
#*   --use-c-parser
#*                      Use the faster C parser for CIFs (default).
#*   --use-perl-parser
#*                      Use the Perl parser for parsing CIFs.
#*   --help,--usage     Print a short usage message (this message) and exit.
#**
@ARGV = ("-") unless @ARGV;

foreach my $filename (@ARGV) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );

    foreach my $dataset (@$data) {
        canonicalize_names( $dataset );

        my $values   = $dataset->{values};
        my $dataname = 'data_' . $dataset->{name} if defined $dataset->{name};

        local $SIG{__WARN__} = sub { process_warnings( {
                                       'message'  => @_,
                                       'program'  => $0,
                                       'filename' => $filename,
                                       'add_pos'  => $dataname
                                     }, {
                                       'WARNING' => $die_on_warnings,
                                       'NOTE'    => $die_on_notes
                                     } ) };

        eval {
            # extracts atom site label or atom site type symbol
            my $loop_tag;

            if (exists $values->{"_atom_site_label"}) {
                $loop_tag = "_atom_site_label";
            }
            elsif (exists $values->{"_atom_site_type_symbol"})
            {
                $loop_tag = "_atom_site_type_symbol";
            }
            else
            {
                die "ERROR, neither '_atom_site_type_symbol'"
                  . " nor '_atom_site_label' are present in the file\n";
            }

            # extracts symmetry operators
            my $sym_data = get_symmetry_operators($dataset);

            my $inloop = $dataset->{"inloop"};
            my $loop_id = $inloop->{$loop_tag};
            my $loop = $dataset->{"loops"}[$loop_id];

            my @sym_operators = map{symop_from_string($_)} @{$sym_data};

            # prints additional cif file information
            print $dataname . "_" . &File::Basename::fileparse($0) . "\n";
            print  "_symmetry_space_group_name_H-M   'P 1'\n";

            foreach my $angle (qw(_cell_angle_alpha
                                  _cell_angle_beta
                                  _cell_angle_gamma))
            {
                if( defined $values->{$angle}[0] ) {
                    print $angle . "   " . $values->{$angle}[0]."\n";
                }
            }

            foreach my $length (qw(_cell_length_a
                                   _cell_length_b
                                   _cell_length_c))
            {
                print $length . "   " . $values->{$length}[0]."\n";
            }

            print "loop_ " . "_symmetry_equiv_pos_as_xyz" . " 'x, y, z'\n";
            print "loop_\n";

            foreach my $loop_value (@{$loop})
            {
                if("_atom_site_adp_type" ne $loop_value)
                {
                    print $loop_value . "\n";
                }
            }

            my @sym_atoms;

            for(my $i = 0; $i < @sym_operators; $i++)
            {
                my $symop = $sym_operators[$i];

                for(my $j = 0; $j < @{$values->{$loop_tag}}; $j++)
                {
                    my @atom_xyz;
                    foreach my $atom_fract (qw(_atom_site_fract_x
                                               _atom_site_fract_y
                                               _atom_site_fract_z))
                    {
                        my $sym_atom_data = $values->{$atom_fract};
                        push(@atom_xyz, ${$sym_atom_data}[$j]);
                    }
                    push(@atom_xyz, 1);

                    my $new_atom_xyz = shift_atoms(symop_apply(\@atom_xyz, $symop));
                    for(my $m = 0; $m < @{$new_atom_xyz}; $m++)
                    {
                    for(my $k = 0; $k < @{$loop}; $k++)
                    {
                        my $sym_atom_data = $values->{${$loop}[$k]};

                        if("_atom_site_adp_type" ne ${$loop}[$k])
                        {
                            if(${$loop}[$k] eq "_atom_site_label")
                            {
                                $sym_atoms[$i][$j][$k] = ${$sym_atom_data}[$j]."_".$i."_".$m;
                            }
                            elsif(${$loop}[$k] eq "_atom_site_fract_x")
                            {
                                $sym_atoms[$i][$j][$k] = ${$new_atom_xyz}[$m][0];
                            }
                            elsif(${$loop}[$k] eq "_atom_site_fract_y")
                            {
                                $sym_atoms[$i][$j][$k] = ${$new_atom_xyz}[$m][1];
                            }
                            elsif(${$loop}[$k] eq "_atom_site_fract_z")
                            {
                                $sym_atoms[$i][$j][$k] = ${$new_atom_xyz}[$m][2];
                            }
                            else
                            {
                                $sym_atoms[$i][$j][$k] = ${$sym_atom_data}[$j];
                            }
                            print $sym_atoms[$i][$j][$k] . "   ";
                        }
                    }
                    print "\n";
                    }
                }
            }
        };
        if ( $@ ) {
            process_errors( {
              'message'       => $@,
              'program'       => $0,
              'filename'      => $filename,
              'add_pos'       => $dataname
            }, $die_on_errors )
        }
    }
}

#===============================================================#
sub symop_apply
{
    my($atom_xyz, $symop) = @_;
    my @new_atom_xyz;

    for(my $i = 0; $i < @{$symop}; $i++)
    {
        $new_atom_xyz[$i] = 0;
        for(my $j = 0; $j < @{$symop}; $j++)
        {
            ${$atom_xyz}[$j] =~ s/\(\d+\)$//;
            $new_atom_xyz[$i] += ${$atom_xyz}[$j] * ${$symop}[$i][$j];
        }
        $new_atom_xyz[$i] = modulo_1($new_atom_xyz[$i]);
    }

    return \@new_atom_xyz;
}

#===============================================================#
sub shift_atoms
{
    my($atom_xyz) = @_;

    my @shifted_atom_xyz;
    my @shifting_params = (0, -1, 1);

    my $counter = 0;
    for(my $i = 0; $i < @shifting_params; $i++)
    {
        for(my $j = 0; $j < @shifting_params; $j++)
        {
            for(my $k = 0; $k < @shifting_params; $k++)
            {
                $shifted_atom_xyz[$counter][0] = ${$atom_xyz}[0] + $shifting_params[$i];
                $shifted_atom_xyz[$counter][1] = ${$atom_xyz}[1] + $shifting_params[$j];
                $shifted_atom_xyz[$counter][2] = ${$atom_xyz}[2] + $shifting_params[$k];
                $counter++;
            }
        }
    }

    return \@shifted_atom_xyz;
}
#===============================================================#
# @COD::Spacegroups::Lookup::COD::table =
# (
# {
#     number          => 1,
#     hall            => ' P 1',
#     schoenflies     => 'C1^1',
#     hermann_mauguin => 'P 1',
#     universal_h_m   => 'P 1',
#     symops => [
#         'x,y,z',
#     ],
#     ncsym => [
#         'x,y,z',
#     ]
# },
# );

sub get_symops
{
    my ($option, $param) = @_;

    $param =~ s/ //g;
    $param =~ s/_//g;

    foreach my $hash (@COD::Spacegroups::Lookup::COD::table)
    {
        my $value = $hash->{$option};
        $value =~ s/ //g;
        $value =~ s/_//g;

        if($value eq $param)
        {
            return $hash->{symops};
        }
    }
    return 0;
}
