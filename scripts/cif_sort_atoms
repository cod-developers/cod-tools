#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Sort atoms in a CIF file in given order. Accepts more than one sorting
#* criterion.
#*
#* USAGE:
#*    $0 --options input1.cif input*.cif
#**

use strict;
use warnings;
use File::Basename qw( basename );
use COD::AtomProperties;
use COD::CIF::Parser qw( parse_cif );
use COD::CIF::Tags::CanonicalNames qw( canonicalize_all_names );
use COD::CIF::Tags::Print qw( print_cif );
use COD::ErrorHandler qw( process_errors
                          process_warnings
                          process_parser_messages
                          report_message );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ToolsVersion;

my @order_functions;
my $direction = 1;

my $use_parser = 'c';

my $die_on_errors   = 0;
my $die_on_warnings = 0;
my $die_on_notes    = 0;
my $die_on_error_level = {
    ERROR   => $die_on_errors,
    WARNING => $die_on_warnings,
    NOTE    => $die_on_notes
};

#* OPTIONS:
#*   -l, --lexicographic
#*                     Sort by lexicographic order (default).
#*   -Z, --atomic-number
#*                     Sort by atomic number.
#*   --ascending-numeric _atom_site_occupancy
#*                     Sort by values of CIF data item in ascending numeric
#*                     order.
#*   --descending-numeric _atom_site_occupancy
#*                     Sort by values of CIF data item in descending numeric
#*                     order.
#*   --ascending-lexic _atom_site_label
#*                     Sort by values of CIF data item in ascending lexic
#*                     order.
#*   --descending-lexic _atom_site_label
#*                     Sort by values of CIF data item in descending lexic
#*                     order.
#*
#*   -r, --reverse
#*                     Reverse the ordering.
#*
#*   --use-perl-parser
#*                     Use Perl parser for CIF parsing.
#*   --use-c-parser
#*                     Use Perl & C parser for CIF parsing (default).
#*
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**

@ARGV = getOptions(
    '-l,--lexicographic' => sub { push @order_functions, \&get_lexicographic_order },
    '-Z,--atomic-number' => sub { push @order_functions, \&get_atomic_order },

    '--ascending-numeric' =>
        sub { push @order_functions,
                   make_comparator_numeric( get_value, 1 ) },
    '--descending-numeric' =>
        sub { push @order_functions,
                   make_comparator_numeric( get_value, -1 ) },
    '--ascending-lexic' =>
        sub { push @order_functions,
                   make_comparator_lexic( get_value, 1 ) },
    '--descending-lexic' =>
        sub { push @order_functions,
                   make_comparator_lexic( get_value, -1 ) },

    '-r,--reverse' => sub { $direction = -1 },

    '--use-perl-parser' => sub{ $use_parser = 'perl' },
    '--use-c-parser'    => sub{ $use_parser = 'c' },

    '--options'      => sub { options; exit },
    '--help,--usage' => sub { usage; exit },
    '--version'         => sub { print 'cod-tools version ',
                                 $COD::ToolsVersion::Version, "\n";
                                 exit }
);

@order_functions = ( \&get_lexicographic_order ) if !@order_functions;

@ARGV = ( '-' ) unless @ARGV;

binmode STDOUT, ':encoding(UTF-8)';
binmode STDERR, ':encoding(UTF-8)';

for my $filename (@ARGV) {
    my $options = { parser   => $use_parser,
                    no_print => 1 };

    my( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );

    if( !@{$data} || !defined $data->[0] || !defined $data->[0]{name} ) {
        report_message( {
           'program'   => $0,
           'filename'  => $filename,
           'err_level' => 'WARNING',
           'message'   => 'file seems to be empty'
        }, 0 );
        next;
    }

    canonicalize_all_names( $data );

    for my $dataset (@$data) {
        my $values = $dataset->{values};
        my $dataname = 'data_' . $dataset->{name};

        local $SIG{__WARN__} = sub {
            process_warnings( {
                'message'  => @_,
                'program'  => $0,
                'filename' => $filename,
                'add_pos'  => $dataname
            }, $die_on_error_level )
        };

        eval {
            my $atom_loop = $dataset->{inloop}{_atom_site_label};
            my @atoms;
            for my $i (0..$#{$dataset->{values}{_atom_site_label}}) {
                my %atom = map { $_ => $dataset->{values}{$_}[$i] }
                               @{$dataset->{loops}[$atom_loop]};
                $atom{index} = $i;
                push @atoms, \%atom;
            }
            my @order = map  { $_->{index} }
                        sort { for my $order (@order_functions) {
                                   my $cmp = $order->( $a, $b );
                                   return $direction * $cmp if $cmp;
                               } }
                             @atoms;
            if( defined $atom_loop ) {
                for my $tag (@{$dataset->{loops}[$atom_loop]}) {
                    for my $key (qw( precisions types values )) {
                        $dataset->{$key}{$tag} =
                            [ @{$dataset->{$key}{$tag}}[@order] ];
                    }
                }
            }

            print_cif( $dataset,
                       {
                            preserve_loop_order => 1,
                            keep_tag_order => 1
                       } );
        };
        if ( $@ ) {
            process_errors( {
              'message'       => $@,
              'program'       => $0,
              'filename'      => $filename,
              'add_pos'       => $dataname
            }, $die_on_errors )
        }
    }
}

sub get_lexicographic_order
{
    my( $a, $b ) = @_;
    return $a->{_atom_site_label} cmp $b->{_atom_site_label};
}

sub get_atomic_order
{
    my( $a, $b ) = @_;

    my( $a_type, $b_type );
    if( exists $a->{_atom_site_type_symbol} &&
        exists $b->{_atom_site_type_symbol} ) {
        $a_type = $a->{_atom_site_type_symbol};
        $b_type = $b->{_atom_site_type_symbol};
    } else {
        if( $a->{_atom_site_label} =~ /^([A-Za-z]{1,2})/ ) {
            $a_type = $1;
        }
        if( $b->{_atom_site_label} =~ /^([A-Za-z]{1,2})/ ) {
            $b_type = $1;
        }
    }
    if( defined $a_type && defined $b_type ) {
        return $COD::AtomProperties::atoms{$a_type}{atomic_number} <=>
               $COD::AtomProperties::atoms{$b_type}{atomic_number};
    }

    return 0; # cannot compare
}

sub make_comparator_numeric
{
    my( $data_name, $direction ) = @_;
    return sub { $direction * ( $a->{$data_name} <=> $b->{$data_name} ) };
}

sub make_comparator_lexic
{
    my( $data_name, $direction ) = @_;
    return sub { $direction * ( $a->{$data_name} cmp $b->{$data_name} ) };
}
