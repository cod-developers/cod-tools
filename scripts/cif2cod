#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#*  Parse a CIF file, prepare a COD database table entry from it.
#*
#* USAGE:
#*    $0 --options input.cif inputs*.cif
#**

use strict;
use warnings;
use COD::CIF::Parser qw( parse_cif );
use COD::CIF::Data::CIF2COD qw( cif2cod );
use COD::SOptions qw( getOptions );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_warnings
                          process_errors
                          process_parser_messages );

my $print_header = 0; # Indicates whether to print out a header with column names
my $print_keywords = 0;

my $user_columns; # User specified list of columns to be printed

my $use_parser = "c";
my $die_on_errors   = 1;
my $die_on_warnings = 0;
my $die_on_notes    = 0;

my %options;
#* OPTIONS:
#* -C, --cod-number 1000000
#*                     Use the specified number, 1000000 in this example, as
#*                     a COD number for this structure; do not take the number
#*                     from the datablock name.
#*
#* -c, --always-continue
#*                     Continue processing and return successful return status
#*                     even if errors are diagnosed.
#* -c-, --always-die
#*                     Stop and return error status if errors are diagnosed.
#*
#* -h, --print-header
#*                     Print header with data column names at the first line
#*                     With this option cif2cod use the new field list for the
#*                     output file.
#*
#* -h-, --dont-print-header, --no-print-header
#*                     Do not print column names on the first (header) line
#*                     (default).
#*
#* -k, --keywords
#*                     Print values in separate lines prefixed with keywords.
#*
#* --use-attached-hydrogens
#*                     Include number of implicit hydrogens, specified using
#*                     _atom_site_attached_hydrogens tag, into the formula sum.
#*
#* --dont-use-attached-hydrogens,
#* --no-use-attached-hydrogens,
#* --ignore-attached-hydrogens
#*                     Ignore number of implicit hydrogens, specified using
#*                     _atom_site_attached_hydrogens tag, in calculation of the
#*                     formula sum. Default option.
#*
#* --reformat-space-group
#*                     Correct the formatting of Hermann-Mauguin symmetry
#*                     space group symbol.
#*
#* --dont-reformat-space-group,
#* --leave-space-group
#*                     Do not correct the formatting of Hermann-Mauguin 
#*                     symmetry space group.
#*
#* --use-datablocks-without-coordinates
#*                     Do not filter out datablocks without coordinates.
#*
#* --do-not-use-datablocks-without-coordinates, --use-all-datablocks
#* --dont-use-datablocks-without-coordinates
#* --no-use-datablocks-without-coordinates
#* --skip-datablocks-without-coordinates
#*                     Filter out datablocks without coordinates (default).
#*
#* --require-only-doi
#*                     Do not require all bibliographic details (authors,
#*                     journal name, title, year, volume and first page of
#*                     the publication) to be present if publication DOI is
#*                     specified.
#*
#* --require-full-bibliography
#*                     Require author names, journal name, volume, publication
#*                     title, year and first page to be present (default).
#*
#* --columns file,flags,Robs
#* --columns "file flags Robs"
#*                     Print only columns specified in this option.
#*
#* --continue-on-errors
#*                     Do not terminate script if errors are raised.
#* --dont-continue-on-errors, --no-continue-on-errors,
#* --exit-on-errors, --do-not-continue-on-errors, --die-on-errors
#*                     Terminate script immediately if errors are raised (default).
#* --continue-on-warnings
#*                     Do not terminate script if warnings are raised (default).
#* --die-on-warnings
#*                     Terminate script immediately if warnings are raised.
#* --continue-on-notes
#*                     Do not terminate script if notes are raised (default).
#* --die-on-notes
#*                     Terminate script immediately if notes are raised.
#*
#* --use-perl-parser
#*                     Use the Perl parser for parsing CIFs.
#* --use-c-parser
#*                     Use the faster C parser for CIFs (default).
#*
#* --help, --usage
#*                     Print a short usage message (this message) and exit.
#**
@ARGV = getOptions(
    "-C,--cod-number" => \$options{cod_number},

    "-h,--print-header"       => sub { $print_header = 1 },
    "-h-,--dont-print-header" => sub { $print_header = 0 },
    "--no-print-header"       => sub { $print_header = 0 },

    "-k,--keywords"   => sub { $print_keywords = 1 },

    "--use-attached-hydrogens" => sub { $options{use_attached_hydrogens} = 1 },
    "--dont-use-attached-hydrogens" => sub { $options{use_attached_hydrogens} = 0 },
    "--no-use-attached-hydrogens" => sub { $options{use_attached_hydrogens} = 0 },
    "--ignore-attached-hydrogens" => sub { $options{use_attached_hydrogens} = 0 },

    "--require-only-doi"
        => sub{ $options{require_only_doi} = 1 },
    "--require-full-bibliography"
        => sub{ $options{require_only_doi} = 0 },

    "--reformat-space-group" =>
            sub { $options{reformat_spacegroup} = 1; },
    "--dont-reformat-space-group" =>
            sub { $options{reformat_spacegroup} = 0; },
    "--leave-space-group" =>
            sub { $options{reformat_spacegroup} = 0; },

    "--columns" => \$user_columns,

    "--use-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 1 },
    "--use-all-datablocks"
        => sub{ $options{use_datablocks_without_coord} = 1 },

    "--do-not-use-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 0 },
    "--dont-use-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 0 },
    "--no-use-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 0 },
    "--skip-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 0 },

    "-c,--always-continue"              => sub { $die_on_errors   = 0;
                                                 $die_on_warnings = 0;
                                                 $die_on_notes    = 0 },
    "-c-,--always-die"                  => sub { $die_on_errors   = 1;
                                                 $die_on_warnings = 1;
                                                 $die_on_notes    = 1 },

    "--continue-on-errors"          => sub { $die_on_errors = 0 },
    "--dont-continue-on-errors"     => sub { $die_on_errors = 1 },
    "--die-on-errors"               => sub { $die_on_errors = 1 },
    "--do-not-continue-on-errors"   => sub { $die_on_errors = 1 },
    "--no-continue-on-errors"       => sub { $die_on_errors = 1 },
    "--exit-on-errors"              => sub { $die_on_errors = 1 },

    "--continue-on-warnings" => sub { $die_on_warnings = 0 },
    "--die-on-warnings"      => sub { $die_on_warnings = 1 },

    "--continue-on-notes"    => sub { $die_on_notes = 0 },
    "--die-on-notes"         => sub { $die_on_notes = 1 },

    "--use-perl-parser"       => sub{ $use_parser = "perl" },
    "--use-c-parser"          => sub{ $use_parser = "c" },

    "--options"       => sub { options; exit },
    "--help,--usage"  => sub { usage; exit }
);

my $die_on_error_level = {
    ERROR   => $die_on_errors,
    WARNING => $die_on_warnings,
    NOTE    => $die_on_notes
};

my @print_columns;

if( defined $user_columns ) {
    @print_columns = map { split m/[ ]/, $_ } split m/,/, $user_columns;
} else {
    @print_columns = @COD::CIF::Data::CIF2COD::new_data_fields;
}

binmode( STDOUT, ":encoding(UTF-8)" );

if( $print_header ) {
    local $\ = "\n";
    if( $print_keywords ) {
        local $, = " ";
        print @print_columns;
    } else {
        local $, = ";";
        print @print_columns;
    }
}

@ARGV = ( "-" ) unless @ARGV;

my $first = 1;

for my $filename (@ARGV) {

    my $parser_options = { 'parser' => $use_parser, 'no_print' => 1 };

    my ( $data, $err_count, $messages ) = parse_cif( $filename, $parser_options );
    process_parser_messages( $messages, $die_on_error_level );

    my @extracted;
    foreach my $dataset (@$data) {

        my $dataname = 'data_' . $dataset->{name};

        local $SIG{__WARN__} = sub { process_warnings( {
                                       'message'       => @_,
                                       'program'       => $0,
                                       'filename'      => $filename,
                                       'add_pos'       => $dataname
                                     }, $die_on_error_level ) };

        my $extracted_dataset;
        eval {
            $extracted_dataset = cif2cod( $dataset, $filename, \%options );
        };
        if ($@) {
            process_errors( {
              'message'       => $@,
              'program'       => $0,
              'filename'      => $filename,
              'add_pos'       => $dataname
            }, $die_on_errors )
        }
        push @extracted, $extracted_dataset if defined $extracted_dataset;
    }

    for my $data (@extracted) {
        my %data = %$data;

        # Print out the collected data fields:
        my @data_fields = @COD::CIF::Data::CIF2COD::default_data_fields;
        if( $print_header || defined $user_columns ) {
            @data_fields = @print_columns;
        }
        if( $print_keywords ) {
            print "\n" unless $first;
            $first = 0;
            my $separator = " ";
            for my $key (@data_fields) {
                my $value = $data{$key};
                if( defined $value ) {
                    # Remove trailing dot from numbers:
                    $value =~ s/^\s*(\d+)\.\s*$/$1/;
                    print $key . $separator . $value . "\n";
                }
            }
        } else {
            my $separator = "";
            for my $key (@data_fields) {
                my $value = $data{$key};
                if( defined $value ) {
                    # Remove trailing dot from numbers:
                    $value =~ s/^\s*(\d+)\.\s*$/$1/;
                    if( $key ne "text" ) {
                        $value =~ s/\\/\\\\/g;
                        $value =~ s/"/\\"/g;
                    }
                    $value = "\"" . $value . "\"";
                } else {
                    $value = "NULL";
                }
                print $separator, $value;
                $separator = ";";
            }
            print "\n";
        }
    }
}
