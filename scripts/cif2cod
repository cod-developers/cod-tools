#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#*  Parse a CIF file, prepare a COD database table entry from it.
#*
#* USAGE:
#*    $0 --options input.cif inputs*.cif
#**

use strict;
use warnings;
use COD::CIF::Parser qw( parse_cif );
use COD::CIF::Data::CIF2COD qw(cif2cod);
use COD::SOptions;
use COD::SUsage;
use COD::UserMessage qw( parse_message sprint_message );
use COD::ErrorHandler qw( process_warnings process_errors );

my $print_header = 0;
    # Indicates whether to print out a header with column names
my $print_keywords = 0;

my $user_columns; # User specified list of columns to be printed

my $use_parser = "c";
my $die_on_errors   = 1;
my $die_on_warnings = 0;
my $die_on_notes    = 0;

my %options;
#* OPTIONS:
#* -C, --cod-number 1000000
#*                     Use the specified number, 1000000 in this example, as
#*                     a COD number for this structure; do not take the number
#*                     from the datablock name.
#*
#* -c, --always-continue
#*                     Continue processing and return successful return status
#*                     even if errors are diagnosed.
#* -c-, --always-die
#*                     Stop and return error status if errors are diagnosed.
#*
#* -h, --print-header
#*                     Print header with data column names at the first line
#*                     With this option cif2cod use the new field list for the
#*                     output file.
#*
#* -h-, --dont-print-header, --no-print-header
#*                     Do not print column names on the first (header) line
#*                     (default).
#*
#* -k, --keywords
#*                     Print values in separate lines prefixed with keywords.
#*
#* --use-attached-hydrogens
#*                     Include number of implicit hydrogens, specified using
#*                     _atom_site_attached_hydrogens tag, into the formula sum.
#*
#* --dont-use-attached-hydrogens,
#* --no-use-attached-hydrogens,
#* --ignore-attached-hydrogens
#*                     Ignore number of implicit hydrogens, specified using
#*                     _atom_site_attached_hydrogens tag, in calculation of the
#*                     formula sum. Default option.
#*
#* --reformat-space-group
#*                     Correct the formatting of Hermann-Mauguin symmetry
#*                     space group symbol.
#*
#* --dont-reformat-space-group,
#* --leave-space-group
#*                     Do not correct the formatting of Hermann-Mauguin 
#*                     symmetry space group.
#*
#* --use-datablocks-without-coordinates
#*                     Do not filter out datablocks without coordinates.
#*
#* --do-not-use-datablocks-without-coordinates, --use-all-datablocks
#* --dont-use-datablocks-without-coordinates
#* --no-use-datablocks-without-coordinates
#* --skip-datablocks-without-coordinates
#*                     Filter out datablocks without coordinates (default).
#*
#* --require-only-doi
#*                     Do not require all bibliographic details (authors,
#*                     journal name, title, year, volume and first page of
#*                     the publication) to be present if publication DOI is
#*                     specified.
#*
#* --require-full-bibliography
#*                     Require author names, journal name, volume, publication
#*                     title, year and first page to be present (default).
#*
#* --columns file,flags,Robs
#* --columns "file flags Robs"
#*                     Print only columns specified in this option.
#*
#* -c, --continue-on-errors
#                      Do not terminate script if errors are raised.
#* -c-, --dont-continue-on-errors, --no-continue-on-errors,
#* --exit-on-errors, --do-not-continue-on-errors, --die-on-errors
#*                     Terminate script immediately if errors are raised (default).
#* --continue-on-warnings
#*                     Do not terminate script if warnings are raised (default).
#* --die-on-warnings
#*                     Terminate script immediately if warnings are raised.
#* --continue-on-notes
#*                     Do not terminate script if notes are raised (default).
#* --die-on-notes
#*                     Terminate script immediately if notes are raised.
#*
#* --use-perl-parser   Use the Perl parser for parsing CIFs.
#* --use-c-parser      Use the faster C parser for CIFs (default).
#*
#* --help,--usage  print a short usage message (this message) and exit.
#**
@ARGV = getOptions(
    "-C,--cod-number" => \$options{cod_number},

    "-h,--print-header"       => sub { $print_header = 1 },
    "-h-,--dont-print-header" => sub { $print_header = 0 },
    "--no-print-header"       => sub { $print_header = 0 },

    "-k,--keywords"   => sub { $print_keywords = 1 },

    "--use-attached-hydrogens" => sub { $options{use_attached_hydrogens} = 1 },
    "--dont-use-attached-hydrogens" => sub { $options{use_attached_hydrogens} = 0 },
    "--no-use-attached-hydrogens" => sub { $options{use_attached_hydrogens} = 0 },
    "--ignore-attached-hydrogens" => sub { $options{use_attached_hydrogens} = 0 },

    "--require-only-doi"
        => sub{ $options{require_only_doi} = 1 },
    "--require-full-bibliography"
        => sub{ $options{require_only_doi} = 0 },

    "--reformat-space-group" =>
            sub { $options{reformat_spacegroup} = 1; },
    "--dont-reformat-space-group" =>
            sub { $options{reformat_spacegroup} = 0; },
    "--leave-space-group" =>
            sub { $options{reformat_spacegroup} = 0; },

    "--columns" => \$user_columns,

    "--use-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 1 },
    "--use-all-datablocks"
        => sub{ $options{use_datablocks_without_coord} = 1 },

    "--do-not-use-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 0 },
    "--dont-use-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 0 },
    "--no-use-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 0 },
    "--skip-datablocks-without-coordinates"
        => sub{ $options{use_datablocks_without_coord} = 0 },

    "-c,--always-continue"              => sub { $die_on_errors   = 0;
                                                 $die_on_warnings = 0;
                                                 $die_on_notes    = 0 },
    "-c-,--always-die"                  => sub { $die_on_errors   = 1;
                                                 $die_on_warnings = 1;
                                                 $die_on_notes    = 1 },

    "--continue-on-errors"          => sub { $die_on_errors = 0 },
    "--dont-continue-on-errors"     => sub { $die_on_errors = 1 },
    "--die-on-errors"               => sub { $die_on_errors = 1 },
    "--do-not-continue-on-errors"   => sub { $die_on_errors = 1 },
    "--no-continue-on-errors"       => sub { $die_on_errors = 1 },
    "--exit-on-errors"              => sub { $die_on_errors = 1 },

    "--continue-on-warnings" => sub { $die_on_warnings = 0 },
    "--die-on-warnings"      => sub { $die_on_warnings = 1 },

    "--continue-on-notes"    => sub { $die_on_notes = 0 },
    "--die-on-notes"         => sub { $die_on_notes = 1 },

    "--use-perl-parser"       => sub{ $use_parser = "perl" },
    "--use-c-parser"          => sub{ $use_parser = "c" },

    "--help,--usage"  => sub { usage; exit },
);

my %die_on_error_level = (
    ERROR   => $die_on_errors,
    WARNING => $die_on_warnings,
    NOTE    => $die_on_notes
);

my @print_columns;

if( defined $user_columns ) {
    @print_columns = map { split( " ", $_ ) } split( ",", $user_columns );
} else {
    @print_columns = @COD::CIF::Data::CIF2COD::new_data_fields;
}

binmode( STDOUT, ":utf8" );

if( $print_header ) {
    local $\ = "\n";
    if( $print_keywords ) {
        local $, = " ";
        print @print_columns;
    } else {
        local $, = ";";
        print @print_columns;
    }
}

@ARGV = ( "-" ) unless @ARGV;

my $first = 1;

for my $filename (@ARGV) {

    my $parser_options = { 'parser' => $use_parser, 'no_print' => 1 };

    my ( $data, $err_count, $messages ) = parse_cif( $filename, $parser_options );

    my %err_level_counter;
    foreach ( @$messages ) {
        warn $_;
        my $parsed_message = parse_message($_);
        if ( defined $parsed_message->{errlevel} ) {
            $err_level_counter{$parsed_message->{errlevel}}++;
        }
    };

    my @error_levels = ( 'NOTE', 'WARNING', 'ERROR' );
    foreach ( @error_levels ) {
        if ( defined $err_level_counter{$_} && $err_level_counter{$_} > 0 ) {
            my $message = sprint_message( $0, $filename, undef, 'ERROR',
                            "$err_level_counter{$_} $_(s) encountered "
                          . 'while parsing the file', undef );
            $die_on_error_level{$_} ? die $message : warn $message;
        }
    };

    my @extracted;
    foreach my $dataset (@$data) {

        my $dataname = 'data_' . $dataset->{name};

        local $SIG{__WARN__} = sub {
                                   process_warnings(
                                       $filename, $dataname, @_,
                                       {
                                         WARNING => $die_on_warnings,
                                         NOTE    => $die_on_notes,
                                       }
                                   ) };

        my $extracted_dataset;
        eval {
            $extracted_dataset = cif2cod( $dataset, $filename, \%options );
        };
        if ($@) {
            process_errors( $filename, $dataname, $@, $die_on_errors );
        }
        push @extracted, $extracted_dataset if defined $extracted_dataset;
    }

    for my $data (@extracted) {
        my %data = %$data;

        # Print out the collected data fields:
        my @data_fields = @COD::CIF::Data::CIF2COD::default_data_fields;
        if( $print_header || defined $user_columns ) {
            @data_fields = @print_columns;
        }
        if( $print_keywords ) {
            print "\n" unless $first;
            $first = 0;
            my $separator = " ";
            for my $key (@data_fields) {
                my $value = $data{$key};
                if( defined $value ) {
                    # Remove trailing dot from numbers:
                    $value =~ s/^\s*(\d+)\.\s*$/$1/;
                    print $key . $separator . $value . "\n";
                }
            }
        } else {
            my $separator = "";
            for my $key (@data_fields) {
                my $value = $data{$key};
                if( defined $value ) {
                    # Remove trailing dot from numbers:
                    $value =~ s/^\s*(\d+)\.\s*$/$1/;
                    if( $key ne "text" ) {
                        $value =~ s/\\/\\\\/g;
                        $value =~ s/"/\\"/g;
                    }
                    $value = "\"" . $value . "\"";
                } else {
                    $value = "NULL";
                }
                print $separator, $value;
                $separator = ";";
            }
            print "\n";
        }
    }
}
