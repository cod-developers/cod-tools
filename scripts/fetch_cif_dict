#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#$Id$
#------------------------------------------------------------------------------
#*
#*  Fetches cif_core.dic from the IUCr FTP site if non-expired local copy
#*  does not exist.
#*
#* USAGE:
#*    $0 --options
#**

use strict;
use warnings;
use Net::FTP;
use File::Compare qw( compare );
use File::Copy qw( move );
use COD::SOptions qw( getOptions );
use COD::SUsage qw( usage options );
use COD::UserMessage qw( note warning error sprint_message );

my $version = '1.0';
my $cacheDuration = 432000; # 60 * 60 * 24 * 5 = 432000 -> for 5 days
my $fromMail = undef;       # e-mail of user using script
my $forceOverwrite = 0;     # force overwrite of local file or cache clearance
my $verbose = 0;
my $dictFileURI = 'ftp://ftp.iucr.org/pub/cif_core.dic';

#* OPTIONS:
#* --cache-duration 432000
#*                    Time in seconds, for which the file will remain
#*                    untouched unless forced to do otherwise 
#*                    (see --force-overwrite) (default 432000).
#* --mail-address fetcher@mail.com
#*                    The e-mail address that will be used passed to the FTP
#*                    server as an identifier of the client using the service.
#*                    It is not mandatory and there is no default, but we
#*                    insist you to declare it.
#* --force-overwrite
#*                    Disregard local file modification time and cache duration
#*                    values while fetching the requested file.
#* --no-force-overwrite
#*                    Respect local file modification time and cache duration
#*                    values while fetching the requested file (default).
#* --silent, --quiet
#*                    Suppress additional messages about the progress of the
#*                    script. Only fatal errors will be printed.
#* --verbose, --no-quiet
#*                    Print additional messages about the progress of the
#*                    script.
#* --help, --usage
#*                    Print a short usage message (this message) and exit.
#**
@ARGV = getOptions(
    "--cache-duration"   => \$cacheDuration,
    "--mail-address"     => \$fromMail,

    "--force-overwrite"    => sub { $forceOverwrite = 1 },
    "--no-force-overwrite" => sub { $forceOverwrite = 0 },

    "--silent"       => sub { $verbose = 0 },
    "--quiet"        => sub { $verbose = 0 },
    "--verbose"      => sub { $verbose = 1 },
    "--no-quiet"     => sub { $verbose = 1 },
    "--options"      => sub { options; exit },
    "--help,--usage" => sub { usage; exit }
);

fetchDictionary($dictFileURI, $cacheDuration, $fromMail, $forceOverwrite);

# This subroutine is used before fetching new dictionary from FTP.
# It creates local directory and returns path to it.
# Parameters:
#     NONE
# Example:
#     prepareLocal;
sub prepareLocal {
    my $myCODDir = '';
    if( defined $ENV{HOME} ) {
        $myCODDir = $ENV{HOME} . '/';
    }
    $myCODDir .= '.cod/';

    if( ! -d $myCODDir ) {
        if( ! mkdir $myCODDir, 0775 ) {
            error( $0, $myCODDir, undef, 'unable to create COD directory ',
                   lcfirst($!) );
            return 0;
        }
        note( $0, $myCODDir, undef, 'created directory to store '
            . "Crystallography Open Database (COD) persistent files", undef );
    }

    return $myCODDir;
}

# Subroutine used to create a copy of local dictionary file appending
# date to file name.
# Parameters:
#     1) string -- path to local dictionary file
# Example:
#     createCopyOfLocalFile '/home/user/.cod/cif_core.dic';
sub createCopyOfLocalFile {
    my $localDictFile = shift;

    my @lTime = localtime(time);
    my $movedDistFile = $localDictFile . '_';
    $movedDistFile .= ($lTime[5]+1900) . '-';
    $movedDistFile .= ($lTime[4] < 10) ? '0' . $lTime[4] : $lTime[4];
    $movedDistFile .= '-' . $lTime[3];

    if( -e $movedDistFile ) {
        warning( $0, undef, undef, 'back-up of your current dictionary file '
               . "already exists as '$movedDistFile'", 'operation stopped' );
        return 0;
    }

    if( ! move $localDictFile, $movedDistFile ) {
        error( $0, undef, undef, "unable to create copy '$movedDistFile' "
             . "of your dictionary file '$localDictFile'", lcfirst($!) );
        return 0;
    }

    note( $0, undef, undef, 'created a copy of your dictionary file '
        . "'$localDictFile' as '$movedDistFile'", undef);
    return 1;
}

# Subroutine to replace fetched dictionary file by new one.
# This subroutine uses 'File::Compare' to check, if files are equal.
# There is no need, to replace old file by new if they are equal.
# If files are not equal and old file exists - createCopyOfLocalFile is
# called.
# Parameters:
#     1) string -- path to local dictionary file;
#     2) string -- path to temporary folder where downloaded file resides.
# Example:
#     moveFetchedFileIfDiff '/home/user/.cod/cif_core.dic',
#                           '/tmp/fetch_cif_dict_17531_cif_core.dic'
sub moveFetchedFileIfDiff {
    my ($dictFilePath, $newFilePath) = @_;

    if( -e $dictFilePath ) {
        if( compare($dictFilePath, $newFilePath) == 0 ) {
            note( $0, undef, undef, 'new file does not differ from its '
                . 'previous version', "only its mtime will be changed "
                . 'for further processes' );
            utime undef, undef, $dictFilePath;
            unlink $newFilePath;
            return 0;
        }

        return unless createCopyOfLocalFile $dictFilePath;
    }

    if( ! move $newFilePath, $dictFilePath ) {
        error( $0, undef, undef, 'unable to create new dictionary file '
             . "'$dictFilePath' moving '$newFilePath'", lcfirst($!) );
        unlink $newFilePath;
        return 0;
    }

    note( $0, $dictFilePath, undef, 'new dictionary file was successfuly ' . 
          'downloaded', undef );
    return 1;
}

# Subroutine to fetch dictionary.
# Parameters:
#     1) string -- full FTP address of dictionary to be fecthed;
#     2) int -- time in seconds to cache file (will be checked against 
#         mtime of local file);
#     3) string -- e-mail of user using script (will be used to 
#         authenticate against FTP server);
#     4) int -- this flag forces download if set to higher than 0 (zero) 
#         value;
# Example:
#     fetchDictionary 'ftp://ftp.iucr.org/pub/cif_core.dic', 432000, 
#                       'name@example.com', 0;
sub fetchDictionary {
    my ($dictFileURI, $cacheDuration, $userMail, $forceDownload) =
            (shift, shift, shift, shift);
    $dictFileURI =~ m/^([a-z]+):\/\/([^\/]+)(\/.*\/)([^\/]+)$/s;
    my %ftp = ( 'protocol' => $1,
                'host' => $2,
                'path' => $3,
                'file' => $4
        );

    my $localPath = prepareLocal;
    my $localDictPath = $localPath . $ftp{file};

    return unless $localPath;

    my $temporaryStore = '/tmp';
    if( defined $ENV{TMP}
        && -d $ENV{TMP} ) {
        $ENV{TMP} =~ m/^(.*)\/?$/;
        $temporaryStore = $1;
    }
    $0 =~ m/\/?([^\/]+)$/;
    $temporaryStore .= '/' . $1 . '_' . $$ . '_' . $ftp{file};

    # if dictionary does not exist in local cache, or has expired
    if( $forceDownload == 0
        && -e $localDictPath
        && (stat($localDictPath))[9] < (time() + $cacheDuration) ) {
        warning( $0, $ftp{file}, undef, 'dictionary file already exists in '
               . "local folder as '$localDictPath'", 'operation canceled' );
        return 0;
    }

    # download file
    my $ftpAgent = Net::FTP->new($ftp{host}, Debug => 0, Passive => 1) or die
                  sprintf_message($0, undef, undef, 'ERROR', 'unable to connect'
                                . "to ftp '$ftp{host}'", lcfirst($@));
    $ftpAgent->login('anonymous', $userMail) or die
                  sprintf_message($0, undef, undef, 'ERROR', 'unable to '
                                . 'authenticate', lcfirst($ftpAgent->message) );
    $ftpAgent->cwd($ftp{path}) or die
                   sprintf_message($0, undef, undef, 'ERROR', 'unable to '
                                . "change working directory to '$ftp{path}'",
                                  lcfirst($ftpAgent->message) );
    $ftpAgent->get($ftp{file}, $temporaryStore) or die
                   sprintf_message($0, undef, undef, 'ERROR', 'unable to fetch'
                                . "file '$ftp{file}'", 
                                   lcfirst($ftpAgent->message));
    note( $0, $dictFileURI, undef, 'succesfully downloaded the dictionary and '
        . "stored it as '$temporaryStore' for further processing", undef );
    $ftpAgent->quit;

    # attempt to replace file
    return moveFetchedFileIfDiff $localDictPath, $temporaryStore;
}
