#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Parse a CIF file and print out essential data values in the CIF
#  format, the COD CIF style.
#
#  This script has also many capabilities -- it can restore spacegroup
#  symbols from symmetry operators (consulting pre-defined tables),
#  parse and tidy-up _chemical_formula_sum, compute cell volume,
#  exclude unknown or "empty" tags, and add specified bibliography data.
#**

use strict;
use warnings;
use File::Basename;
use COD::CIF::Parser qw( parse_cif );
use COD::Cell qw(cell_volume);
use COD::CIF::Tags::DictTags;
use COD::CIF::Tags::COD;
use COD::CIF::Tags::AMCSD;
use COD::CIF::Tags::TCOD;
use COD::CIF::Tags::DFT;
use COD::CIF::Tags::Excluded;
use COD::CIF::Tags::Manage;
use COD::CIF::Tags::Print;
use COD::CIF::Tags::CanonicalNames;
use COD::Spacegroups::Names;
use COD::Spacegroups::Symop::Parse;
use COD::Spacegroups::Symop::SSGParse qw(symop_from_ssg_operator);
use COD::Spacegroups::Lookup::COD;
use COD::Formulae::Parser::AdHoc;
use COD::CIF::Unicode2CIF;
use COD::UserMessage qw(warning error prefix_dataname);
use COD::SOptions;
use COD::SUsage;

sub mk_symop_key
{
    my ( $symops ) = @_;

    my @canonical = sort 
        map {symop_string_canonical_form($_)} @$symops;
    my $key = join( ";", @canonical );
    return $key;
}

sub mkhash
{
    if( 1 ) {
        map { (mk_symop_key($_->{symops}), $_) }
        @COD::Spacegroups::Lookup::COD::table,
        @COD::Spacegroups::Lookup::COD::extra_settings;
    #} else {
    #    map { (mk_symop_key($_->{symops}), $_) }
    #    @COD::Spacegroups::Lookup::CCP4::table;
    }
}

my %symop_lookup_table;
## my %symop_lookup_table = mkhash();

sub merge_new_tag_values($$$);

my $user_biblio = 0;
my $leave_biblio = 0;
my $leave_title = 0;
my $global_priority = 0; # if set to says that bibliography in
                         # 'data_global' has priority over
                         # bibliography in each other datablock.
my $estimate_spacegroup = 0;
my $exclude_empty_tags = 0;
my $exclude_empty_non_loop_tags = 0;
my $exclude_unknown_tags = 0;
my $exclude_unknown_non_loop_tags = 0;
my $preserve_tag_order = 0;
my $preserve_loop_order = 0;
my $reformat_spacegroup = 0;
my $keep_unrecognised_spacegroups = 0;
my $calculate_cell_volume = 0;
my $record_original_filename = 0;
my $exclude_misspelled_tags = 0;
my $fold_long_fields = 0;
my $fold_title = 0;
my $folding_width = 76;
my $exclude_publ_details = 1;
my $use_parser = "c";
my $parse_formula_sum = 0;
my $fix_errors = 0;
my $use_datablocks_without_coord = 0;
my $use_datablocks_with_fobs = 1;
my $update_database_code = 1; # Specifies whether to update
                              # _cod_database_code tag value upon
                              # renumbering.
my $database_code_tag = '_cod_database_code'; # Tag for database code.

my $extra_tag_file;
my $original_filename;

my $journal;
my $volume;
my $doi;
my $issue;
my $start_page;
my $end_page;
my $year;
my $title;
my @authors;
my $biblio; # A bibliography file name, possibly marked up by XML-like
            # or LaTeX-like tags.

my $cif_comment_header; # A header with comments to printed at the
                        # beginning of the output CIF file.

my $cif_header_file; # The name of an external file that holds a CIF
                     # header.

my $data_block_nr; # If defined, specifies that data blocks should be
                   # numbered in a COD-like fasion.

my $datablock_format = "%07d";

my %spacegroups = map {
    my $key1 = $_->[1];
    my $key2 = $_->[2];
    $key1 =~ s/\s//g;
    $key2 =~ s/\s//g;
    ($key1, $_->[2], $key2, $_->[2] )
} @COD::Spacegroups::Names::names;

#* USAGE:
#*     $0 [options] input.cif [input2.cif ...]
#* 
#* OPTIONS:
#*    -j, --journal 'Acta Cryst. A'
#*    -v, --volume    36
#*    -i, --issue      1
#*    -p, --page     123
#*    --start-page   123
#*    -e, --end-page 132
#*    -y, --year     1999
#*    -D, --doi      10.1010/xyz9999
#*        Specify bibliographic data to be included into the output.
#*
#*    -B, --bibliography bibliography.cif
#*    --bibliography bibliography.mrk
#*        Provide a bibliography file, 'bibliography.mrk' in this example,
#*        with the bibliographic information to be included into the output.
#*        The bibliography information can be provided in CIF format or in
#*        a XML-like .mrk file with data items between <authors>, <journal>,
#*        <volume>, <issue>, <year>, <pages>123-132</pages> tags.
#*    
#*    -h, --add-cif-header header_file.cif
#*        Prepend each of the output files with the comments from the
#*        beginning of the specified file.
#*
#*    -s, --estimate-spacegroup
#*    -s-, --dont-estimate-spacegroup, --no-estimate-spacegroup
#*        Estimate spacegroup symbols from the symmetry operators in the
#*        input.
#*
#*    -x,--extra-tag-list tag-list.lst
#*
#*    --exclude-empty-tags
#*    --dont-exclude-empty-tags, --no-exclude-empty-tags
#*
#*    --exclude-unknown-tags
#*    --dont-exclude-unknown-tags, --no-exclude-unknown-tags
#*
#*    --exclude-misspelled-tags
#*    --dont-exclude-misspelled-tags, --no-exclude-misspelled-tags
#*
#*    --keep-unrecognised-spacegroups
#*    --dont-keep-unrecognised-spacegroups, --no-keep-unrecognised-spacegroups
#*
#*    --parse-formula-sum
#*    --dont-parse-formula-sum, --no-parse-formula-sum
#*
#*    --fix-syntax-errors
#*    --dont-fix-syntax-errors, --no-fix-syntax-errors
#*
#*    --preserve-loop-order
#*    --use-internal-loop-order
#*
#*    --retain-tag-order
#*    --dont-retain-tag-order
#*
#*    --reformat-space-group, --reformat-spacegroup
#*          Correct the formatting of Hermann-Mauguin symmetry space group
#*          symbol.
#*
#*    --dont-reformat-space-group, --leave-space-group
#*    --dont-reformat-spacegroup, --leave-spacegroup
#*          Leave the Hermann-Mauguin symmetry space group as is. Default
#*          action.
#*
#*    --calculate-cell-volume
#*    --dont-calculate-cell-volume
#*
#*    --original-filename data_source.cif
#*
#*    --clear-original-filename
#*
#*    --record-original-filename
#*    --dont-record-original-filename
#*
#*    --update-database-code
#*    --dont-update-database-code
#*
#*    --database-code-tag _cod_database_code
#*
#*    -S, --start-data-block-number 1234567
#*
#*    -R, --renumber-data-blocks
#*    -R-, --dont-renumber-data-blocks
#*
#*    --use-datablocks-without-coordinates
#*          Do not filter out datablocks without coordinates.
#*    
#*    --do-not-use-datablocks-without-coordinates, --use-all-datablocks
#*    --dont-use-datablocks-without-coordinates
#*    --no-use-datablocks-without-coordinates
#*    --skip-datablocks-without-coordinates
#*          Filter out datablocks without coordinates. Default action.
#*
#*    --use-datablocks-with-structure-factors
#*    --dont-use-datablocks-with-structure-factors
#*    --no-use-datablocks-with-structure-factors
#*    --skip-datablocks-with-structure-factors
#*
#*    --folding-width 78
#*          Specify the length of the longest unfolded line.
#*
#*    --fold-title
#*    --dont-fold-title
#*          Folds the title, if longer than folding width. Default: off.
#*
#*    --fold-long-fields
#*    --dont-fold-long-fields
#*          Fold fields, longer than folding width. Default: off.
#*
#*    --use-perl-parser
#*          Use Perl parser for CIF parsing.
#*
#*    --use-c-parser
#*          Use Perl & C parser for CIF parsing.
#*
#*    --leave-bibliography
#*    --discard-bibliography
#*
#*    --exclude-publication-details
#*    --dont-exclude-publication-details, --no-exclude-publication-details
#*
#*    --leave-title
#*    --help,--usage         Print a short usage message (this message) and exit.
#**

@ARGV = getOptions( 
    "-a,--authors"      => sub{ $user_biblio = 1;
                                @authors = split( /(?:;|:)\s*/,
                                                  get_value()) },
    "-j,--journal"      => sub{ $user_biblio = 1; $journal = get_value() },
    "-v,--volume"       => sub{ $user_biblio = 1; $volume = get_value() },
    "-i,--issue"        => sub{ $user_biblio = 1; $issue = get_value() },
    "-p,--page"         => sub{ $user_biblio = 1; $start_page = get_value() },
    "--start-page"      => sub{ $user_biblio = 1; $start_page = get_value() },
    "-e,--end-page"     => sub{ $user_biblio = 1; $end_page = get_value() },
    "-y,--year"         => sub{ $user_biblio = 1; $year = get_value() },
    "-D,--doi"          => sub{ $user_biblio = 1; $doi = get_value() },
    "-B,--bibliography" => \$biblio,

    "-d,--datablock-format" => \$datablock_format,

    "-g,--global-priority"     => sub { $global_priority = 1 },
    "-g-,--no-global-priority" => sub { $global_priority = 0 },

    "-h,--add-cif-header" => \$cif_header_file,

    "-s,--estimate-spacegroup" => sub { $estimate_spacegroup = 1; },
    "-s-,--dont-estimate-spacegroup" => sub { $estimate_spacegroup = 0; },
    "--no-estimate-spacegroup" => sub { $estimate_spacegroup = 0; },

    "-x,--extra-tag-list" => \$extra_tag_file,

    "--exclude-empty-tags"      => sub { $exclude_empty_tags = 1; },
    "--dont-exclude-empty-tags" => sub { $exclude_empty_tags = 0; },
    "--no-exclude-empty-tags"   => sub { $exclude_empty_tags = 0; },

    "--exclude-empty-non-loop-tags"      => sub { $exclude_empty_non_loop_tags = 1; },
    "--dont-exclude-non-loop-empty-tags" => sub { $exclude_empty_non_loop_tags = 0; },
    "--no-exclude-non-loop-empty-tags"   => sub { $exclude_empty_non_loop_tags = 0; },

    "--exclude-unknown-tags"      => sub { $exclude_unknown_tags = 1; },
    "--dont-exclude-unknown-tags" => sub { $exclude_unknown_tags = 0; },
    "--no-exclude-unknown-tags"   => sub { $exclude_unknown_tags = 0; },

    "--exclude-unknown-non-loop-tags"      => sub { $exclude_unknown_non_loop_tags = 1; },
    "--dont-exclude-non-loop-unknown-tags" => sub { $exclude_unknown_non_loop_tags = 0; },
    "--no-exclude-non-loop-unknown-tags"   => sub { $exclude_unknown_non_loop_tags = 0; },

    "--exclude-misspelled-tags"      => sub { $exclude_misspelled_tags = 1; },
    "--dont-exclude-misspelled-tags" => sub { $exclude_misspelled_tags = 0; },
    "--no-exclude-misspelled-tags"   => sub { $exclude_misspelled_tags = 0; },

    "--keep-unrecognised-spacegroups"
        => sub { $keep_unrecognised_spacegroups = 1; },
    "--dont-keep-unrecognised-spacegroups"
        => sub { $keep_unrecognised_spacegroups = 0; },
    "--no-keep-unrecognised-spacegroups"
        => sub { $keep_unrecognised_spacegroups = 0; },

    "--parse-formula-sum"       => sub { $parse_formula_sum = 1; },
    "--dont-parse-formula-sum"  => sub { $parse_formula_sum = 0; },
    "--no-parse-formula-sum"    => sub { $parse_formula_sum = 0; },

    "--fix-syntax-errors"       => sub { $fix_errors = 1; },
    "--dont-fix-syntax-errors"  => sub { $fix_errors = 0; },
    "--no-fix-syntax-errors"    => sub { $fix_errors = 0; },

    "--preserve-loop-order"     => sub { $preserve_loop_order = 1; },
    "--use-internal-loop-order" => sub { $preserve_loop_order = 0; },

    "--retain-tag-order"        => sub { $preserve_tag_order = 1; },
    "--dont-retain-tag-order"   => sub { $preserve_tag_order = 0; },

    "--reformat-space-group"      => sub { $reformat_spacegroup = 1; },
    "--dont-reformat-space-group" => sub { $reformat_spacegroup = 0; },
    "--leave-space-group"         => sub { $reformat_spacegroup = 0; },

    "--reformat-spacegroup"       => sub { $reformat_spacegroup = 1; },
    "--dont-reformat-spacegroup"  => sub { $reformat_spacegroup = 0; },
    "--leave-spacegroup"          => sub { $reformat_spacegroup = 0; },

    "--calculate-cell-volume"      => sub { $calculate_cell_volume = 1; },
    "--dont-calculate-cell-volume" => sub { $calculate_cell_volume = 0; },

    "--original-filename" => sub { $original_filename = &get_value;
                                   $record_original_filename = 1 },
    "--clear-original-filename" => sub { undef $original_filename },

    "--record-original-filename"      => sub { $record_original_filename = 1; },
    "--dont-record-original-filename" => sub { $record_original_filename = 0; },

    "--update-database-code"          => sub { $update_database_code = 1; },
    "--dont-update-database-code"     => sub { $update_database_code = 0; },

    "--database-code-tag" => \$database_code_tag,

    "-S,--start-data-block-number"    => \$data_block_nr,
    "-R,--renumber-data-blocks"       => sub { $data_block_nr = 7000001 },
    "-R-,--dont-renumber-data-blocks" => sub { undef $data_block_nr },

    "--use-datablocks-without-coordinates"
        => sub{ $use_datablocks_without_coord = 1 },
    "--use-all-datablocks"
        => sub{ $use_datablocks_without_coord = 1 },

    "--do-not-use-datablocks-without-coordinates"
        => sub{ $use_datablocks_without_coord = 0 },
    "--dont-use-datablocks-without-coordinates"
        => sub{ $use_datablocks_without_coord = 0 },
    "--no-use-datablocks-without-coordinates"
        => sub{ $use_datablocks_without_coord = 0 },
    "--skip-datablocks-without-coordinates"
        => sub{ $use_datablocks_without_coord = 0 },

    "--use-datablocks-with-structure-factors"
        => sub{ $use_datablocks_with_fobs = 1 },
    "--dont-use-datablocks-with-structure-factors"
        => sub{ $use_datablocks_with_fobs = 0 },
    "--no-use-datablocks-with-structure-factors"
        => sub{ $use_datablocks_with_fobs = 0 },
    "--skip-datablocks-with-structure-factors"
        => sub{ $use_datablocks_with_fobs = 0 },

    "--folding-width"         => \$folding_width,
    "--fold-title"            => sub{ $fold_title = 1 },
    "--dont-fold-title"       => sub{ $fold_title = 0 },
    "--fold-long-fields"      => sub{ $fold_long_fields = 1 },
    "--dont-fold-long-fields" => sub{ $fold_long_fields = 0 },

    "--use-perl-parser"       => sub{ $use_parser = "perl" },
    "--use-c-parser"          => sub{ $use_parser = "c" },

    "--leave-bibliography"   => sub{ $leave_biblio = 1 },
    "--discard-bibliography" => sub{ $leave_biblio = 0 },

    "--exclude-publication-details"      => sub{ $exclude_publ_details = 1 },
    "--dont-exclude-publication-details" => sub{ $exclude_publ_details = 0 },
    "--no-exclude-publication-details"   => sub{ $exclude_publ_details = 0 },

    "--leave-title"          => sub{ $leave_title  = 1 },
    "--help,--usage" => sub { usage; exit },
);

my @extra_tags = ();

if( $extra_tag_file ) {
    open( EXTRA, "$extra_tag_file" ) or
        die( "could not open tag list '$extra_tag_file' for reading: $!" );
    @extra_tags = map {s,\s,,g;lc($_)} map {split} grep /^\s*_/, <EXTRA>;
    close( EXTRA ) or
        die( "error while closing file '$extra_tag_file' after reading" );

    ## local $, = "\n"; local $\ = "\n";
    ## print @extra_tags;
}

my %excluded_tags  = map { ($_,$_) } @COD::CIF::Tags::Excluded::tag_list;

my @dictionary_tags = ( @COD::CIF::Tags::DictTags::tag_list,
                        @COD::CIF::Tags::COD::tag_list,
                        @COD::CIF::Tags::AMCSD::tag_list,
                        @COD::CIF::Tags::TCOD::tag_list,
                        @COD::CIF::Tags::DFT::tag_list,
                        @extra_tags );

my %dictionary_tags = map { $_, $_ } @dictionary_tags;

if( defined $cif_header_file ) {
    open( HEADER, "$cif_header_file" ) or
        die( "could not open CIF header file '$cif_header_file' for reading: $!" );
    # local $/; # enable "slurp" mode: read the whole header file.
    $cif_comment_header = "";
    while( <HEADER> ) {
        last unless /^\#|^\s*$/;
        $cif_comment_header .= $_;
    }
    close( HEADER ) or
        die( "error while closing file '$cif_header_file' after reading" );
}

my $reference;
my $biblio_blocks;

if( defined $biblio ) {
    if( $biblio =~ /\.cif/i ) {
        my ($err_count, $messages);
        # For now, always use Perl parser for bibliographies, since C
        # parser is not (yet) reenterable :(: (still applicable?)
        my $biblio_options = { parser     => 'perl',
                               no_print   => 1,
                               fix_errors => 1 };

        ($biblio_blocks, $err_count, $messages) =
                                            parse_cif($biblio, $biblio_options);

        print STDERR $_ foreach ( @$messages );
        if( $err_count > 0 ) {
            error( $0, $biblio, undef, "$err_count error(s) "
                 . 'encountered while parsing the file', undef );
            die;
        }
    } else {
        open( BIBLIO, "<:utf8", $biblio ) or
            die( "Could not open file '$biblio' for reading: $!" );
        if( $biblio =~ /\.ref/ ) {
            $reference = <BIBLIO>; # read the first line
        } elsif( $biblio =~ /\.xrf/ ) {
            my @reference = grep !/^\#/, <BIBLIO>;
            $reference = $reference[0]; # read the first non-comment line
        } else {
            local $/ = undef; # read the whole file
            $reference = <BIBLIO>;
        }
        close BIBLIO;
        chomp $reference;
    }
}

@ARGV = ( "-" ) unless @ARGV;

for my $filename (@ARGV) {
    my $options = { parser     => $use_parser,
                    no_print   => 1,
                    fix_errors => $fix_errors };

    my ($data, $err_count, $messages) = parse_cif($filename, $options);

    print STDERR $_ foreach @$messages;
    if( $err_count > 0 ) {
        error( $0, $filename, undef, "$err_count error(s) "
             . 'encountered while parsing the file', undef );
        die;
    }

    if( !@$data || !defined $data->[0] || !defined $data->[0]{name} ) {
        warn( "file '$filename' seems to be empty" );
        next;
    }

#------------------------------------------------------------------------------

    my %global_bibliography = ();
    my @global_biblio_keys = (
        "_journal_name_full",
        "_journal_volume",
        "_journal_issue",
        "_journal_page_first",
        "_journal_page_last",
        "_journal_year",
        "_publ_section_title",
        "_publ_author_name",
        "_journal_coeditor_code",
        "_journal_paper_doi"
        );

    my %global_biblio_keys = map {($_,$_)} @global_biblio_keys;

#
# First, look for a data_global section and extract bibliography
# information. Stupidly enough, this section can be in the very end of
# the CIF file, so we need to scan all sections to find it.
#

    my $global_section_nr = 0;

    for my $dataset (@$data) {
        next unless $dataset->{name} eq "global";
        my $datablock = $dataset->{values};

        $global_section_nr ++;

        %global_bibliography = ();

        merge_new_tag_values( \@global_biblio_keys, \%global_bibliography,
                              $dataset );

        ## use COD::ShowStruct; showRef( \%global_bibliography );
    }

    if( $global_section_nr > 1 ) {
        warn "file '${filename}' had $global_section_nr global sections, "
            . "taking one into account, other were removed"
    }

#
# Locate publication and overall information datablocks in powder
# diffraction CIF files. Publication datablock is recognised as having
# _audit_*, _publ_* or _journal_* tags and having no coordinates or
# structure factors. Overall information datablock contains both
# _pd_phase_block_id and _pd_block_diffractogram_id loops.
# See Toby et al., Journal of Applied Crystallography (2003).
#

    my $pd_datablocks = grep( $_->{values}{_pd_block_id}, @$data );

    my %pd_global_publ_data = ();

    my $pd_publ_datablock_nr = 0;
    my $pd_overall_info_datablock_nr = 0;

    if( $pd_datablocks > 0 ) {
        for my $dataset (@$data) {
            my $datablok = $dataset->{values};
            if( exists $datablok->{_pd_phase_block_id} &&
                exists $datablok->{_pd_block_diffractogram_id} ) {
                $pd_overall_info_datablock_nr++;
            } elsif( grep( /^_(audit|publ|journal)_*/, keys %$datablok ) > 0 &&
                     grep( /^_refln_index_.$/, keys %$datablok ) == 0 &&
                     !exists $datablok->{_atom_site_label} ) {
                $pd_publ_datablock_nr++;
            } else {
                next;
            }

            merge_new_tag_values( [ grep( !/^(_pd_block_id|
                                              _pd_phase_block_id|
                                              _pd_block_diffractogram_id)$/x,
                                          keys %$datablok ) ],
                                  \%pd_global_publ_data,
                                  $dataset );
        }
    }

    if( $pd_publ_datablock_nr > 1 ) {
        warn "file '${filename}' had $pd_publ_datablock_nr powder "
            . "diffraction publication sections, taking one "
            . "into account, other were removed"
    }

    if( $pd_overall_info_datablock_nr > 1 ) {
        warn "file '${filename}' had $pd_overall_info_datablock_nr "
            . "powder overall information datablocks, taking one "
            . "into account, other were removed"
    }

    # Assume that there are no datablocks with coordinates until a datablock
    # with coordinates is found 

    my $no_coordinates = 1;

    binmode( STDOUT, ":utf8" );

    for my $dataset (@$data) {

        ## next unless defined $dataset->{kind} && $dataset->{kind} == "DATA";

        my $datablok = $dataset->{values};
        my $dataname = prefix_dataname($dataset->{name});

        # Add bibliography from a global section, if any:

        if( %global_bibliography ) {
            merge_new_tag_values( [keys %{$global_bibliography{values}}],
                                  $dataset, \%global_bibliography );
        }

        if( $pd_publ_datablock_nr ) {
            merge_new_tag_values( [keys %{$pd_global_publ_data{values}}],
                                  $dataset, \%pd_global_publ_data );
        }

        # convert all tags to a "cannonical" form:

        canonicalize_names( $dataset );

        next if !defined $datablok;
        next if !$use_datablocks_without_coord &&
                !defined $datablok->{_atom_site_label} &&
                ( grep( /^_refln_index_.$/, keys %$datablok ) == 0 ||
                  !$use_datablocks_with_fobs );

        $no_coordinates = 0;

        ## print "\n" if $n > 0;

        # Remove empty tags, if requested:

        if( $exclude_empty_tags ) {
            exclude_empty_tags( $dataset );
        }

        if( $exclude_empty_non_loop_tags ) {
            exclude_empty_non_loop_tags( $dataset );
        }

        # Remove unknown tags, if requested:

        if( $exclude_unknown_tags ) {
            exclude_unknown_tags( $dataset );
        }

        if( $exclude_unknown_non_loop_tags ) {
            exclude_unknown_non_loop_tags( $dataset );
        }

        # Process the bibliography file that was supplied on the command
        # line:

        if( defined $biblio_blocks ) {
            my $bibdata;

            if( @{$biblio_blocks} > 1 ) {
                warn "file '${biblio}' has @{$biblio_blocks} --" .
                    "will take bibliography from a datablock "  .
                    "that has the same name as the coordinate datablock";
                for my $block (@{$biblio_blocks}) {
                    if( $block->{name} eq $dataset->{name} ) {
                        $bibdata = $block->{values};
                        last
                    }
                }
            } else {
                $bibdata = $biblio_blocks->[0]{values};
            }
            if( !defined $bibdata ) {
                warn "file '${biblio}' matching bibliography datablock " .
                    "for '$dataset->{name}' --"  .
                    "no bibliography wil be taken for this datablock";
            } else {
                if( !$leave_biblio ) {
                    for my $key ( grep /_journal_|_publ_section_title|_author_/,
                                  keys %{$datablok} ) {
                        if( $key ne "_journal_coeditor_code" ) {
                            if( $key ne "_publ_section_title" || !$leave_title ) {
                                exclude_tag( $dataset, $key );
                            }
                        }
                    }
                }
                for my $bibtag (@global_biblio_keys) {
                    if( !exists $datablok->{$bibtag} &&
                        exists $bibdata->{$bibtag}) {
                        $datablok->{$bibtag} = $bibdata->{$bibtag};
                        if( $bibtag eq "_publ_author_name" ) {
                            if( exists $dataset->{inloop}{$bibtag} ) {
                                my $loop_nr = $dataset->{inloop}{$bibtag};
                                $dataset->{loops}[$loop_nr] = [ $bibtag ];
                            } else {
                                if( exists $dataset->{loops} ) {
                                    push( @{$dataset->{loops}}, [ $bibtag ] );
                                    $dataset->{inloop}{$bibtag} = $#{$dataset->{loops}};
                                } else {
                                    $dataset->{inloop}{$bibtag} = 0;
                                    $dataset->{loops} = [ [ $bibtag ] ];
                                }
                            }
                        }
                    }
                }
            }
        } elsif( defined $reference ) {
            if( !$leave_biblio ) {
                for my $key ( grep /_journal_|_publ_section_title|_author_/,
                              keys %{$datablok} ) {
                    if( $key ne "_journal_coeditor_code" ) {
                        if( $key ne "_publ_section_title" || !$leave_title ) {
                            exclude_tag( $dataset, $key );
                        }
                    }
                }
            }

            if( $reference =~ /<.*?>.*?<.*?>/s ||
                $reference =~ /\\.*?(?:\[.*?\])?\{.*?\}/s ) {
                if( !$title && ( $reference =~ /<title>(.*?)<\/title>/s ||
                                 $reference =~ /\\title\{(.*?)\}/s )) {
                    my $cif_title = unicode2cif( $1 );
                    $cif_title =~ s/\n/ /g;
                    $datablok->{_publ_section_title} = [
                        "\n" . join( "\n", map { " " . $_ }
                                     fold( 71, " +", " ", $cif_title ))
                        ];
                }
                if( !$journal && ( $reference =~ /<journal>(.*?)<\/journal>/s ||
                                   $reference =~ /\\journal\{(.*?)\}/s )) {
                    $datablok->{_journal_name_full} = [ unicode2cif( $1 ) ];
                }
                if( !$issue && ( $reference =~ /<issue>(.*?)<\/issue>/s ||
                                 $reference =~ /\\issue\{(.*?)\}/s )) {
                    $datablok->{_journal_issue} = [ unicode2cif( $1 ) ];
                }
                if( !$volume && ( $reference =~ /<volume>(.*?)<\/volume>/s ||
                                  $reference =~ /\\volume\{(.*?)\}/s )) {
                    $datablok->{_journal_volume} = [ unicode2cif( $1 ) ];
                }
                if( !$year && ( $reference =~ /<year>(.*?)<\/year>/s ||
                                $reference =~ /\\year\{(.*?)\}/s )) {
                    my $y = $1;
                    $y =~ s/[^0-9]//g;
                    $datablok->{_journal_year} = [ unicode2cif( $y ) ];
                }
                if( !$doi && ( $reference =~ /<doi>(.*?)<\/doi>/s ||
                                  $reference =~ /\\doi\{(.*?)\}/s )) {
                    $datablok->{_journal_paper_doi} = [ unicode2cif( $1 ) ];
                }
                if( !$start_page && ( $reference =~ /<pages?>(.*?)<\/pages?>/s ||
                                      $reference =~ /\\pages?\{(.*?)\}/s )) {
                    my @pages = map { s/\s//g; $_ } split ( "-", $1 );
                    $datablok->{_journal_page_first} = [ unicode2cif( $pages[0] ) ];
                    if( int(@pages) > 1 ) {
                        $datablok->{_journal_page_last} =
                            [ unicode2cif( $pages[1] ) ];
                    }
                }
                if( !@authors && ( $reference =~
                                   /<authors?\s?(.*?)>(.*?)<\/authors?>/s ||
                                   $reference =~
                                   /\\authors?(?:\[(.*?)\])?\{(.*?)\}/s )) {
                    my $attributes = $1;
                    my $author_list = $2;
                    my $separator = qr/,\s*and|\sand\s|,/;
                    if( $attributes && $attributes =~ /separator\s*=\s*"(.*?)"/ ) {
                        $separator = qr/$1/;
                    }
                    $datablok->{_publ_author_name} =
                        [
                         map { unicode2cif( $_ ) }
                         map { s/\n/ /g; s/\s+/ /g; $_ }
                         map { s/^\s*|\s*$//g; $_ }
                         split( $separator, $author_list )
                        ];
                    my $tag = "_publ_author_name";
                    if( exists $dataset->{inloop}{$tag} ) {
                        my $loop_nr = $dataset->{inloop}{$tag};
                        $dataset->{loops}[$loop_nr] = [ $tag ];
                    } else {
                        if( exists $dataset->{loops} ) {
                            push( @{$dataset->{loops}}, [ $tag ] );
                            $dataset->{inloop}{$tag} = $#{$dataset->{loops}};
                        } else {
                            $dataset->{inloop}{$tag} = 0;
                            $dataset->{loops} = [ [ $tag ] ];
                        }
                    }
                }
            }
        }

        # User specified bibliography is processed last since it must take
        # precedence over the original CIF bibliography and over the
        # bibliography file data:

        if( $user_biblio ) {
            if( !$leave_biblio ) {
                for my $key ( grep /_journal_|_publ_section_title|_author_/,
                              keys %{$datablok} ) {
                    if( $key ne "_publ_section_title" || !$leave_title ) {
                        exclude_tag( $dataset, $key );
                    }
                }
            }

            do {
                use Encode 'decode_utf8';
                ## use encoding 'utf8';
                @authors = map { s/\n/ /g; s/\s+/ /g; $_ }
                           map { s/^\s*|\s*$//g; $_ }
                           map { unicode2cif( $_ ) }
                           # Insist that the names are well-formed utf8:
                           map { decode_utf8($_) }
                           # This does not work, alas:
                           ## map { pack("U*", unpack("C*", $_ )) }
                           @authors;
                $datablok->{_publ_author_name} = [ @authors ];
                my $tag = "_publ_author_name";
                if( exists $dataset->{inloop}{$tag} ) {
                    my $loop_nr = $dataset->{inloop}{$tag};
                    $dataset->{loops}[$loop_nr] = [ $tag ];
                } else {
                    if( exists $dataset->{loops} ) {
                        push( @{$dataset->{loops}}, [ $tag ] );
                        $dataset->{inloop}{$tag} = $#{$dataset->{loops}};
                    } else {
                        $dataset->{inloop}{$tag} = 0;
                        $dataset->{loops} = [ [ $tag ] ];
                    }
                }
            } if @authors;

            $datablok->{_publ_section_title} = [ $title ]
                if defined $title;

            $datablok->{_journal_name_full} = [ $journal ]
                if defined $journal;

            $datablok->{_journal_year} = [ $year ]
                if defined $year;

            $datablok->{_journal_volume} = [ $volume ]
                if defined $volume;

            $datablok->{_journal_issue} = [ $issue ]
                if defined $issue;

            $datablok->{_journal_page_first} = [ $start_page ]
                if defined $start_page;

            $datablok->{_journal_page_last} = [ $end_page ]
                if defined $end_page;

            $datablok->{_journal_paper_doi} = [ $doi ]
                if defined $doi;
        }

        # Restore the full final page number if only trailing digits of
        # the _journal_page_last are given:

        if( defined $datablok->{_journal_page_first} &&
            defined $datablok->{_journal_page_last} &&
            $datablok->{_journal_page_first}[0] =~ /^[0-9]+$/ &&
            $datablok->{_journal_page_last}[0] =~ /^[0-9]+$/ &&
            $datablok->{_journal_page_first}[0] >
            $datablok->{_journal_page_last}[0] ) {
            $datablok->{_journal_page_last}[0] =
                restore_last_page( $datablok->{_journal_page_first}[0],
                                   $datablok->{_journal_page_last}[0] );
        }

        # Fold title if requested:

        if( $fold_title && exists $datablok->{_publ_section_title} ) {
            my $cif_title = join( " ", @{$datablok->{_publ_section_title}} );
            $cif_title =~ s/\n/ /g;
            $datablok->{_publ_section_title} = [
                "\n" . join( "\n", map { " " . $_ }
                             fold( $folding_width - 2, " +", " ", $cif_title ))
                ];
        }

        # Exclude potentially copyrighted and irrelevant tags if requested:

        if( $exclude_publ_details ) {
            my @tag_list = @{$dataset->{tags}};
            for my $tag (@tag_list) {
                if( exists $excluded_tags{$tag} || $tag =~ /^_vrf_/ ) {
                    exclude_tag( $dataset, $tag );
                    #use COD::ShowStruct;
                    #showRef( $dataset );
                }
            }
        }

        # Check for misspelled tags:

        for my $tag (@{$dataset->{tags}}) {
            unless( exists $dictionary_tags{$tag} ) {
                warning( $0, $filename, $dataname,
                         "tag '$tag' is not recognised", undef );
            }
        }

        # Exclude the misspelled tags if requested:

        if( $exclude_misspelled_tags ) {
            my @tag_list = @{$dataset->{tags}};
            for my $tag (@tag_list) {
                unless( exists $dictionary_tags{$tag} ) {
                    exclude_tag( $dataset, $tag );
                }
            }
        }

        # Add the data source file name, if requested:

        if( $record_original_filename ) {
            my $basename;
            if( defined $original_filename ) {
                $basename = File::Basename::basename( $original_filename );
            } elsif( defined $filename && $filename ne "-" ) {
                $basename = File::Basename::basename( $filename );
            } else {
                $basename = "?";
            }
            set_tag( $dataset, "_cod_data_source_file", $basename );
            set_tag( $dataset, "_cod_data_source_block", $dataset->{name} );
        }

        # Clean up the resulting CIF data structure:

        for my $excluded_tag (qw( _publ_author_address
                              _publ_author.address
                              _publ_author_email
                              _publ_author.email
                              _publ_author_footnote
                              _publ_author.footnote
                              _publ_author_id_iucr
                              _publ_author.id_iucr )) {
            if( exists $datablok->{$excluded_tag} ) {
                exclude_tag( $dataset, $excluded_tag );
                #use COD::ShowStruct;
                #showRef( $dataset );
            }
        }

        # Correct the formatting of the H-M spacegroup symbol:

        if( $reformat_spacegroup ) {
            for my $sg_tag (qw (
            _symmetry_space_group_name_H-M
            _space_group_name_H-M_alt
            _space_group.name_H-M_full
        )) {
                ##use COD::ShowStruct;
                ##showRef( \%spacegroups  );
                if( exists $datablok->{$sg_tag} ) {
                    my $clean_sg = $datablok->{$sg_tag}[0];
                    $clean_sg =~ s/[()~_\s]//g;
                    ##print ">>> $clean_sg\n";
                    if( exists $spacegroups{$clean_sg} ) {
                        my $original_sg_H_M = $datablok->{$sg_tag}[0];
                        if( $sg_tag eq "_symmetry_space_group_name_H-M" &&
                            $original_sg_H_M ne '?' &&
                            $original_sg_H_M ne $spacegroups{$clean_sg} &&
                            !exists $datablok->{"_[local]_cod_cif_authors_sg_H-M"} &&
                            !exists $datablok->{"_cod_cif_authors_sg_H-M"} &&
                            !exists $datablok->{"_cod_original_sg_symbol_H-M"} ) {
                            set_tag( $dataset, "_cod_cif_authors_sg_H-M",
                                     $original_sg_H_M );
                        }
                        $datablok->{$sg_tag}[0] = $spacegroups{$clean_sg};
                    }
                }
            }
        }

        # If no 3D spacegroup information is provided but a SSG
        # (superspacegroup) operators are provided, extract an averge space-group (?)

        if( $estimate_spacegroup &&
            !(exists $datablok->{"_space_group_symop_operation_xyz"} or 
              exists $datablok->{"_symmetry_equiv_pos_as_xyz"}) &&
            exists $datablok->{"_space_group_symop_ssg_operation_algebraic"} ) {
            my $ssg_symops =
                $datablok->{"_space_group_symop_ssg_operation_algebraic"};

            use COD::Spacegroups::Builder;
            
            my $spacegroup = new COD::Spacegroups::Builder;
            for my $ssgop (@$ssg_symops) {
                my $matrix = 
                    COD::Spacegroups::Symop::SSGParse::symop_from_string
                    ( $ssgop );
                my $symop3d = symop_from_ssg_operator( $matrix );
                $spacegroup->insert_symop( $symop3d );
            }
            my @symops = $spacegroup->all_symops();
            set_loop_tag( $dataset, "_space_group_symop_id",
                          undef, # set the new in_loop ID
                          [ 1 .. scalar(@symops) ]  );
            set_loop_tag( $dataset, "_space_group_symop_operation_xyz",
                          "_space_group_symop_id", # in_loop ID
                          [ map {string_from_symop($_)} @symops ] );
        }

        # Determine space group symbols from symmetry elements if requested:

        if( $estimate_spacegroup ) {
            if( !%symop_lookup_table ) {
                %symop_lookup_table = mkhash();
            }

            my @symops;
            if( exists $datablok->{"_space_group_symop_operation_xyz"} ) {
                @symops = @{$datablok->{"_space_group_symop_operation_xyz"}};
            } elsif( exists $datablok->{"_symmetry_equiv_pos_as_xyz"} ) {
                @symops = @{$datablok->{"_symmetry_equiv_pos_as_xyz"}};
            }
            
            if( @symops ) {
                my $has_errors = 0;
                for my $symop (@symops) {
                    my $error = check_symmetry_operator( $symop );
                    if( $error ) {
                        $has_errors = 1;
                        error( $0, $filename, $dataname, $error, undef );
                    }
                }
                if( !$has_errors ) {
                    my $key = mk_symop_key( \@symops );
                    my $original_sg_H_M =
                        defined $datablok->{"_symmetry_space_group_name_H-M"} ?
                        $datablok->{"_symmetry_space_group_name_H-M"}[0] :
                        undef;
                    my $original_sg_Hall =
                        defined $datablok->{"_symmetry_space_group_name_Hall"} ?
                        $datablok->{"_symmetry_space_group_name_Hall"}[0] :
                        undef;
                    my $original_sg_number =
                        defined $datablok->{"_space_group_IT_number"} ?
                        $datablok->{"_space_group_IT_number"}[0] :
                        undef;

                    if( exists $symop_lookup_table{$key} ) {
                        my $estimated_sg = $symop_lookup_table{$key};

                        my $estimated_sg_H_M = $estimated_sg->{universal_h_m};
                        if( defined $original_sg_H_M &&
                            $original_sg_H_M ne '?' &&
                            $original_sg_H_M ne $estimated_sg_H_M &&
                            !exists $datablok->{"_[local]_cod_cif_authors_sg_H-M"} &&
                            !exists $datablok->{"_cod_cif_authors_sg_H-M"} &&
                            !exists $datablok->{"_cod_original_sg_symbol_H-M"} ) {
                            set_tag( $dataset, "_cod_cif_authors_sg_H-M",
                                     $original_sg_H_M );
                        }
                        set_tag( $dataset, "_symmetry_space_group_name_H-M",
                                 $estimated_sg_H_M );

                        my $estimated_sg_Hall = $estimated_sg->{hall};
                        $estimated_sg_Hall =~ s/^\s*//;
                        if( defined $original_sg_Hall &&
                            $original_sg_Hall ne '?' &&
                            $original_sg_Hall ne $estimated_sg_Hall ) {
                            set_tag( $dataset, "_cod_cif_authors_sg_Hall",
                                     $original_sg_Hall );
                        }
                        set_tag( $dataset, "_symmetry_space_group_name_Hall",
                                 $estimated_sg_Hall );

                        my $estimated_sg_number = $estimated_sg->{number};
                        if( defined $original_sg_number &&
                            $original_sg_number ne '?' &&
                            $original_sg_number != $estimated_sg_number ) {
                            set_tag( $dataset, "_cod_cif_authors_sg_number",
                                     $original_sg_number );
                        }
                        set_tag( $dataset, "_space_group_IT_number",
                                 $estimated_sg_number );
                    } else {
                        if( !$keep_unrecognised_spacegroups ) {
                            if( defined $original_sg_H_M && $original_sg_H_M ne '?' &&
                                !exists $datablok->{"_[local]_cod_cif_authors_sg_H-M"} &&
                                !exists $datablok->{"_cod_cif_authors_sg_H-M"} &&
                                !exists $datablok->{"_cod_original_sg_symbol_H-M"} ) {
                                set_tag( $dataset, "_cod_cif_authors_sg_H-M",
                                         $original_sg_H_M );
                            }
                            set_tag( $dataset, "_symmetry_space_group_name_H-M", '?' );

                            if( defined $original_sg_Hall && $original_sg_Hall ne '?' ) {
                                set_tag( $dataset, "_cod_cif_authors_sg_Hall",
                                         $original_sg_Hall );
                            }
                            set_tag( $dataset, "_symmetry_space_group_name_Hall",'?' );

                            if( defined $original_sg_number ) {
                                set_tag( $dataset, "_cod_cif_authors_sg_number",
                                         $original_sg_number );
                            }
                            set_tag( $dataset, "_space_group_IT_number", '?' );
                        }
                    }
                }
            } else {
                warning( $0, $filename,$dataname,
                         "the " . (defined $filename ? "'$filename' " : "") .
                         "$dataname does not contain " .
                         "symmetry operators", undef );
            }
        }

        # Try to parse and correct chemical formula if requested:

        if( $parse_formula_sum && defined $datablok->{_chemical_formula_sum} ) {
            my $formula = $datablok->{_chemical_formula_sum}[0];
            $formula =~ s/\n/ /g;
            $formula =~ s/^\s*|\s*$//g;
            my $parser = new COD::Formulae::Parser::AdHoc;
            $parser->ParseString( $formula );
            my $new_formula = $parser->SprintFormula;

            if( defined $new_formula && 
                $datablok->{_chemical_formula_sum}[0] ne $new_formula ) {
                set_tag( $dataset, "_cod_chemical_formula_sum_orig",
                         $datablok->{_chemical_formula_sum}[0] );
                set_tag( $dataset, "_chemical_formula_sum", $new_formula );
            }
        }

        # Calculate essential information if it is missing but requested:

        if( $calculate_cell_volume ) {
            my @cell = get_cell( $datablok );
            my @sigcell = get_cell( $dataset->{precisions} );
            $cell[3] = 90 unless defined $cell[3];
            $cell[4] = 90 unless defined $cell[4];
            $cell[5] = 90 unless defined $cell[5];

            my $has_cell = 1;
            my $has_precisions = 0;

            for (@cell) {
                if( !defined $_ ) {
                    $has_cell = 0;
                    last;
                }
            }
            for (@sigcell) {
                if( defined $_ && $_ != 0 ) {
                    $has_precisions = 1;
                    last;
                }
            }

            if( $has_cell ) {
                my ( $V, $sigV );
                if( $has_precisions ) {
                    @sigcell = map { defined $_ ? $_ : 0 } @sigcell;
                    ($V, $sigV) = cell_volume( @cell, @sigcell );
                    $V = pack_precision( $V, $sigV );
                } else {
                    $V = sprintf( "%.3f", scalar( cell_volume( @cell )));
                }
                if( exists $datablok->{"_cell_volume"} &&
                    !exists $datablok->{"_cod_original_cell_volume"} &&
                    $datablok->{"_cell_volume"}[0] ne $V ) {
                    $datablok->{"_cod_original_cell_volume"}[0] =
                        $datablok->{"_cell_volume"}[0];
                }
                $datablok->{"_cell_volume"}[0] = $V;
            } else {
                warning( $0, $filename, $dataname,
                         'no unit cell information found',
                         'cannot compute cell volume' );
            }
        }

        # Add default cell angles of 90 degrees if these are missing:
        if( exists $datablok->{"_cell_length_a"} ||
            exists $datablok->{"_cell_length_b"} ||
            exists $datablok->{"_cell_length_c"} ) {
            if( ! exists $datablok->{"_cell_angle_alpha"} ) {
                $datablok->{"_cell_angle_alpha"}[0] = 90;
            }
            if( ! exists $datablok->{"_cell_angle_beta"} ) {
                $datablok->{"_cell_angle_beta"}[0] = 90;
            }
            if( ! exists $datablok->{"_cell_angle_gamma"} ) {
                $datablok->{"_cell_angle_gamma"}[0] = 90;
            }
        }

        # Print out the CIF header if requested:

        if( defined $cif_comment_header ) {
            print $cif_comment_header;
        }

        # Calculate the data block name:

        if( defined $data_block_nr ) {
            $dataset->{name} = sprintf $datablock_format, $data_block_nr;
            if( $update_database_code ) {
                $dataset->{values}{$database_code_tag}[0] =
                    $dataset->{name};
            }
            $data_block_nr ++;
        }

        # Make sure we do not print out datasets with empty names if
        # we fix CIFs:

        if( $dataset->{name} eq "" ) {
            $dataset->{name} = $filename;
            $dataset->{name} =~ s/\s/_/g;
        }

        # Print out requested tags:

        print_cif( $dataset, { 
            exclude_misspelled_tags => $exclude_misspelled_tags,
            preserve_loop_order => $preserve_loop_order,
            fold_long_fields => $fold_long_fields,
            folding_width => $folding_width,
            dictionary_tags => \%dictionary_tags,
            dictionary_tag_list => \@dictionary_tags,
            keep_tag_order => $preserve_tag_order,
                   } );

    }

    if( $no_coordinates ) {
        warning( $0, $filename, undef,
                 'no datablocks that contain coordinates found', undef );
    }

}

#
# Subroutines:
#

sub merge_new_tag_values($$$)
{
    my ($tag_list, $dst, $src ) = @_;

    my %tag_list = map {($_,1)} @$tag_list;

    for my $key (@{$tag_list}) {
        if( defined $src->{values}{$key}
            && (!exists $dst->{values}{$key} || $global_priority )) {

            if( exists $dst->{values}{$key} ) {
                exclude_tag( $dst, $key );
            }

            $dst->{values}{$key} = $src->{values}{$key};
            push( @{$dst->{tags}}, $key );

            if( exists $src->{inloop}{$key} &&
                !exists $dst->{inloop}{$key} ) {
                my $loop_nr = $src->{inloop}{$key};
                my @loop = @{$src->{loops}[$loop_nr]};
                my $dst_loop_nr =
                    defined $dst->{loops} ? int(@{$dst->{loops}}) : 0;

                for my $loop_key (@loop) {
                    if( exists $tag_list{$loop_key}) {
                        push( @{$dst->{loops}[$dst_loop_nr]}, $loop_key );
                        $dst->{inloop}{$loop_key} = $dst_loop_nr;
                    }
                }
            }
        }
    }

    return $dst;
}

sub get_cell
{
    my $datablok = $_[0];

    my @cell = (
        exists $datablok->{_cell_length_a} ?
            $datablok->{_cell_length_a}[0] : undef,

        exists $datablok->{_cell_length_b} ?
            $datablok->{_cell_length_b}[0] : undef,

        exists $datablok->{_cell_length_c} ?
            $datablok->{_cell_length_c}[0] : undef,

        exists $datablok->{_cell_angle_alpha} ?
            $datablok->{_cell_angle_alpha}[0] : undef,

        exists $datablok->{_cell_angle_beta} ?
            $datablok->{_cell_angle_beta}[0] : undef,

        exists $datablok->{_cell_angle_gamma} ?
            $datablok->{_cell_angle_gamma}[0] : undef
    );

    return map { defined $_ && /^\s*[?.]\s*$/ ? undef : $_ } @cell;
}

sub restore_last_page
{
    my ( $page_first, $page_last ) = @_;

    if( $page_last > $page_first ) {
        return $page_last;
    } else {
        my $length_last = length( $page_last );
        my $length_first = length( $page_first );
        my $extra = $length_first - $length_last;

        my $leading_digits = substr( $page_first, 0, $extra );

        return $leading_digits . $page_last;
    }
}
