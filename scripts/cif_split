#!/bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#-----------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------
#*
# Split CIF files into separate files with one data_ section each.
#
# This script parses given CIF files to separate the datablocks, so is
# capable of splitting non-correctly formatted and nested CIF files.
#**

use strict;
use warnings;
use COD::CIF::Parser qw(parse_cif);
use COD::CIF::Tags::CanonicalNames;
use COD::CIF::Tags::Print;
use File::Basename;
use COD::SOptions;
use COD::SUsage;
use COD::UserMessage qw(warning error);

my $verbose = 1;
my $output_dir = "";
my $output_prefixed = 0;
my $output_tar = 0;
my $cif_header_file;

my $use_parser = "c";
my $format = "cif";

@ARGV = getOptions(
#** USAGE:
#**     $0 [options] input.cif [input2.cif ...]
#** 
#** OPTIONS:
#** -o, --output-dir out/
#**     Put all split files into the directory out/.
#**
#** -p, --prefixed, --output-prefixed
#**     Print splitted datablocks to the STDOUT, each line prefixed
#**     by the datablock name. Do not create any files.
#**
#** --output-tar
#**     Produce TAR archive with split files to the STDOUT.
#**
#** -h, --add-cif-header header_file.cif
#**     Prepend each of the output files with the comments from the
#**     beginning of the specified file.
#**
#** -v, --verbose      print names of the generated files to STDERR
#** -q, --quiet        do not print file names to STDERR
#**
#** --format-cif
#**    Output stand-alone CIF files (default option).
#**
#** --format-json
#**    Output internal representation of parsed CIF file in JSON.
#**
#** --use-perl-parser
#**    Use Perl parser for CIF parsing.
#**
#** --use-c-parser
#**    Use Perl & C parser for CIF parsing.
#**
#** --use-json-parser
#**    Use the JSON parser (input is in JSON format).
#**
#** --help,--usage     print short usage message (this message) and exit

   "-o,--output-dir" => sub { $output_dir = get_value(),
                              $output_prefixed = 0;
                              $output_tar = 0 },
   "-p,--prefixed,--output-prefixed" => sub { $output_prefixed = 1;
                                              $output_tar = 0 },
   "--output-tar"    => sub { $output_tar = 1;
                              $output_prefixed = 0 },

   "--format-cif"  => sub { $format = "cif" },
   "--format-json" => sub { $format = "json" },

   "-h,--add-cif-header" => \$cif_header_file,
   "-v,--verbose"    => sub { $verbose = 1 },
   "-q,--quiet"      => sub { $verbose = 0 },

   "--use-perl-parser" => sub{ $use_parser = "perl" },
   "--use-c-parser"    => sub{ $use_parser = "c" },
   "--use-json-parser" => sub{ $use_parser = "json" },

   "--help,--usage"  => sub { usage; exit },
);

my $cif_header;

if( $cif_header_file ) {
    open( HDR, "$cif_header_file" ) or
        die( "$0: could not open header file '$cif_header_file' " .
             "for input - $!" );

    $cif_header = "";
    while( <HDR> ) {
        last unless /^#/;
        $cif_header .= $_;
    }

    close( HDR ) or
        die( "$0: error reading header file '$cif_header_file' - $!" );
}

$output_dir =~ s./+$..;

my %files = ();
my $tar;
if( $output_tar ) {
    require Archive::Tar;
    $tar = Archive::Tar->new;
}

@ARGV = ("-") unless @ARGV;

for my $filename (@ARGV) {

    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );

    if ( $err_count > 0 ) {
        print STDERR $_ foreach ( @$messages );
        error( $0, $filename, undef, "$err_count error(s) "
             . "encountered while parsing the file", undef );
        next;
    }
    print STDERR $_ foreach ( @$messages );

    canonicalize_all_names( $data );

    my $data_global;
    for my $dataset (@$data) {
        my $dataname = $dataset->{name};

        if( $dataname eq 'global' ) {
            if( !$data_global ) {
                $data_global = $dataset;
            } else {
                warning( $0, $filename, $dataname,
                         'second data_global encountered', 'skipping' );
            }
            next;
        }

        my $print_cif_stdout;
        if( $format eq "cif" ) {
            local *STDOUT;
            open( STDOUT, '>', \$print_cif_stdout );
            if( $data_global ) {
                print_cif( $data_global,
                           {
                                preserve_loop_order => 1,
                                keep_tag_order => 1
                           }
                         );
            }
            print_cif( $dataset,
                       {
                            preserve_loop_order => 1,
                            keep_tag_order => 1
                       }
                     );
        } else {
            my @to_json = ( $dataset );
            if( $data_global ) {
                unshift( @to_json, $data_global );
            }
            $print_cif_stdout = cif2json( \@to_json );
        }

        my $cif_contents = "";
        if( $format eq "cif" ) {
            $cif_contents .= $cif_header if $cif_header;
        }
        $cif_contents .= $print_cif_stdout;

        if( $output_prefixed ) {
            map { print $dataset->{name}, "\t", $_, "\n" }
                    split( "\n", $cif_contents );
        } else {
            my $suffix = $dataname;
            $suffix =~ s/[^-+._a-zA-Z0-9]/_/g;

            my $basename = basename( $filename, ".cif" );
            my $output_file;
            if( $basename ne "-" ) {
                $output_file = "${basename}_${suffix}.${format}";
            } else {
                $output_file = "${suffix}.${format}";
            }
            if( $output_tar ) {
                $tar->add_data( $output_file, $cif_contents );
            } else {
                if( $output_dir ne "" ) {
                    $output_file = $output_dir . "/" . $output_file;
                }
                if( !exists $files{$output_file} ) {
                    $files{$output_file} = $output_file;

                    print STDERR "$output_file\n" if $verbose;
                    open( STDOUT, ">$output_file" ) or
                        die( "Could not open file '${output_file}' for writing: $!" );
                    print $cif_contents;
                } else {
                    open( STDOUT, ">>$output_file" ) or
                        die( "Could not open file '${output_file}' for appending: $!" );
                    
                    print STDERR "$output_file (appending)\n" if $verbose;
                }
            }
        }
    }
}

if( $output_tar ) {
    print $tar->write();
}
