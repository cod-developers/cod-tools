#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Rev$
#$URL$
#------------------------------------------------------------------------------
#*
#*  Calculates minimal distance between atoms read from a CIF file.
#*
#* USAGE:
#*    $0 --options input1.cif input*.cif
#**

use strict;
use warnings;
use File::Basename qw( basename );
use COD::AtomProperties;
use COD::Escape qw( escape );
use COD::CIF::Parser qw( parse_cif );
use COD::Spacegroups::Symop::Algebra qw( symop_vector_mul );
use COD::Spacegroups::Symop::Parse qw( symop_string_canonical_form
                                       symop_from_string );
use COD::Algebra::Vector qw( distance );
use COD::CIF::Data qw( get_cell get_symmetry_operators );
use COD::CIF::Data::AtomList qw( uniquify_atom_names );
use COD::CIF::Data::SymmetryGenerator qw( copy_atom
                                          symop_generate_atoms );
use COD::CIF::Data::ExcludeFromStatistics qw( exclude_from_statistics );
use COD::Fractional qw( symop_ortho_from_fract );
use COD::SOptions qw( getOptions get_value );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_warnings
                          process_errors
                          process_parser_messages );

my $die_on_error_level = {
    ERROR   => 0,
    WARNING => 0,
    NOTE    => 0
};

my $use_parser = 'c';
my $uniquify_atoms = 1;
my $include_disord_struct  = 1;
my $include_dup_struct     = 0;
my $include_self_distances = 1;
my $include_null_distances = 0;
my $include_unknown_types  = 0;
my $verbose = 0;
my $add_filename;
my $output_format = 'pairwise';
my $format = '%-11.3f';
my $pairwise_format = '%-6.3f';
my $line_length = 80;

my $escape_sequence = '\\';
my %escaped_symbols = ( "\"" => '"', "\'" => "'" );

#* OPTIONS:
#* -M, --distance-matrix
#*                     Set distance matrix output format.
#* -P, --pairwise-distance
#*                     Set pairwise distance output format (default).
#* -l, --matrix-line-length "80"
#*                     Maximum length of an output line in distance 
#*                     matrix format (default 80).
#* --format "%8.6f"
#*                     Use the specified format for distance matrix
#*                     and pairwise printout format (default "%-11.3f"
#*                     for matrix, "%-6.3f" for pairwise).
#* -F, --add-filename
#*                     Add a filename field at the end of pairwise
#*                     distance format lines.
#* --no-add-filename, --do-not-add-filename
#*                     Do not add a filename field at the end of
#*                     pairwise distance format lines (default).
#* --process-disordered-structures,
#* --include-disordered-structures
#*                     Force processing of disordered structures (default).
#* --no-process-disordered-structures,
#* --exclude-disordered-structures,
#* --skip-disordered-structures
#*                     Skip disordered structures.
#* --process-duplicate-structures,
#* --include-duplicate-structures,
#*                     Force processing of structures, that are flagged
#*                     as duplicates with '_cod_duplicate_entry' or
#*                     '_[local]_cod_duplicate_entry' tags.
#* --no-process-duplicate-structures,
#* --exclude-duplicate-structures,
#* --skip-duplicate-structures
#*                     Skip duplicate structures (default).
#* --include-null-distances
#*                     Include entries of null distance relationship between
#*                     atoms from different disorder groups of the same
#*                     disorder assembly in pairwise distances output format.
#* --no-null-distances, --exclude-null-distances
#*                     Exclude entries of null distance relationship between
#*                     atoms from different disorder groups of the same
#*                     disorder assembly in pairwise distances output format
#*                     (default).
#* --include-self-distances
#*                     Include entries of distances between symmetry-related
#*                     instances of the same atom (default).
#* --no-self-distances, --exclude-self-distances
#*                     Exclude entries of distances between symmetry-related
#*                     instances of the same atom.
#* -U, --include-unknown-types
#*                     Include entries containing atoms of undetermined
#*                     chemical type. Atom type will be marked as 'UN'.
#* --no-unknown-types, --exclude-unknown-types
#*                     Exclude entries containing atoms of undetermined
#*                     chemical type (default).
#* --uniquify-atoms
#*                    Makes unique the labels of atoms (default).
#* --no-uniquify-atoms
#*                    Does not make unique labels for atoms.
#* -v, --verbose
#*                    Print additional information for each step of the script.
#* -s, --silent, --quiet
#*                    Print no additional information (default).
#* --use-perl-parser
#*                    Use Perl parser to parse CIF files.
#* --use-c-parser
#*                    Use C parser to parse CIF files (default).
#* --help, --usage
#*                    Print a short usage message (this message) and exit.
#**
@ARGV = getOptions(
    '-M,--distance-matrix'       => sub { $output_format = 'matrix' },
    '-P,--pairwise-distance'     => sub { $output_format = 'pairwise'; },
    '-l,--matrix-line-length'    => \$line_length,
    '--format'         => sub { $format = $pairwise_format = get_value() },

    '-F,--add-filename'      => sub { $add_filename = 1 },
    '--no-add-filename'      => sub { $add_filename = 0 },
    '--do-not-add-filename'  => sub { $add_filename = 0 },

    '--process-disordered-structures'    => sub { $include_disord_struct = 1 },
    '--include-disordered-structures'    => sub { $include_disord_struct = 1 },
    '--no-process-disordered-structures' => sub { $include_disord_struct = 0 },
    '--exclude-disordered-structures'    => sub { $include_disord_struct = 0 },
    '--skip-disordered-structures'       => sub { $include_disord_struct = 0 },

    '--process-duplicate-structures'     => sub { $include_dup_struct = 1 },
    '--include-duplicate-structures'     => sub { $include_dup_struct = 1 },
    '--no-process-duplicate-structures'  => sub { $include_dup_struct = 0 },
    '--exclude-duplicate-structures'     => sub { $include_dup_struct = 0 },
    '--skip-duplicate-structures'        => sub { $include_dup_struct = 0 },

    '--include-null-distances'   => sub { $include_null_distances = 1 },
    '--no-null-distances'        => sub { $include_null_distances = 0 },
    '--exclude-null-distances'   => sub { $include_null_distances = 0 },

    '--include-self-distances'   => sub { $include_self_distances = 1 },
    '--no-self-distances'        => sub { $include_self_distances = 0 },
    '--exclude-self-distances'   => sub { $include_self_distances = 0 },

    '-U,--include-unknown-types' => sub { $include_unknown_types = 1 },
    '--no-unknown-types'         => sub { $include_unknown_types = 0 },
    '--exclude-unknown-types'    => sub { $include_unknown_types = 0 },

    '--uniquify-atoms'           => sub { $uniquify_atoms = 1; },
    '--no-uniquify-atoms'        => sub { $uniquify_atoms = 0; },

    '--use-perl-parser'          => sub { $use_parser = 'perl' },
    '--use-c-parser'             => sub { $use_parser = 'c' },

    '-v,--verbose'               => sub { $verbose = 1; },
    '-s,--silent,--quiet'        => sub { $verbose = 0; },
    '--options'                  => sub { options; exit },
    '--help,--usage'             => sub { usage; exit }
);

@ARGV = ( '-' ) unless @ARGV;

# Print output format header
my $format_doc_path = 'svn://www.crystallography.net/'
                    . 'cod-tools/trunk/perl-scripts/docs';
if ( $output_format eq 'pairwise' ) {
    print 'FORMAT pairwise_distance v1.0 '
        . $format_doc_path . '/cif_distances_pairwise_distance_v1.0' . "\n";
} elsif ( $output_format eq 'matrix' ) {
    print 'FORMAT distance_matrix v1.0 '
        .  $format_doc_path . '/cif_distances_distance_matrix_v1.0' . "\n";
}

foreach my $filename ( @ARGV ) {

    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );
    next if ( $err_count > 0 );

  # Initial check to skip structures not fit for statistics
  # 0 means that this type of stucture is excluded
  my $criteria = { 'duplicates'     => $include_dup_struct,
                   'disordered'     => $include_disord_struct,
                   'suboptimal'     => 0,
                   'retracted'      => 0,
                   'on-hold'        => 0,
                   'has_warnings'   => 0,
                   'has_errors'     => 0
                 };

  foreach my $dataset ( @$data ) {

    my $dataname = 'data_' . $dataset->{name} if defined $dataset->{name};

    local $SIG{__WARN__} = sub { process_warnings( {
                                       'message'  => @_,
                                       'program'  => $0,
                                       'filename' => $filename,
                                       'add_pos'  => $dataname
                                     }, $die_on_error_level ) };

    my ($status, $msg) = exclude_from_statistics( $dataset, $criteria );

    if ( $status ) {
        warn "WARNING, $msg -- dataset will be skipped\n";
        next;
    }

    eval {

      my $ortho_matrix;
      eval {
          my @unit_cell = get_cell( $dataset->{values} );
          $ortho_matrix = symop_ortho_from_fract( @unit_cell );
      };
      if ( $@ ) {
          $@ =~ s/[A-Z]+, //;
          chomp($@);
          die "$@ -- dataset will be skipped\n";
      }

      #   Extract atoms and order them alphabetically by type and label.
      my $atoms = get_atoms( $dataset, $ortho_matrix, $uniquify_atoms );

      my $printable_properties = [ 'name', 'chemical_type',
                                   'coordinates_ortho', 'coordinates_fract',
                                   'disorder_group', 'disorder_assembly' ];

      print_atoms( $atoms, $printable_properties ) if ( $verbose );

      #   Generate atoms by applying symmetry operators. This subroutine 
      #   original atoms are fitted into the first octant by applying x,y,z
      #   operator modulus 1.

      my ( $sym_atoms, $symop_count );
      eval {
          ( $sym_atoms, $symop_count ) = symops_apply( $dataset, $atoms,
                                                       $ortho_matrix );
      };
      if ( $@ ) {
          $@ =~ s/[A-Z]+, //;
          warn $@;
          die 'ERROR, unable to generate symmetrically equivalent '
            . 'atoms -- dataset will be skipped' . "\n";
      }

      push @$printable_properties, 'sym_operator';

      print_atoms( $sym_atoms, $printable_properties ) if ( $verbose );

      my @shifted_atoms = map { shift_atom( $_, $ortho_matrix ) } @{$sym_atoms};

      push @$printable_properties, 'shift_vector';

      print_atoms( \@shifted_atoms, $printable_properties ) if ( $verbose );

      my ( $distances, $headers, $atoms_used ) = get_distances( \@shifted_atoms,
                                                                $symop_count );

      if ( $output_format eq 'pairwise' ) {
          print_pairwise( $distances, $atoms_used, $filename, $add_filename );
      } elsif ( $output_format eq 'matrix' ) {
          print_distance_matrix( $distances, $headers, $format, $line_length );
      }
    };
    if ($@) {
        process_errors( {
          'message'       => $@,
          'program'       => $0,
          'filename'      => $filename,
          'add_pos'       => $dataname
        }, $die_on_error_level->{'ERROR'} );
    }
  }
}

##
# Extracts atom information from given dataset.
# @param $dataset
#       Dataset containing cif file information extracted by a cif file parser.
# @param $ortho_matrix
#       Reference to a structure containing matrix information used to convert
#       fractional coordinates to orthogonal.
# @return $atoms
#       Reference to a data structure containing atom information.
##

sub get_atoms {

    my ( $dataset, $ortho_matrix, $uniquify_atoms ) = @_;

    my $values = $dataset->{values};

    #   extracts atom site label or atom site type symbol
    my $atom_site_tag;

    if( exists $values->{'_atom_site_label'} ) {
        $atom_site_tag = '_atom_site_label';
    } elsif( exists $values->{'_atom_site_type_symbol'} ) {
        $atom_site_tag = '_atom_site_type_symbol';
    } else {
        die 'ERROR, neither \'_atom_site_label\' nor \'_atom_site_type_symbol\' '
          . 'present -- dataset will not be processed' . "\n";
    }

    my @atoms;

    for my $i ( 0 .. $#{$values->{$atom_site_tag}} ) {
        my $atom = {
            name => $values->{$atom_site_tag}[$i],
            chemical_type => exists $values->{_atom_site_type_symbol} ?
                $values->{_atom_site_type_symbol}[$i] : undef,
            disorder_group => exists $values->{_atom_site_disorder_group}[$i] ?
                $values->{_atom_site_disorder_group}[$i] : '.',
            disorder_assembly => exists $values->{_atom_site_disorder_assembly}[$i] ?
                $values->{_atom_site_disorder_assembly}[$i] : '.',
            coordinates_fract => [
                $values->{_atom_site_fract_x}[$i],
                $values->{_atom_site_fract_y}[$i],
                $values->{_atom_site_fract_z}[$i]
            ],
        };

        # get atoms chemical type 
        # Chemical type is determined from _atom_site_type_symbol or 
        # _atom_site_label if the previous tag is not present.
        if( !defined $atom->{chemical_type} || $atom->{chemical_type} eq '?' ) {
            $atom->{chemical_type} = $atom->{name};
            if( $atom->{chemical_type} =~ m/^([A-Za-z]{1,2})/ ) {
                $atom->{chemical_type} = ucfirst( lc( $1 ));
            };
        } else {
            if( $atom->{chemical_type} =~ m/^([A-Za-z]{1,2})/ ) {
                $atom->{chemical_type} = ucfirst( lc( $1 ));
            }
        }

        # If the two letter chemical type abbreviation is not recognised
        # it is assumed that only the first letter defines the type.
        # If the type is still not recognised, the type is marked as 
        # unrecognised "UN".
        if( ! exists $COD::AtomProperties::atoms{$atom->{chemical_type}}) {
            chop $atom->{chemical_type};
            if( ! exists $COD::AtomProperties::atoms{$atom->{chemical_type}}) {
                if ( $include_unknown_types ) {
                    warn 'WARNING, unable to determine chemical type of atom '
                       . 'with _atom_site_label ' . "'$atom->{'name'}'" . ' -- '
                       . 'atom chemical type will be set to \'UN\'' . "\n";
                    $atom->{'chemical_type'} = 'UN'
                } else {
                    warn 'WARNING, unable to determine chemical type of atom '
                       . 'with _atom_site_label ' . "'$atom->{name}'" . ' -- '
                       . 'atom will be removed' . "\n";
                    next;
                }
            }
        };

        @{$atom->{'coordinates_fract'}} = map { s/\(\d+\)\s*$//; $_ }
            @{$atom->{'coordinates_fract'}};

        $atom->{'coordinates_ortho'} =
            symop_vector_mul( $ortho_matrix, $atom->{'coordinates_fract'} );

        if( defined $values->{'_atom_site_occupancy'} ) {
            if( $values->{'_atom_site_occupancy'}[$i] ne '?' &&
                $values->{'_atom_site_occupancy'}[$i] ne '.' ) {
                $atom->{'occupancy'} = $values->{'_atom_site_occupancy'}[$i];
                $atom->{'occupancy'} =~ s/\(\d+\)\s*$//;
            } else {
                $atom->{'occupancy'} = 1;
            }
        }

        if( defined $values->{'_atom_site_symmetry_multiplicity'} &&
            $values->{'_atom_site_symmetry_multiplicity'}[$i] ne '?' ) {
            $atom->{'cif_multiplicity'} =
                $values->{'_atom_site_symmetry_multiplicity'}[$i];
        }

        push( @atoms, $atom );
    }

    @atoms = @{ uniquify_atom_names( \@atoms, $uniquify_atoms ) };

    @atoms = sort { ( $a->{'chemical_type'} cmp $b->{'chemical_type'} ) ||
                    ( $a->{'name'} cmp $b->{'name'} ) } @atoms;

    return \@atoms;
}

##
# Generates symmetrical atoms from the given original atoms and symmetry
# operators.
# @param $sym_data
#       Reference to an array containing symmetry operators in string format.
# @param $atoms
#       Reference to an array of original atoms.
# @param $ortho_matrix
#       Reference to a struture containing matrix, that is used to convert 
#       fractional coordinates to orthogonal in the newly generated atoms.
#  @return
#       Reference to an array containing atoms generated by applying symmetry
#       operators. Each atom hash is given a new field "sym_operator".
##

sub symops_apply {
    my ( $dataset, $atoms, $ortho_matrix ) = @_;

    #   extracts symmetry operators
    my $sym_data = get_symmetry_operators( $dataset );

    #   transforms symmetry operators into canonical from
    @{$sym_data} = map { symop_string_canonical_form( $_ ) } @{$sym_data};

    # Computes symmetry operator matrices
    my @symop = map { symop_from_string( $_ ) } @{$sym_data};

    my $sym_atoms = symop_generate_atoms( \@symop, $atoms, $ortho_matrix );

    # Adds applied symmetry operator to the atom property hash
    my $i = 0;
    foreach ( @{ $sym_atoms } ) {
        $_->{'sym_operator'} = @$sym_data[ $i ];
        $i = ( $i + 1 ) % @$sym_data;
    }

    return $sym_atoms, scalar( @symop );
}

##
# Calculates the minimum distance between two atoms from the given array.
# It is expected that atoms, derived from the original atom by applying
# symmetry operator and shifting operators, are put near each other in the 
# array, making groups of size $sym_operator_count * 27 (number of 
# octants). Since all atoms of the cluster are derived from one original 
# atom, distances between them are not calculated.
# @param $all_atom
#       Reference to an array containing all atoms generated after 
#       applying symmetry and shift operators.
# @param $sym_operator_count
#       Number of symmetry operators that have been applied.
# @return $distances
#       An array of shortest interatomic distances.
# @return $headers
#       An array of labels for the shortest interatomic distances.
# @return $atoms_used
#       An array of atoms for which the distances were generated.
##

sub get_distances {
    my ( $all_atoms, $sym_operator_count ) = @_;
    my $group_size = $sym_operator_count * 27; # 27 is the number of octants
    my $number_of_groups = @$all_atoms/$group_size;
    my @headers;
    my @distances;
    my @atoms_used;

    # $i holds the index of the first group
    for ( my $i  = 0; $i < $number_of_groups; $i++ ) {
        my $atom_1 = $all_atoms -> [ $i * $group_size ]; # acquiring first atom

        push @headers, "$atom_1->{'name'}/$atom_1->{'chemical_type'}";
        my @atom_rows_used;
        push @atom_rows_used, $atom_1;
        my @distance_row;

        # $j holds the index of the second group
        for ( my $j = $i; $j < $number_of_groups; $j++ ) {
            my $atom_2 = $all_atoms->[ $j * $group_size + 1 ];
            #
            my $min_distance;
            my $min_index = 0;

            #$start_index = 1 if ($i == $j);

            if ( check_disorder( $atom_1, $atom_2 ) ) {

                $min_distance = distance( $atom_1->{'coordinates_ortho'},
                                          $atom_2->{'coordinates_ortho'} );
                $min_distance = 5000;

                # $k holds the element index in the second group
                for ( my $k = 0; $k < $group_size; $k++ ) {
                    $atom_2 = $all_atoms -> [ $j * $group_size + $k ];
                    my $distance = distance( $atom_1->{'coordinates_ortho'},
                                             $atom_2->{'coordinates_ortho'} );

                    if ( !( equals( $distance, 0, 3 ) && $i == $j ) ) {
                        if ( $distance < $min_distance ) {
                            ( $min_index, $min_distance ) = ( $k, $distance )
                        }
                    }
                }
            } else {
                $min_distance = '-';
            }
            push @distance_row, $min_distance;
            push @atom_rows_used, $all_atoms -> [ $j * $group_size + $min_index ];
        }

        push @distances, \@distance_row;
        push @atoms_used, \@atom_rows_used;
    }

return ( \@distances, \@headers, \@atoms_used );
}

##
# Checks if the atoms belong to the same disorder group.
# @param $atom_1
#       Reference to a hash, containing information of the first atom.
# @param $atom_2
#       Reference to a hash, containing information of the second atom.
# @return
#       0 is atoms belong to different disorder groups but the same 
#       disorder assembly. 1 otherwise.
##

sub check_disorder {
    my ( $atom_1, $atom_2 ) = @_;
    if ( ( $atom_1->{'disorder_group'} ne $atom_2->{'disorder_group'} ) &&
         ( $atom_1->{'disorder_group'} ne '.' ) &&
         ( $atom_2->{'disorder_group'} ne '.' ) &&
         ( $atom_1->{'disorder_assembly'} eq $atom_2->{'disorder_assembly'} )
       )  {
        return 0;
    }

    return 1;
}

##
# Returns an array of atom hashes generated by shifting the original 
# atom in 26 directions (3-D space).
# @param $atom_ref
#       Reference to a hash, containing atom information.
# @return @shifted_atoms;
#       Array of atom hashes.
##

sub shift_atom {
    my ( $original_atom, $ortho_matrix ) = @_;

    $original_atom->{'shift_vector'} = '5,5,5';
    my @shifted_atoms;
    push @shifted_atoms, $original_atom;
    my @shifting_param = ( -1, 0, 1 );

    foreach my $x ( @shifting_param ) {
    foreach my $y ( @shifting_param ) {
    foreach my $z ( @shifting_param ) {
        if ( $x != 0 || $y != 0 || $z != 0 ) {
            my $new_atom = copy_atom($original_atom);

            $new_atom->{'coordinates_fract'}[0] += $x;
            $new_atom->{'coordinates_fract'}[1] += $y;
            $new_atom->{'coordinates_fract'}[2] += $z;

            $new_atom->{'coordinates_ortho'} =
                        symop_vector_mul( $ortho_matrix,
                                          $new_atom->{'coordinates_fract'} );

            $new_atom->{'shift_vector'} = ( 5 + $x ) . ',' .
                                          ( 5 + $y ) . ',' .
                                          ( 5 + $z );
            push @shifted_atoms, $new_atom;
          }
    } } }

    return @shifted_atoms;
}

##
# Prints atoms fieldname values from an array.
# @param $array_ref
#       Reference to an array from which the atoms are printed.
##

sub print_atoms {
    my ( $array_ref, $properties ) = @_;
    foreach my $atom_ref ( @$array_ref ) {
        foreach my $property ( @$properties ) {
            if ( $property eq 'name' ) {
                print "Atom name: $atom_ref->{name} \n";
            } elsif ( $property eq 'chemical_type' ) {
                print "Chemical type: $atom_ref->{'chemical_type'} \n";
            } elsif ( $property eq 'occupancy' ) {
                print "Ocupancy: $atom_ref->{'occupancy'} \n";
            } elsif ( $property eq 'cif_multiplicity' ) {
                print "cif_multiplicity: $atom_ref->{'cif_multiplicity'} \n";
            } elsif ( $property eq 'disorder_group' ) {
                print "Atom site disorder group: $atom_ref->{'disorder_group'} \n";
            } elsif ( $property eq 'disorder_assembly' ) {
                print "Atom site disorder assembly: $atom_ref->{'disorder_assembly'} \n";
            } elsif ( $property eq 'coordinates_ortho' ) {
                printf 'Orthogonal coordinates: %8.3f %8.3f %8.3f' . "\n",
                    @{ $atom_ref->{'coordinates_ortho'} };
            } elsif ( $property eq 'coordinates_fract' ) {
                printf 'Fractional coordinates: %8.3f %8.3f %8.3f' . "\n",
                    @{ $atom_ref->{'coordinates_fract'} };
            } elsif ( $property eq 'shift_vector' ) {
                print "Shift vector: $atom_ref->{'shift_vector'} \n";
            } elsif ( $property eq 'sym_operator' ) {
                print "Symmetry operator: $atom_ref->{'sym_operator'} \n";
            }
        }
    }

    return;
}

##
# Prints distances between atoms in the default format, defined in
# cod-tools/trunk/perl-scripts/cif-distances/cif-distances_matrix_v.1
# @param $distance_ref
#       Reference to an array distances between atoms.
# @param $header_ref;
#       Reference to an array of strings containing information about 
#       atoms that were used in the calculation of distances.
# @param $fraction_precision
#       Number of fraction digits of the distances that should be printed.
# @param $line_length
#       Length of the matrix line in symbols.
##

sub print_distance_matrix {
    my ( $distance_ref, $header_ref, $format, $line_length ) = @_;
    my @distances = @$distance_ref;
    my $cell_width = 11;
    if ( $format =~ /^%\D*(\d+)\D/ ) {
        $cell_width = $1;
    }

    use POSIX qw( floor ceil );
    my $cell_count = floor ( $line_length / $cell_width ) - 1;

    my $print_iteration = 0;
    while ( $print_iteration < ceil( @distances / $cell_count ) ) {
        my $start_cell_index = $cell_count * $print_iteration;
        my $finish_cell_index = $cell_count * ( $print_iteration + 1 );
        if ( $finish_cell_index > @distances ) {
            $finish_cell_index = @distances;
        }

        printf "%-${cell_width}s", 'ATOMS';
        for ( my $k = $start_cell_index; $k < $finish_cell_index; $k++ ) {
            printf "%-${cell_width}s", @$header_ref[ $k ];
        }
        print "\n";

        for ( my $i = 0; $i < @distances; $i++ ) {
            printf "%-${cell_width}s", @$header_ref[$i];
            for ( my $j = $start_cell_index; $j < $finish_cell_index; $j++ ) {
              my $distance;
              if ( $j > $i ) {
                    $distance = $distances[ $i ][ $j - $i ];
                } else {
                    $distance = $distances[ $j ][ $i - $j ];
                }

                if ( $distance eq '-' ) {
                    printf "%-${cell_width}s", $distance;
                } else {
                    printf $format, $distance;
                }
            };
            print "\n";
        }
        $print_iteration++;
    }

    return;
}

##
# Prints distances between atoms in an alternative format, defined in
# cod-tools/trunk/perl-scripts/cif-distances/cif-distances_paired_v.1
# @param $distances
#       Reference to an array distances between atoms.
# @param $atoms_used
#       Reference to an array of atoms that were used in the calculation
#       of the distances.
##

sub print_pairwise {
    my ( $distances, $atoms_used, $filename, $print_filename ) = @_;

    for ( my $i = 0; $i < @$atoms_used; $i++ ) {
      my $atom_1 = @$atoms_used[ $i ] -> [ 0 ];

      for ( my $j = 1; $j < @{ @$atoms_used[ $i ] }; $j++ ) {
        my $atom_2 = @$atoms_used[ $i ] -> [ $j ];

        my $distance = @$distances[ $i ] -> [ $j-1 ];

        # check if atoms are self simmetry-related
        next if ( ( $j - 1 ) == 0  && !$include_self_distances );
        # check if atoms distances contain null value ('-')
        next if ( $distance eq '-' && !$include_null_distances );

        my $output_string = '';

        if ( $distance eq '-' ) {
            $output_string .= sprintf 'DIST %-6s', '-';
        } else {
            $output_string .= sprintf 'DIST ' . $pairwise_format, $distance;
        }

        $output_string .= sprintf ' %10s %10s %24s %8s ',
                    $atom_1->{'name'} . '/' . $atom_1->{'chemical_type'},
                    $atom_2->{'name'} . '/' . $atom_2->{'chemical_type'},
                    $atom_2->{'sym_operator'},
                    $atom_2->{'shift_vector'};

        $output_string .= basename( $filename ) if ( $print_filename );
        print escape( "$output_string\n", {
                        'sequence'        => $escape_sequence,
                        'escaped_symbols' => \%escaped_symbols } );
      }
    }

    return
}

##
# Compares two floating point numbers using given decimal point precision.
# @param $float_1
#       First floating point number.
# @param $float_2
#       Second floating point number.
# @param $float_2
#       Decimal point digit precision.
# @return
#       1 if numbers are equal, 0 otherwise.
##
sub equals {
    my ($float_1, $float_2, $dp) = @_;
    return ( ( sprintf "%.${dp}f", $float_1 ) eq
             ( sprintf "%.${dp}f", $float_2 ) ) ? 1 : 0;
}
