#!/usr/bin/perl

use strict;
use warnings;
use COD::CIF::Parser qw( parse_cif );
use COD::SOptions qw( getOptions );
use COD::SUsage qw( usage options );
use COD::ErrorHandler qw( process_warnings
                          process_errors
                          process_parser_messages );

use Data::Dumper; # for debugging

my $use_parser = 'c';

my $die_on_errors    = 1;
my $die_on_warnings  = 0;
my $die_on_notes     = 0;
my $die_on_error_level = {
    ERROR   => $die_on_errors,
    WARNING => $die_on_warnings,
    NOTE    => $die_on_notes
};

for my $filename (@ARGV) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );

    if( !@$data || !exists $data->[0] || !exists $data->[0]{cifversion} ||
        $data->[0]{cifversion}{major} != 2 ) {
        die 'CIF format must be of version 2.0 or greater to be ' .
            'processed';
    }

    my $dict = build_dictionary_structure( $data->[0] );

    dic_block2markdown( $dict );
}

# Constructs CIF DDLm dictionary relation tree for easier detection of
# dependencies.
sub build_dictionary_structure
{
    my( $dataset ) = @_;

    my $parents = {};
    for my $save_block (@{$dataset->{save_blocks}}) {

        if( !exists $save_block->{values}{'_name.category_id'} ) {
            warn "save block '$save_block->{name}' does not contain " .
                 '\'_name.category_id\' data item -- unable to ' .
                 'determine its anchestry, skipping';
            next;
        }

        my $parent = lc $save_block->{values}{'_name.category_id'}[0];
        push @{$parents->{$parent}}, $save_block;
    }

    my @heads = @{$parents->{lc $dataset->{values}{'_dictionary.title'}[0]}};

    my $dict = {};
    $dict->{content} = $heads[0];
    find_children( $dict, $parents );

    return $dict;
}

sub find_children
{
    my( $node, $parents ) = @_;
    my $children = $parents->{lc $node->{content}{values}{'_definition.id'}[0]};
    return if !$children;

    foreach (@$children) {
        my $new_node = { content => $_ };
        find_children( $new_node, $parents );
        push @{$node->{children}}, $new_node;
    }
}

sub dic_block2markdown
{
    my( $node, $indent ) = @_;

    my $values = $node->{content}{values};

    $indent = 0 if !defined $indent;
    my $title = $values->{'_definition.id'}[0];
    $title =~ s/_/\\_/g;

    print '#' x ($indent + 1) . ' ' . $title . "\n\n";
    print $values->{'_description.text'}[0] . "\n\n";

    foreach (@{$node->{children}}) {
        dic_block2markdown( $_, $indent + 1 );
    }
}
