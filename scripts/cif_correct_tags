#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Corrects misspelled tags in a CIF file and outputs made changes into the 
#  standard I/O streams. By default, only tags from CIF Core and CIF COD 
#  dictionaries with extra '^_+' prefixes are corrected. Additionally, a 
#  replacement list file can be provided for the correction of misspelled tags.
#**

use strict;
use warnings;
use COD::CIF::Parser::Yapp;
use COD::CIF::Tags::CanonicalNames;
use COD::CIF::Tags::DictTags;
use COD::CIF::Tags::COD;
use COD::CIF::Tags::Manage;
use COD::CIF::Tags::Print;
use COD::SOptions;
use COD::SUsage;
use COD::UserMessage qw(note error prefix_dataname);

my $keep_tag_order = 0;
my $Id = '$Id$';
my $replacement_list;
my $use_parser = "c";

#* USAGE:
#*     $0 [options] input.cif [input2.cif ...]
#*
#* OPTIONS:
#*   --keep-tag-order
#*                      Keep the original tag order in CIF file (default).
#*   --sort-tags
#*                      Reorder tags in CIF file according to COD.
#*   -r, --replacement-list "replacement-file.lst"
#*                      Name of the multi-line replacement list file with 
#*                      entries of form '_incorrect_tag _correct_tag' to be 
#*                      used in the correction of misspelled tags.
#*   --use-perl-parser  Use the Perl-only CIF parser.
#*   --use-c-parser     Use the speed-optimised C/Perl parser. Default.
#**  --help,--usage     Print a short usage message (this message) and exit.

@ARGV = getOptions(
    "--keep-tag-order"  => sub { $keep_tag_order = 1; },
    "--sort-tags"       => sub { $keep_tag_order = 0; },
    "-r,--replacement-list" => \$replacement_list,
    "--use-perl-parser" => sub{ $use_parser = "perl" },
    "--use-c-parser"    => sub{ $use_parser = "c" },
    "--help,--usage"    => sub { usage; exit }
);

sub insert_report_to_comments 
{
    my ($dataset, $insert_reports) = @_;
    if ( @$insert_reports > 0 ) {
        my $comments_tag = '_cod_depositor_comments';
        my $values = $dataset->{values};
        my $reports_value = join("\n\n",@$insert_reports);

        my $message =
            "The following automatic conversions were performed:\n" .
            join( "\n", map { "" . $_ }
                  fold( 70, " +", " ", $reports_value ));

        if( exists $values->{$comments_tag} ) {
            $values->{$comments_tag}[0] .= "\n\n" . $message;
        } else {
            $values->{$comments_tag}[0] = "\n" . $message;
        }
        my $signature = $Id;
        $signature =~ s/^\$|\$$//g;
        $values->{$comments_tag}[0] .=
            "\n\n" . "Automatic conversion script" .
            "\n" . $signature;
    }
} 

my %tag_spelling = ();

if( $replacement_list ) {
    open( LIST, $replacement_list ) or
        die "$0: $replacement_list: can not open file for input - $!";

    %tag_spelling =
        map { split }
        grep !/^\#/,
        grep '\.',
    <LIST>;

    close( LIST ) or
        die "$0: $replacement_list: error closing file - $!";
}

my @dictionary_tags = ( @COD::CIF::Tags::DictTags::tag_list,
                        @COD::CIF::Tags::COD::tag_list );
my %dictionary_tags = map { $_, $_ } @dictionary_tags;

@ARGV = ("-") unless @ARGV;

for my $filename (@ARGV) {
    my( $data, $error_count );

    if(      $use_parser eq "perl" ) {
        my $parser = new COD::CIF::Parser::Yapp;

        $data = $parser->Run($filename);

        if( defined $parser->YYData->{ERRCOUNT} ) {
            $error_count = $parser->YYData->{ERRCOUNT};
        }
    } elsif( $use_parser eq "c" ) {
        require COD::CIF::Parser::Bison;
        ( $data, $error_count ) =
            COD::CIF::Parser::Bison::parse( $filename );
    } else {
        error( $0, undef, undef, "unknown parser '$use_parser'", undef );
        die;
    }

    if( defined $error_count && $error_count > 0 ) {
        error( $0, $filename, undef, $error_count
             . ' error(s) encountered while parsing CIF data', undef );
        exit -1; # Should go on to the next file?
    }

    canonicalize_all_names( $data );

    for my $dataset (@$data) {

        my @insert_reports = ();
        my $tags = $dataset->{tags};
        my $values = $dataset->{values};
        my $dataname = prefix_dataname($dataset->{name});

        for my $tag (@$tags) {
            if( exists $tag_spelling{$tag} ) {
                my $old_tag = $tag;
                my $correct = $tag_spelling{$tag};
                if( !exists $values->{$correct} ) {
                    rename_tag( $dataset, $tag, $correct );
                    my $report_msg = 
                    "'$old_tag' tag replaced with '$correct' tag " .
                    "as specified in the replacement file " .
                    "'$replacement_list'.";
                    push (@insert_reports, $report_msg);
                    note( $0, $filename, $dataname, $report_msg, undef );
                }
            }
            if( $tag =~ /^_+(_[^_].*)$/ ) {
                my $old_tag = $tag;
                my $correct = $1;
                if( exists $dictionary_tags{$correct} &&
                    !exists $values->{$correct} ) {
                    rename_tag( $dataset, $tag, $correct );
                    my $report_msg = "'$old_tag' tag replaced with " .
                                     "'$correct' tag.";
                    push (@insert_reports, $report_msg);
                    note( $0, $filename, $dataname, $report_msg, undef );
                }
            }
        }
        insert_report_to_comments ($dataset,\@insert_reports);
        print_cif( $dataset, {
            exclude_misspelled_tags => 0,
            preserve_loop_order => 1,
            fold_long_fields => 0,
            dictionary_tags => \%dictionary_tags,
            dictionary_tag_list => \@dictionary_tags,
            keep_tag_order => $keep_tag_order,
        } );
    }
}
