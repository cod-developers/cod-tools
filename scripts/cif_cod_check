#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Parse a CIF file, check if certain data values match COD
#  requirements and IUCr data validation criteria (Version: 2000.06.09,
#  ftp://ftp.iucr.ac.uk/pub/dvntests or ftp://ftp.iucr.org/pub/dvntests)
#**

use strict;
use warnings;
use COD::CIF::Parser qw(parse_cif);
use COD::CIF::Data qw(get_cell get_content_encodings);
use COD::CIF::Data::EstimateZ qw(cif_estimate_z);
use COD::CIF::Tags::CanonicalNames;
use COD::CIF::Tags::Manage;
use COD::Escape qw( decode_textfield );
use COD::Precision qw(eqsig);
use COD::ShowStruct;
use COD::Spacegroups::Symop::Parse;
use COD::Spacegroups::Lookup::COD;
use COD::Spacegroups::Names;
use COD::UserMessage qw(error print_message);
use COD::ErrorHandler qw(process_warnings);
use COD::SOptions;
use COD::SUsage;
use Digest::MD5 qw( md5_hex );
use Digest::SHA qw( sha1_hex );
use File::Basename;

my $name_syntax_explained = 0;
my $check_bibliography = 1;
my $require_only_doi = 0;
my $check_authors = 1;
my $check_chemical_formula_sum = 1;
my $check_spacegroup_info = 1;
my $check_symmetry_operators = 1;
my $check_spacegroup_constraints = 1;
my $check_limits = 1;
my $use_precisions = 1;
my $check_temperature_factors = 1;
my $check_simultaneous_presence = 1;
my $check_embedded_file_integrity = 1;
my $check_z = 0;

my $die_on_errors = 1;
my $die_on_warnings = 0;
my $die_on_notes = 0;

sub dont_check_any
{
    $check_bibliography = 0;
    $check_authors = 0;
    $check_chemical_formula_sum = 0;
    $check_spacegroup_info = 0;
    $check_symmetry_operators = 0;
    $check_spacegroup_constraints = 0;
    $check_limits = 0;
    $check_temperature_factors = 0;
    $check_simultaneous_presence = 0;
    $check_embedded_file_integrity = 0;
    $check_z = 0;
}

sub check_all
{
    $check_bibliography = 1;
    $check_authors = 1;
    $check_chemical_formula_sum = 1;
    $check_spacegroup_info = 1;
    $check_symmetry_operators = 1;
    $check_spacegroup_constraints = 1;
    $check_limits = 1;
    $check_temperature_factors = 1;
    $check_simultaneous_presence = 1;
    $check_embedded_file_integrity = 1;
    $check_z = 1;
}

my $useReporter = 0;
my $reportFile = '-';

#===================================================================#
#
# The structure of the default table of the limits 
# that uses '--check-limits' option is:
#
# { _tag_name -> [ [$begin,$end] , [$begin,$end] , [$begin,$end] ] }
# 
# The array [$begin,$end] is the range of the limits.
#
#===================================================================#

my %default_limits_table = (
    '_refine_ls_R_factor_gt' =>   [ [0.2], [0.15], [0.10] ],
    '_refine_ls_R_factor_obs' =>  [ [0.2], [0.15], [0.10] ],
    '_refine_ls_wR_factor_ref' => [ [0.45], [0.35], [0.25] ],
    '_refine_ls_wR_factor_obs' => [ [0.45], [0.35], [0.25] ],
    '_refine_ls_goodness_of_fit_ref' => [ [0.4,6], [0.6,4], [0.8,2] ],
    '_refine_ls_goodness_of_fit_obs' => [ [0.4,6], [0.6,4], [0.8,2] ],
    '_refine_ls_shift/su_max' =>  [ [0.20], [0.10], [0.05] ],
    '_refine_ls_shift/esd_max' => [ [0.20], [0.10], [0.05] ],
);

my %limits_table = %default_limits_table;
my $limits_table = \%limits_table;

# Subroutine that gets limits values from the file that is given under
# the option '--limits-file'

sub get_limits_table($) {
    my( $flimits ) = @_;
    my %ltable;
    open( LIST, $flimits ) or
        die "$0: $flimits: can not open file for input - $!";
    foreach( <LIST> ) {
        if( /^#/ ) { next; }
        my @constraints;
        my @data = split( /\s+/, $_, 4 );
        my $tag = shift( @data );
        foreach( @data ) {
            $_ =~ s/\s+//g;
            if( $_ =~ /(\d*\.?\d+)-(\d*\.?\d+)/ ) {
                push( @constraints, [$1,$2] );
            } else {
                push( @constraints, [$_] );
            }
        }
        $ltable{$tag} = \@constraints;
    }
    close( LIST ) or
        die "$0: $flimits: error closing file - $!";
    return \%ltable;
}

# Subroutine that merges tables of limits

sub merge_limits_tables($$) {
   my( $new_limits, $old_limits ) = @_;
   my $merged_limits = $old_limits;

   foreach my $tag( keys %$new_limits ) {
        if( exists $merged_limits->{$tag} ) {
            $merged_limits->{$tag} = $new_limits->{$tag};
            next;
        } else {
            $merged_limits->{$tag} = $new_limits->{$tag};
        } 
   }
   return $merged_limits; 
}

my $max_year_temperature_factors_optional = 1969;
my $use_parser = "c";

#* USAGE:
#*    $0 [options] input1.cif [input2.cif ...]
#*
#* OPTIONS:
#* For every --check-xyz option, there are the following corresponding
#* related options:
#*
#*    --check-only-xyz
#*        Switch off any other checks and check ONLY xyz (the last option on the
#*        command line wins)
#*
#*    --dont-check-xyz, --do-not-check-xyz, --no-check-xyz
#*        Switch off checks of xyz condition
#*
#* The check options are:
#*
#*    --check-authors
#*
#*    --check-bibliography
#*
#*    --check-chemical-formula-sum
#*
#*    --check-spacegroup-info
#*
#*    --check-operators, --check-symmetry-operators
#*
#*    --check-unit-cell
#*
#*    --check-symmetry
#*
#*    --check-simultaneous-presence
#*
#*    --check-limits
#*
#*    --print-limits
#*
#*    --add-limits  limits.lst
#*
#*    --limits-file limits.lst
#*
#*    --reset-limits
#*
#*    --check-temperature-factors
#*
#*    --max-year-temperature-factors-optional 1969
#*
#*    --check-embedded-file-integrity
#*
#*    --check-z
#*
#*    --check-all
#*
#*    --check-none, --dont-check-any
#*
#*    --use-perl-parser
#*
#*    --use-c-parser
#*
#*    --help,--usage         Print a short usage message (this message) and exit.
#**

@ARGV = getOptions(
    "--check-bibliography"
        => sub{ $check_bibliography = 1 },
    "--check-only-bibliography"
        => sub{ dont_check_any(); $check_bibliography = 1 },
    "--dont-check-bibliography,--no-check-bibliography," .
    "--do-not-check-bibliography"
        => sub{ $check_bibliography = 0 },

    "--require-only-doi"
        => sub{ $require_only_doi = 1 },
    "--require-full-bibliography"
        => sub{ $require_only_doi = 0 },

    "--check-authors"
        => sub{ $check_authors = 1 },
    "--check-only-authors"
        => sub{ dont_check_any(); $check_authors = 1 },
    "--dont-check-authors,--no-check-authors," .
    "--do-not-check-authors"
        => sub{ $check_authors = 0 },

    "--check-chemical-formula-sum"
        => sub{ $check_chemical_formula_sum = 1 },
    "--check-only-chemical-formula-sum"
        => sub{ dont_check_any(); $check_chemical_formula_sum = 1 },
    "--dont-check-chemical-formula-sum,--no-check-chemical-formula-sum," .
    "--do-not-check-chemical-formula-sum"
        => sub{ $check_chemical_formula_sum = 0 },

    "--check-spacegroup-info"
        => sub{ $check_spacegroup_info = 1 },
    "--check-only-spacegroup-info"
        => sub{ dont_check_any(); $check_spacegroup_info = 1 },
    "--dont-check-spacegroup-info,--no-check-spacegroup-info" .
    "--do-not-check-spacegroup-info"
        => sub{ $check_spacegroup_info = 0 },

    "--check-symmetry-operators,--check-operators"
        => sub{ $check_symmetry_operators = 1 },
    "--check-only-symmetry-operators,--check-only-operators"
        => sub{ dont_check_any(); $check_symmetry_operators = 1 },
    "--dont-check-symmetry-operators,--no-check-symmetry-operators" .
    "--do-not-check-symmetry-operators" .
    "--dont-check-operators,--no-check-operators" .
    "--do-not-check-operators"
        => sub{ $check_symmetry_operators = 0 },

    "--check-constraints-on-unit-cell," .
    "--check-unit-cell"
        => sub{ $check_spacegroup_constraints = 1 },
    "--check-only-constraints-on-unit-cell," .
    "--check-only-unit-cell"
        => sub{ dont_check_any(); $check_spacegroup_constraints = 1 },
    "--dont-check-constraints-on-unit-cell," .
    "--do-not-check-constraints-on-unit-cell," .
    "--no-check-constraints-on-unit-cell," .
    "--dont-check-unit-cell,--do-not-check-unit-cell," .
    "--no-check-unit-cell"
        => sub{ $check_spacegroup_constraints = 0 },

    "--check-symmetry" => sub{
        $check_spacegroup_info = 1;
        $check_symmetry_operators = 1;
        $check_spacegroup_constraints = 1;
    },

    "--check-only-symmetry" => sub{
        dont_check_any();
        $check_spacegroup_info = 1;
        $check_symmetry_operators = 1;
        $check_spacegroup_constraints = 1;
    },

    "--check-simultaneous-presence" =>
        sub{ $check_simultaneous_presence = 1 },
    "--check-only-simultaneous-presence" =>
        sub{ dont_check_any(); $check_simultaneous_presence = 1 },
    "--dont-check-simultaneous-presence" =>
        sub{ $check_simultaneous_presence = 0 },

    "--check-limits" => sub{ $check_limits = 1 },
    "--check-only-limits" => sub{ dont_check_any(); $check_limits = 1 },
    "--dont-check-limits,--no-check-limits,--do-not-check-limits"
        => sub{ $check_limits = 0 },
    
    "--limits-file" => sub{ $limits_table = &get_limits_table( &get_value() ) },

    "--add-limits" => sub{ $limits_table = &merge_limits_tables( 
                               &get_limits_table( &get_value() ),
                               $limits_table )
    },

    "--reset-limits" => sub{ $limits_table = \%default_limits_table },
    
    "--print-limits" => sub{ &print_limits() }, 

    "--check-temperature-factors" =>
        sub { $check_temperature_factors = 1; },
    "--dont-check-temperature-factors,--no-check-temperature-factors" =>
        sub { $check_temperature_factors = 0; },
    "--do-not-check-temperature-factors" =>
        sub { $check_temperature_factors = 0; },
    "--max-year-temperature-factors-optional" =>
        \$max_year_temperature_factors_optional,

    "--check-embedded-file-integrity" =>
        sub { $check_embedded_file_integrity = 1; },
    "--dont-check-embedded-file-integrity" =>
        sub { $check_embedded_file_integrity = 0; },
    "--do-not-check-embedded-file-integrity" =>
        sub { $check_embedded_file_integrity = 0; },
    "--no-check-embedded-file-integrity" =>
        sub { $check_embedded_file_integrity = 0; },
    "--check-only-embedded-file-integrity" =>
        sub { dont_check_any(); $check_embedded_file_integrity = 1; },

    "--check-z"        => sub { $check_z = 1; },
    "--check-only-z"   => sub { dont_check_any(); $check_z = 1; },
    "--no-check-z"     => sub { $check_z = 0; },
    "--dont-check-z"   => sub { $check_z = 0; },
    "--do-not-check-z" => sub { $check_z = 0; },

    "--check-all"
        => \&check_all,

    "--check-none,--dont-check-any,--do-not-check-any,--no-check-any"

        => \&dont_check_any,

    "--use-precisions"        => sub { $use_precisions = 1 },
    "--dont-use-precisions"   => sub { $use_precisions = 0 },
    "--do-not-use-precisions" => sub { $use_precisions = 0 },
    "--ignore-precisions"     => sub { $use_precisions = 0 },

    "--use-reporter" => sub{ $useReporter = 1; $reportFile = get_value() },

    "--use-perl-parser" => sub{ $use_parser = "perl" },
    "--use-c-parser"    => sub{ $use_parser = "c" },

    "--help,--usage" => sub { usage; exit },
);

if( $reportFile =~ m/^\s*-\s*$/ || !-w dirname($reportFile) ) {
    open reportFileFH, ">&", \*STDOUT or die "Can't dup STDOUT: $!";
} else {
    open reportFileFH, ">", $reportFile;
}

# The subroutine that prints out the table of limits

sub print_limits {
    print "#" . "-"x70  . "\n" .
          "# The table of data value limits that 'cif_cod_check' script \n" .
          "# uses under the option '--check-limits'.\n" .
          "#" . "-"x70  . "\n";
    foreach my $tag( sort keys %$limits_table ) {
        printf "%-32s", $tag;
        for my $i( 0..$#{ $limits_table->{$tag} } ) {
            print "\t" , join( "-", @{ $limits_table->{$tag}[$i]} );
        }
        print "\n";
    }
    exit 0;
}

binmode( reportFileFH, 'utf8' );

my %spacegroups = map {
    my $key1 = $_->[1];
    my $key2 = $_->[2];
    $key1 =~ s/\s//g;
    $key2 =~ s/\s//g;
    ($_->[2], $_->[2], $_->[1], $_->[2], $key1, $_->[2], $key2, $_->[2] )
} @COD::Spacegroups::Names::names,
  map { [ $_->{'number'}, $_->{'hermann_mauguin'}, $_->{'universal_h_m'} ] }
      @COD::Spacegroups::Lookup::COD::table,
      @COD::Spacegroups::Lookup::COD::extra_settings;

$| = 1; # Flush buffers immediately, to avoid mixing lines of STDOUT
        # and STDERR.

@ARGV = ("-") unless @ARGV;

for my $filename (@ARGV) {

    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    if ( $use_parser eq 'perl' && $useReporter ) {
        $options->{reporter} = \&parser_reporter;
    };

    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );

    if ( $err_count > 0 ) {
        print STDERR $_ foreach ( @$messages );
        error( $0, $filename, undef, "$err_count error(s) "
             . "encountered while parsing the file", undef );
        exit -1;
    }
    print STDERR $_ foreach ( @$messages );

    canonicalize_all_names( $data );

    my $warnings = 0;
    my $errors   = 0;
    for my $dataset (@$data) {

        my $dataname = 'data_' . $dataset->{name} if defined $dataset->{name};

        local $SIG{__WARN__} =
                   sub {process_warnings( $filename, $dataname, @_,
                                          {
                                            WARNING => $die_on_warnings,
                                            NOTE    => $die_on_notes,
                                          }
                                        ) };

        # Variables to hold errors returned from a single function (f)
        my ($f_warnings, $f_errors);

        $warnings += check_data( $dataset );
        $warnings += check_bibliography( $dataset )
            if $check_bibliography;
        $warnings += check_authors( $dataset )
            if $check_authors;
        $warnings += check_chemical_formula_sum( $dataset )
            if $check_chemical_formula_sum;
        $warnings += check_spacegroup_info( $dataset )
            if $check_spacegroup_info;
        $warnings += check_symmetry_operators( $dataset )
            if $check_symmetry_operators;
        $warnings += check_spacegroup_constraints( $dataset )
            if $check_spacegroup_constraints;
        if ( $check_limits ) {
            ($f_warnings, $f_errors) = check_limits( $dataset );
            $warnings += $f_warnings;
            $errors   += $f_errors;
        };
        $warnings += check_temperature_factors( $dataset )
            if $check_temperature_factors;
        $warnings += check_simultaneous_presence( $dataset )
            if $check_simultaneous_presence;
        $warnings += check_embedded_file_integrity( $dataset )
            if $check_embedded_file_integrity;
        $warnings += check_z( $dataset )
            if $check_z;
    }

    eval {
        local $SIG{__WARN__} =
                   sub {process_warnings( $filename, undef, @_,
                                          {
                                            WARNING => $die_on_warnings,
                                            NOTE    => $die_on_notes,
                                          }
                                        ) };
        my ($f_warnings, $f_errors) = check_pdcif_relations( $data );
        $warnings += $f_warnings;
        $errors   += $f_errors;
    };
    printf "%-30s: OK\n", $filename if $warnings == 0 && $errors == 0;
}

sub check_data
{
    my ($dataset) = @_;

    if( !defined $dataset->{values} ) {
        warn "no datablocks found -- program will now exit\n";
        return 1;
    } else {
        return 0;
    }
}

sub check_bibliography
{
    my ($dataset) = @_;
    
    if( !defined $dataset->{values} ) {
        return 0;
    }

    my $warnings = 0;
    my $values = $dataset->{values};

    if( $require_only_doi &&
        defined $values->{_journal_paper_doi} ) {
        return 0;
    }

    if( !defined $values->{_journal_name_full} ) {
        warn "WARNING, _journal_name_full is undefined\n";
        $warnings++;
    }
    if( !defined $values->{_publ_section_title} ) {
        warn "WARNING, _publ_section_title is undefined\n";
        $warnings++;
    }
    if( !defined $values->{_journal_year} &&
        !defined $values->{_journal_volume} ) {
        warn "WARNING, neither _journal_year nor _journal_volume is defined\n";
        $warnings++;
    }
    if( !defined $values->{_journal_page_first} &&
        !defined $values->{_journal_article_reference} ) {
        warn 'WARNING, neither _journal_page_first nor '
           . "_journal_article_reference is defined\n";
        $warnings++;
    }
    return $warnings;
}

sub check_authors
{
    use COD::CIF::Unicode2CIF;

    my ($dataset) = @_;

    if( !defined $dataset->{values} ) {
        return 0;
    }

    my $warnings = 0;
    my $values = $dataset->{values};

    my $First = qr/[[:upper:]] ('[[:alpha:]])? [[:lower:]]*
                   ( \s*-\s* [[:upper:]]? ['[:lower:]]* )?/x;
                # Armel, Miguel, O'Reily, Ding-Quan, Chun-hsien

    my $Initial = qr/[[:upper:]] [[:lower:]]? \.
                   ( \s*-\s* [[:upper:]] [[:lower:]]?\. )?/x;
                # A., M., O., D.-Q.

    my $Last = qr/([[:upper:]][[:lower:]]{1,2})? # optional Mc, Da, La prefix
                   [[:upper:]] ('[[:alpha:]])? ['[:lower:]]*
                  (?: \s*-\s* [[:upper:]] ['[:lower:]]+ )?
                  (?: \s+ i \s+ [[:upper:]] [[:lower:]]+ )? # poss. 'i Surname'
                  |
                  [[:upper:]][[:lower:]]+
                  -[[:lower:]][[:lower:]]-
                  [[:upper:]][[:lower:]]+
                  /x;
                # Neuman, D'Lamber, le Bail, Le Bail (?), Mairata i Payeras

    my $von = qr/[a-zA-Z][a-z]+(\s+[a-zA-Z][a-z]+)?/;
                # von, van, de, De, de la

    my $Jr  = qr/[A-Za-z]+\.?/;
                # Jr, Jr., I, II, III, IV

    my $FirstNames = qr/${First}(\s+${First})*/;
    my $Initials = qr/(${Initial}\s*|${First}\s+)*(${First}|${Initial})/;
    my $LastNames = qr/${Last}(\s+${Last})*/;
    my $vonLast = qr/(${von}\s+)?${Last}/;
    my $vonLastNames = qr/(${von}\s+)?${Last}(\s+${Last})*/;

    if( !defined $values->{_publ_author_name} ) {
        warn "WARNING, _publ_author_name is undefined\n";
        $warnings++;
    } else {
        for my $author (@{$values->{_publ_author_name}}) {
            my $UCS_author = cif2unicode( $author );
            if( $UCS_author =~ /^([^[:alpha:]])/ ||
                $UCS_author =~ /([^-\.,[:alpha:]'()\s])/ ) {
                my $symbol_escaped = $1;
                my $author_escaped = $author;
                my $UCS_author_escaped = $UCS_author;
                $symbol_escaped =~ s/\n/\\n/g;
                $author_escaped =~ s/\n/\\n/g;
                $UCS_author_escaped =~ s/\n/\\n/g;
                warn "WARNING, name '$author_escaped'"
                   . ( $author eq $UCS_author
                                ? ""
                                : " ('$UCS_author_escaped')" )
                   . " contains symbol '$symbol_escaped' "
                   . "that is not permitted in names\n";
                if( ! $name_syntax_explained ) {
                    warn "NOTE, names should be written as 'First von Last', "
                       . "'von Last, First', or 'von Last, Jr, First' "
                       . "(mind the case!)\n";
                    $name_syntax_explained = 1;
                }
                $warnings++;
            } elsif( $UCS_author !~
                /^\s*${FirstNames}\s+${vonLast}\s*$/ &&
                $UCS_author !~
                /^\s*${Initials}\s*${vonLast}\s*$/ &&
                $UCS_author !~
                /^\s*${vonLastNames}\s*,\s*${FirstNames}\s*$/ &&
                $UCS_author !~
                /^\s*${vonLastNames}\s*,\s*${Initials}\s*$/ &&
                $UCS_author !~
                /^\s*${vonLastNames}\s*,\s*${Jr}\s*,\s*${FirstNames}\s*$/ &&
                $UCS_author !~
                /^\s*${vonLastNames}\s*,\s*${Jr}\s*,\s*${Initials}\s*$/ &&
                $UCS_author !~
                /^\s*${First}-ur-${Last}\s*$/
                ) {
                warn "NOTE, name '$author'"
                    . ( $author eq $UCS_author ? ""
                                               : " ('$UCS_author')" )
                    . " seems unusual\n";
                if( ! $name_syntax_explained ) {
                    warn "NOTE, names should be written as 'First von Last', "
                       . "'von Last, First', or 'von Last, Jr, First' "
                       . "(mind the case!)\n";
                    $name_syntax_explained = 1;
                }
                $warnings++;
            }
        }
    }
    return $warnings;
}

sub check_chemical_formula_sum
{
    my ($dataset) = @_;

    if( !defined $dataset->{values} ) {
        return 0;
    }

    my $formula = $dataset->{values}{_chemical_formula_sum}[0];

    my $formula_component = "[a-zA-Z]{1,2}[0-9.]*";

    if( !defined $formula ) {
        warn "WARNING, no _chemical_formula_sum\n";
        return 1;
    } elsif( $formula !~
             /^\s*($formula_component\s+)*($formula_component)\s*$/ ) {
        warn "WARNING, chemical formula '$formula' could not be parsed\n";
        return 1;
    } else {
        return 0;
    }
}

sub check_spacegroup_info
{
    my ($dataset) = @_;

    if( !defined $dataset->{values} ) {
        return 0;
    }

    my $symops = $dataset->{values}{_symmetry_equiv_pos_as_xyz};
    my $values = $dataset->{values};

    my @spacegroup_tags = qw (
        _symmetry_space_group_name_H-M
        _symmetry_space_group_name_Hall
        _symmetry_Int_Tables_number
        _space_group_name_H-M_alt
        _space_group.name_H-M_full
        _space_group_name_Hall
        _space_group_ssg_name
        _space_group_ssg_name_IT
        _space_group_ssg_name_WJJ
    );

    my $warnings = 0;
    my $spacegroup_found;
    my $spacegroup;

    for my $sg_tag (@spacegroup_tags) {
        if( exists $values->{$sg_tag} ) {
            $spacegroup = $values->{$sg_tag}[0];
            my $no_spaces = $spacegroup;
            $no_spaces =~ s/\s//g;
            $no_spaces =~ s/[\(\)~]//g;
            if( $sg_tag =~ /H-M/ ) {
                if( defined $spacegroup &&
                    !exists $spacegroups{$spacegroup} &&
                    !exists $spacegroups{$no_spaces} ) {
                    warn "WARNING, unrecognised spacegroup '$spacegroup'\n";
                    $warnings++;
                } else {
                    $spacegroup_found =
                        (exists $spacegroups{$spacegroup} )
                              ? $spacegroups{$spacegroup}
                              : $spacegroups{$no_spaces};
                }
            }
            last
        }
    }
    if( !defined $spacegroup ) {
        if( !defined $symops ) {
            warn "WARNING, no symmetry information found\n";
        } else {
            warn "WARNING, no spacegroup symbol found\n";
        }
        $warnings++;
    }

    my %symops_cannonical;
    if( defined $symops ) {
        my %duplicate_symops;
        for my $symop (@$symops) {
            my $cannonical_symop =
                symop_string_canonical_form( $symop );
            if( !exists $duplicate_symops{$cannonical_symop} ) {
                $duplicate_symops{$cannonical_symop} = [];
            }
            push( @{$duplicate_symops{$cannonical_symop}}, $symop );
        }
        for my $cannonical_symop (sort keys %duplicate_symops) {
            $symops_cannonical{$cannonical_symop} =
                $duplicate_symops{$cannonical_symop}[0];
            if( @{ $duplicate_symops{$cannonical_symop} } > 1 ) {
                warn "NOTE, symmetry operator '$cannonical_symop' is repeated "
                     . scalar( @{ $duplicate_symops{$cannonical_symop} } )
                     . " times (as "
                     . join( ", ", map { "'$_'" }
                             @{ $duplicate_symops{$cannonical_symop} } )
                     . ") in symmetry operator list\n";
                $warnings++;
            }
        }
    }

    if( defined $symops && defined $spacegroup_found ) {
        my $spacegroup_info = lookup_spacegroup( 'hermann_mauguin',
                                                 $spacegroup_found );
        if( defined $spacegroup_info ) {
            my %sg_symops_cannonical =
                map { symop_string_canonical_form( $_ ) => $_ }
                @{ $spacegroup_info->{symops} };

            my @missing_symops;
            for my $s (sort keys %sg_symops_cannonical) {
                next if exists $symops_cannonical{$s};
                push( @missing_symops, $s );
            }
            if( @missing_symops > 0 ) {
                my $single = (@missing_symops == 1);
                warn "NOTE, symmetry operator"
                     . (!$single ? "s " : " ")
                     . join( ", ", map { "'$_'" } @missing_symops )
                     . " " . ($single ? "is" : "are")
                     . " missing, although required by "
                     . "the spacegroup '$spacegroup_found'\n";
                $warnings++;
            }

            my @excess_symops;
            for my $s (sort keys %symops_cannonical) {
                next if exists $sg_symops_cannonical{$s};
                push( @excess_symops, $symops_cannonical{$s} );
            }
            if( @excess_symops > 0 ) {
                my $single = (@excess_symops == 1);
                warn "NOTE, symmetry operator"
                    . (!$single ? "s " : " ")
                    . join( ", ", map { "'$_'" } @excess_symops )
                    . " " . ($single ? "is" : "are")
                    . " found, although not required by "
                    . "the spacegroup '$spacegroup_found'\n";
                $warnings++;
            }
        }
    }

    return $warnings;
}

sub check_temperature_factors
{
    my($dataset) = @_;

    if( !defined $dataset->{values} ) {
        return 0;
    }

    my $values = $dataset->{values};
    my $warnings = 0;

    if( tag_is_empty( $dataset, '_journal_year' ) ) {
        return 0;
    }
    if( $values->{_journal_year}[0] <= 
        $max_year_temperature_factors_optional ) {
        return 0;
    }

    if( !tag_is_empty($dataset,'_atom_site_B_iso_or_equiv') ||
        !tag_is_empty($dataset,'_atom_site_U_iso_or_equiv') ) {
        return 0;
    }
    foreach my $indexes ( '11', '12', '13', '22', '23', '33' ) {
        if( !tag_is_empty($dataset,
            '_atom_site_aniso_B_' . $indexes) ||
            !tag_is_empty($dataset,
            '_atom_site_aniso_U_' . $indexes) ) {
            return 0;
        }
    }
    warn "WARNING, structure is published after "
       . "$max_year_temperature_factors_optional, but does not contain "
       . "temperature factors\n";
    $warnings++;
    return $warnings;
}

sub check_pdcif_relations
{
    my ($data) = @_;

    my $overall_info_datablock;
    my $overall_info_datablock_count = 0;

    my $warnings = 0;
    my $errors   = 0;
    my $pd_ids   = {};

    my @phases;
    my @diffractograms;

    for( my $i = 0; $i < @$data; $i++ ) {
        my $dataset = $data->[$i];
        my $datablock = $dataset->{values};
        if( exists $datablock->{_pd_block_id} ) {
            my $datablock_pd_id = $datablock->{_pd_block_id}[0];
            if( exists $pd_ids->{$datablock_pd_id} ) {
                warn 'ERROR, two or more datablocks with _pd_block_id '
                   . "'$datablock_pd_id' were found -- "
                   . "_pd_block_id must be unique for each datablock\n";
                $errors++;
            } else {
                $pd_ids->{$datablock_pd_id} = $i;
                if( exists $datablock->{_atom_site_label} ) {
                    push( @phases, $i );
                } elsif( grep( /^_refln_index_.$/, keys %$datablock ) > 0 ) {
                    push( @diffractograms, $i );
                }
            }
        }
        if( exists $datablock->{_pd_phase_block_id} &&
            exists $datablock->{_pd_block_diffractogram_id} ) {
            if( !defined $overall_info_datablock ) {
                $overall_info_datablock = $i;
            }
            $overall_info_datablock_count++;
        }
    }

    return ($warnings, $errors) if @phases + @diffractograms == 0;

    if( $overall_info_datablock_count > 1 ) {
        warn "NOTE, $overall_info_datablock_count datablocks having both "
           . "_pd_phase_block_id and _pd_block_diffractogram_id were found -- "
           . "taking the first occurence as the overall information "
           . "datablock\n";
        $warnings++;
    }

    # Checking whether all powder diffraction IDs from the overall
    # information datablock (if such exists) point to existing
    # datablocks. Also, checking whether all phases and diffractograms
    # are listed in overall information datablock:

    if( $overall_info_datablock_count > 0 ) {
        my $overall_block = $data->[$overall_info_datablock];
        my $overall_data = $overall_block->{values};
        my $overall_dataname = 'data_' . $overall_block->{name};

        for my $phase_id (@{$overall_data->{_pd_phase_block_id}}) {
            if( !exists $pd_ids->{$phase_id} ) {
                warn "ERROR, phase datablock with _pd_block_id '$phase_id'"
                   . "is listed in the _pd_phase_block_id loop of the "
                   . "overall information datablock '$overall_dataname', "
                   . "but does not exist\n";
                $errors++;
            }
        }
        for my $diffractogram_id (@{$overall_data->{_pd_block_diffractogram_id}}) {
            if( !exists $pd_ids->{$diffractogram_id} ) {
                warn "ERROR, diffractogram datablock with _pd_block_id "
                   . "'$diffractogram_id' listed in the "
                   . "_pd_block_diffractogram_id loop of the overall "
                   . "datablock '$overall_dataname', but does not exist\n";
                $errors++;
            }
        }
        for my $phase_nr (@phases) {
            my $phase_block = $data->[$phase_nr];
            my $phase_data = $phase_block->{values};
            if( grep( $_ eq $phase_data->{_pd_block_id}[0],
                      @{$overall_data->{_pd_phase_block_id}} ) == 0 ) {
                warn "ERROR, phase datablock 'data_" . $phase_block->{name}
                   . "' " . "is not listed in _pd_phase_block_id loop of the "
                   . "overall information datablock '$overall_dataname'\n";
                $errors++;
            }
        }
        for my $diffractogram_nr (@diffractograms) {
            my $diffractogram_block = $data->[$diffractogram_nr];
            my $diffractogram_data = $diffractogram_block->{values};
            if( grep( $_ eq $diffractogram_data->{_pd_block_id}[0],
                      @{$overall_data->{_pd_block_diffractogram_id}} ) == 0 ) {
                warn "ERROR, diffractogram datablock 'data_"
                    . $diffractogram_block->{name} . "' is not listed in "
                    . "_pd_block_diffractogram_id loop of the overall "
                    . "information datablock '$overall_dataname'\n";
                $errors++;
            }
        }
    }

    # Looking for stray powder diffraction datablocks -- each datablock
    # with _pd_block_id should be listed in overall information
    # datablock (except publication datablock and the overall information
    # datablock itself):

    for my $phase_nr (@phases) {
        my $phase_block = $data->[$phase_nr];
        my $phase_data = $phase_block->{values};
        my $phase_dataname = 'data_' . $phase_block->{name};
        if( !exists $phase_data->{_pd_block_diffractogram_id} ) {
            warn "ERROR, phase datablock '$phase_dataname' does not "
               . "contain a diffractogram list\n";
            $errors++;
            next;
        }
        for my $diffractogram_id (@{$phase_data->{_pd_block_diffractogram_id}}) {
            if( !exists $pd_ids->{$diffractogram_id} ) {
                warn "ERROR, diffractogram datablock with _pd_block_id "
                   . "'$diffractogram_id' is listed in the phase datablock "
                   . "'$phase_dataname', but does not exist'\n";
                $errors++;
                next;
            }
            my $diffractogram_nr = $pd_ids->{$diffractogram_id};
            my $diffractogram_block = $data->[$diffractogram_nr];
            my $diffractogram_data = $diffractogram_block->{values};
            my $diffractogram_dataname = 'data_' . $diffractogram_block->{name};
            if( !exists $diffractogram_data->{_pd_phase_block_id} ) {
                warn "ERROR, diffractogram datablock '$diffractogram_dataname' "
                   . "does not contain a phase list\n";
                $errors++;
                next;
            }
            my $found = 0;
            for my $phase_id (@{$diffractogram_data->{_pd_phase_block_id}}) {
                if( !exists $pd_ids->{$phase_id} ) {
                    warn "ERROR, phase datablock with _pd_block_id "
                       . "'$phase_id' is listed in the difractogram datablock "
                       . "'$diffractogram_dataname', but does not exist\n";
                    $errors++;
                }
                if( $pd_ids->{$phase_id} == $phase_nr ) {
                    $found = 1;
                    last;
                }
            }
            if( !$found ) {
                # If diffractogram datablock does not contain a backlink 
                # to the phase block, we assume that the backlink is:
                warn "WARNING, value '" . $phase_data->{_pd_block_id}[0] . "' "
                   . "seems to be missing in the _pd_phase_block_id list of "
                   . "the difractogram datablock '$diffractogram_dataname'\n";
                $warnings++;
            }
        }
    }

    for my $diffractogram_nr (@diffractograms) {
        my $diffractogram_block = $data->[$diffractogram_nr];
        my $diffractogram_data = $diffractogram_block->{values};
        my $diffractogram_dataname = 'data_' . $diffractogram_block->{name};
        if( !exists $diffractogram_data->{_pd_phase_block_id} ) {
            warn "ERROR, diffractogram datablock '$diffractogram_dataname' " .
                 "does not contain a phase list\n";
            $errors++;
            next;
        }
        for my $phase_id (@{$diffractogram_data->{_pd_phase_block_id}}) {
            if( !exists $pd_ids->{$phase_id} ) {
                warn "ERROR, phase datablock with _pd_block_id '$phase_id' "
                   . "is listed in the difractogram datablock "
                   . "'$diffractogram_dataname', but does not exist\n";
                $errors++;
                next;
            }
            my $phase_nr = $pd_ids->{$phase_id};
            my $phase_block = $data->[$phase_nr];
            my $phase_data = $phase_block->{values};
            my $phase_dataname = 'data_' . $phase_block->{name};
            if( !exists $phase_data->{_pd_block_diffractogram_id} ) {
                warn "ERROR, phase datablock '$phase_dataname' "
                   . "does not contain a diffractogram list\n";
                $errors++;
                next;
            }
            my $found = 0;
            for my $diffractogram_id (@{$phase_data->{_pd_block_diffractogram_id}}) {
                if( !exists $pd_ids->{$diffractogram_id} ) {
                    warn "ERROR, diffractogram datablock with _pd_block_id "
                       . "'$diffractogram_id' is listed in the phase "
                       . "datablock '$phase_dataname', but does not exist\n";
                    $errors++;

                }
                if( $pd_ids->{$diffractogram_id} == $diffractogram_nr ) {
                    $found = 1;
                    last;
                }
            }
            if( !$found ) {
                # If phase datablock does not contain a backlink to the 
                # diffractogram, we are not sure if it is omitted or added:
                warn "ERROR, value '" . $diffractogram_data->{_pd_block_id}[0]
                   . "' " . "seems to be missing in _pd_block_diffractogram_id "
                   . "list of the phase datablock '$phase_dataname'\n";
                $errors++;
            }
        }
    }

    return ($warnings, $errors);
}

#===============================================================#
# Gets symmetry operators if they are not directly represented in the CIF file.

# Accepts
#     option - an option, for example, "hall"
#     param  - according to an option a value given in the CIF file

# Uses @COD::Spacegroups::Lookup::COD::table =
# (
# {
#     number          => 1,
#     hall            => ' P 1',
#     schoenflies     => 'C1^1',
#     hermann_mauguin => 'P 1',
#     universal_h_m   => 'P 1',
#     crystal_class   => 'monoclinic',
#     constraints     => '1',
#     symops => [
#         'x,y,z',
#     ],
#     ncsym => [
#         'x,y,z',
#     ]
# },
# );

# Returns a reference to the spacegroup descriptor
# (a @COD::Spacegroups::Lookup::COD::table element).

sub lookup_spacegroup
{
    my ($option, $param) = @_;

    $param =~ s/ //g;
    $param =~ s/_//g;

    foreach my $hash (@COD::Spacegroups::Lookup::COD::table,
                      @COD::Spacegroups::Lookup::COD::extra_settings) {
        my $value = $hash->{$option};
        $value =~ s/ //g;
        $value =~ s/_//g;

        if( $value eq $param ) {
            return $hash;
        }
    }
    return undef;
}

sub get_spacegroup_descriptions
{
    my ($dataset) = @_;

    my $values = $dataset->{values};

    my $sym_data;
    my $warnings = 0;

    if( exists $values->{"_space_group_name_Hall"} &&
        not defined $sym_data ) {
        my $hall = $values->{"_space_group_name_Hall"}[0];
        $sym_data = lookup_spacegroup("hall", $hall);

        if( !defined $sym_data ) {
            warn "WARNING, incorrect _space_group_name_Hall '$hall'\n";
            $warnings++;
        }
    } elsif( exists $values->{"_symmetry_space_group_name_Hall"} &&
        not defined $sym_data ) {
        my $hall = $values->{"_symmetry_space_group_name_Hall"}[0];
        $sym_data = lookup_spacegroup("hall", $hall);
        
        if( !defined $sym_data ) {
            warn "WARNING, incorrect _symmetry_space_group_name_Hall '$hall'\n";
            $warnings++;
        }
    }
    
    if(exists $values->{"_space_group_name_H-M_alt"} &&
       not defined $sym_data) {
        my $h_m = $values->{"_space_group_name_H-M_alt"}[0];
        $sym_data = lookup_spacegroup("hermann_mauguin", $h_m);
        $sym_data = lookup_spacegroup("universal_h_m", $h_m)
            unless defined $sym_data;
        
        if( !defined $sym_data ) {
            warn "WARNING, incorrect _space_group_name_H-M_alt '$h_m'\n";
            $warnings++;
        }
    } elsif(exists $values->{"_symmetry_space_group_name_H-M"} &&
            not defined $sym_data) {
        my $h_m = $values->{"_symmetry_space_group_name_H-M"}[0];
        $sym_data = lookup_spacegroup("hermann_mauguin", $h_m);
        $sym_data = lookup_spacegroup("universal_h_m", $h_m)
            unless defined $sym_data;
        
        if( !defined $sym_data ) {
            warn "WARNING, incorrect _symmetry_space_group_name_H-M '$h_m'\n";
            $warnings++;
        }
    }
    
    if(not defined $sym_data) {
        if( $warnings == 0 ) {
            my @spacegroup_tags = qw (
                _space_group_symop_ssg_id
                _space_group_symop_ssg_operation_algebraic
                _space_group_ssg_name
                _space_group_ssg_name_IT
                _space_group_ssg_name_WJJ
            );
            for my $sg_tag (@spacegroup_tags) {
                if( exists $dataset->{values}{$sg_tag} ) {
                    return (undef, 0);
                }
            }
            warn "WARNING, no spacegroup symbol to check cell constraints\n";
            $warnings = 1;
        }
    }

    return ( $sym_data, $warnings );
}

sub get_unit_cell_sigmas($)
{
    my ($dataset) = @_;
    my $values = $dataset->{precisions};

    my @cellsig;

    for my $cif_tag (qw(_cell_length_a
                        _cell_length_b
                        _cell_length_c
                        _cell_angle_alpha
                        _cell_angle_beta
                        _cell_angle_gamma
                        )) {
        push( @cellsig, $values->{$cif_tag}[0] );
    }

    return @cellsig;
}

sub regularize_cell($$$$)
{
    my ( $cell, $cellsig, $crystal_class, $h_m_symbol ) = @_;

    my @regcell = @$cell;

    my @cellsig = map { defined $_ ? $_ : 0 } @$cellsig;

    # snap cell lengths:
    if( $crystal_class ne "triclinic" && $crystal_class ne "monoclinic" ) {
        if( eqsig( $cell->[0], $cellsig[0], $cell->[1], $cellsig[1] )) {
            if( ( $crystal_class eq "rhombohedral" ||
                  $crystal_class eq "cubic" ) &&
                eqsig( $cell->[0], $cellsig[0], $cell->[2], $cellsig[2] ) &&
                eqsig( $cell->[1], $cellsig[1], $cell->[2], $cellsig[2] )) {
                $regcell[1] = $regcell[2] = $regcell[0];
            } else {
                $regcell[0] = $regcell[1];
            }
        } elsif( eqsig( $cell->[0], $cellsig[0], $cell->[2], $cellsig[2] )) {
                $regcell[0] = $regcell[2];
        } elsif( eqsig( $cell->[1], $cellsig[1], $cell->[2], $cellsig[2] )) {
                $regcell[1] = $regcell[2];
        }
    }

    # snap unit cell angles:
    for my $i (( 3, 4, 5 )) {
        my $angle = $cell->[$i];
        my $sigma = $cellsig[$i];
        if( eqsig( $angle, $sigma, 90, 0 ) &&
            $crystal_class ne "triclinic" &&
            ( $crystal_class ne "rhombohedral" ||
              $h_m_symbol =~ /^H|:H$/ )) {
            $regcell[$i] = 90;
        } elsif( eqsig( $angle, $sigma, 120, 0 ) &&
                 (( $crystal_class eq "rhombohedral" &&
                    $h_m_symbol =~ /^H|:H$/ ) ||
                  $crystal_class eq "trigonal" ||
                  $crystal_class eq "hexagonal" )) {
            $regcell[$i] = 120;
        }
    }

    if( $crystal_class eq "rhombohedral" && $h_m_symbol !~ /^H|:H$/ ) {
        if( eqsig( $cell->[3], $cellsig[3], $cell->[4], $cellsig[4] ) &&
            eqsig( $cell->[3], $cellsig[3], $cell->[5], $cellsig[5] ) &&
            eqsig( $cell->[4], $cellsig[4], $cell->[5], $cellsig[5] )) {
            $regcell[4] = $regcell[5] = $regcell[3];
        }
    }

    return @regcell;
}

sub check_spacegroup_constraints
{
    my ( $dataset ) = @_;

    if( !defined $dataset->{values} ) {
        return 0;
    }

    my ( $spacegroup_descr, $warnings ) =
        get_spacegroup_descriptions( $dataset );

    if( !defined $spacegroup_descr ) {
        return $warnings;
    }

    if( !exists $spacegroup_descr->{constraints} ) {
        warn "WARNING, could not find constraints for spacegroup ".
             "'$spacegroup_descr->{universal_h_m}'\n";
        return $warnings + 1;
    }

    my $constraints = $spacegroup_descr->{'constraints'};
    my $cryst_class = $spacegroup_descr->{'crystal_class'};
    my $h_m_symbol = $spacegroup_descr->{'universal_h_m'};
    my @cell = get_cell( $dataset->{values} );
    my @cellsig = get_unit_cell_sigmas( $dataset );

    do {
        my ( $a, $b, $c, $alpha, $beta, $gamma );

        if( $use_precisions ) {
            ( $a, $b, $c, $alpha, $beta, $gamma ) =
                regularize_cell( \@cell, \@cellsig,
                                 $cryst_class, $h_m_symbol );
        } else {
            ( $a, $b, $c, $alpha, $beta, $gamma ) = @cell;
        }

        do {
            local $" = ", ";
            print ">>> CELL: @cell\n";
            print ">>> REGULARISED: $a, $b, $c, $alpha, $beta, $gamma\n";
        } if 0;

        if( !eval $constraints ) {
            local $" = " ";
            warn "WARNING, unit cell '@cell' does not satisfy " .
                 "constraints '$constraints'\n";
            return $warnings + 1;
        }

        do {
            local $" = " ";
            warn "NOTE, unit cell '$a $b $c $alpha $beta $gamma' "
               . "IS FINE with constraints '$constraints'!\n";
        } if 0;
    };
    return $warnings;
}

sub check_symmetry_operators
{
    my ($dataset) = @_;

    if( !defined $dataset->{values} ) {
        return 0;
    }

    my $symop_term = '(?:x|y|z|\d|\d*\.\d+|\d+\.\d*|\d/\d)';
    my $symop_component =
        "(?:(?:-|\\+)?$symop_term|" .
        "(?:-|\\+)?$symop_term(?:-|\\+)$symop_term|" .
        "(?:-|\\+)?$symop_term(?:-|\\+)$symop_term(?:-|\\+)$symop_term)";

    my $symops = $dataset->{values}{_symmetry_equiv_pos_as_xyz};

    if( !defined $symops ) {
        return 0; # Let's not regard missing symmetry operators as error.
    } else {
        for my $symop (@$symops) {
            my $no_spaces = $symop;
            $no_spaces =~ s/\s//g;
            if( $no_spaces !~ 
                /^($symop_component,){2}($symop_component)$/i ) {
                warn "symmetry operator '$symop' could not be parsed\n";
                return 1;
            }
        }
    }
    return 0;
}

sub parser_reporter
{
    my ($file, $line, $data) = @_;

    $file = "perl -e '...'" if ( $file eq '-' );
    $data = ( defined $data ) ? ' data_' . $data : '';

    my $report .= "$0: $file($line)" . $data . ': ';
    $report .= "number of the currently processed line -- $line.\n";

    print reportFileFH $report;
    flush reportFileFH;

    return 0;
}

# To check that the specified XYZ tag value is within expected limits.

sub check_limits {
    my ($dataset) = @_;
    my $warnings = 0;
    my $errors  = 0;

    if(! defined $dataset->{values} ) {
        return 0;
    }
    my @report_names = ( "ERROR", "WARNING", "NOTE" );
    my $numeric = '([+-]?(\d+(\.\d*)?|\.\d+))';
    my $values = $dataset->{values};
    
    foreach my $tag( sort keys %$limits_table ) {
        if( exists $values->{$tag} ) {
            my $value = $values->{$tag}[0];
            if( $value =~ /^(\.|\?)$/ ) {
                next;
            }
            if( $value !~ /^([+-]?(?:\d+(?:\.\d*)?|\.\d+))\(?(\d*)\)?$/ ) {
                warn "ERROR, tag '$tag' value '$value' is not numeric\n";
                $warnings++;
                $errors++;
                next;
            } else {
                my $number = $1;
                my $precision = $2;
                if( ($tag =~ /_w?R_factor_/) && ( $precision ) ) {
                    warn "WARNING, '$tag' value is '$value', but it should be "
                       . "numeric and without precision (esd value)\n";
                    $warnings++;
                    next;
                }
                if( $number < 0 ) {
                    warn "WARNING, '$tag' value '$value' "
                       . "should be in range [0.0;+inf]\n";
                    $warnings++;
                    next;
                } elsif(! defined $limits_table->{$tag}[0][1] ) {
                    foreach my $i( 0..$#{ $limits_table->{$tag} } ) {
                        my $limit = @{ $limits_table->{$tag}->[$i]}[0];
                        if( $number > $limit ) {
                            warn "$report_names[$i], tag '$tag' value "
                               . "'$value' is > $limit\n";
                            $warnings++;
                            $errors++ if $i == 0; # $i is @report_names index
                            last;
                        }
                    }
                } else {
                    foreach my $i( 0..$#{ $limits_table->{$tag} } ) {
                        my $begin = @{ $limits_table->{$tag}->[$i]}[0];
                        my $end = @{ $limits_table->{$tag}->[$i]}[1];
                        if( ($number < $begin) || ($number > $end) ) {
                            warn "$report_names[$i], tag '$tag' value "
                               . "'$value' lies outside the range "
                               . "$begin <> $end\n";
                            $warnings++;
                            $errors++ if $i == 0; # $i is @report_names index
                            last;
                        } 
                    }
                    
                }
            }
        }
    }
    return ($warnings, $errors);
}

# Check whether specified tags are all simultaneously persent. This
# check in COD is important for _atom_site_fractional_{x,y,z},
# _atom_site_Cartesian_{x,y,z} and _atom_site_aniso_U_?? data items.

sub check_simultaneous_presence
{
    my( $dataset ) = @_;
    my $warnings = 0;

    my @tag_lists = (
        [ qw( _atom_site_fract_x _atom_site_fract_y _atom_site_fract_z ) ],
        [ qw( _atom_site_Cartn_x _atom_site_Cartn_y _atom_site_Cartn_z ) ],
        [ qw( _atom_site_aniso_U_11
              _atom_site_aniso_U_22
              _atom_site_aniso_U_33
              _atom_site_aniso_U_23
              _atom_site_aniso_U_13
              _atom_site_aniso_U_12
            )
        ],
        [ qw(
              _tcod_atom_sites_sim_cell_tran_matrix_11
              _tcod_atom_sites_sim_cell_tran_matrix_12
              _tcod_atom_sites_sim_cell_tran_matrix_13
              _tcod_atom_sites_sim_cell_tran_matrix_21
              _tcod_atom_sites_sim_cell_tran_matrix_22
              _tcod_atom_sites_sim_cell_tran_matrix_23
              _tcod_atom_sites_sim_cell_tran_matrix_31
              _tcod_atom_sites_sim_cell_tran_matrix_32
              _tcod_atom_sites_sim_cell_tran_matrix_33
            )
        ],
        [ qw(
              _tcod_atom_sites_sim_cell_tran_vector_1
              _tcod_atom_sites_sim_cell_tran_vector_2
              _tcod_atom_sites_sim_cell_tran_vector_3
            )
        ],
        [ qw(
              _tcod_atom_site_initial_fract_x
              _tcod_atom_site_initial_fract_y
              _tcod_atom_site_initial_fract_z
            )
        ],
        [ qw(
              _tcod_atom_site_initial_Cartn_x
              _tcod_atom_site_initial_Cartn_y
              _tcod_atom_site_initial_Cartn_z
            )
        ],
        [ qw(
              _tcod_atom_site_resid_force_Cartn_x
              _tcod_atom_site_resid_force_Cartn_y
              _tcod_atom_site_resid_force_Cartn_z
            )
        ],
        [ qw(
              _tcod_atom_site_resid_force_fract_x
              _tcod_atom_site_resid_force_fract_y
              _tcod_atom_site_resid_force_fract_z
            )
        ],
        [ qw(
              _tcod_atom_site_resid_force_dir_cos_x
              _tcod_atom_site_resid_force_dir_cos_y
              _tcod_atom_site_resid_force_dir_cos_z
            )
        ],
        [ qw(
              _dft_BZ_integration_grid_X
              _dft_BZ_integration_grid_Y
              _dft_BZ_integration_grid_Z
            )
        ],
        [ qw(
              _dft_BZ_integration_grid_dens_X
              _dft_BZ_integration_grid_dens_Y
              _dft_BZ_integration_grid_dens_Z
            )
        ],
        [ qw(
              _dft_BZ_integration_grid_shift_X
              _dft_BZ_integration_grid_shift_Y
              _dft_BZ_integration_grid_shift_Z
            )
        ],
        [ qw(
              _dft_cell_periodic_BC_X
              _dft_cell_periodic_BC_Y
              _dft_cell_periodic_BC_Z
            )
        ],
        );

    for my $tag_list (@tag_lists) {
        $warnings += check_all_tags_present( $dataset, $tag_list );
    }

    return $warnings;
}

sub check_all_tags_present
{
    my( $dataset, $tag_list ) = @_;
    my ( %tags_present, %tags_absent );

    for my $tag (@{$tag_list}) {
        if( exists $dataset->{values}{$tag} ) {
            $tags_present{$tag} ++;
        } else {
            $tags_absent{$tag} ++;
        }
    }

    if( int(keys %tags_present) > 0 &&
        int(keys %tags_absent) > 0 ) {
        my @tags_present = sort {$a cmp $b} keys %tags_present;
        my @tags_absent = sort {$a cmp $b} keys %tags_absent;
        my $tag = $tags_present[0];

        warn "WARNING, tag '$tag' is present, but tag"
            . (int(@tags_absent) > 1 ? "s":"") . " "
            . join( ", ", @tags_absent ) . " are absent\n";
        return 1;
    } else {
        return 0;
    }
}

sub check_embedded_file_integrity
{
    my ($dataset) = @_;
    my $warnings = 0;
    my $values = $dataset->{values};

    my $encodings;
    eval {
        $encodings = get_content_encodings( $dataset );
    };
    if( $@ ) {
        warn $@;
        $warnings++;
    }

    for my $i (0..$#{$values->{_tcod_file_contents}}) {
        my $content  = $values->{_tcod_file_contents}[$i];
        my $path     = $values->{_tcod_file_name}[$i];
        my $md5sum   = $values->{_tcod_file_md5sum}[$i];
        my $sha1sum  = $values->{_tcod_file_sha1sum}[$i];
        my $encoding;
        if( exists $values->{_tcod_file_content_encoding} ) {
            $encoding = $values->{_tcod_file_content_encoding}[$i];
            $encoding = undef if $encoding eq '.';
        }

        next if $content eq '.' || $content eq '?';
        next if ($md5sum  eq '.' || $md5sum  eq '?') &&
                ($sha1sum eq '.' || $sha1sum eq '?');

        eval {
            if( !$encoding || !$encodings ||
                !exists $encodings->{$encoding} ) {
                if( $encoding && $encodings &&
                    !exists $encodings->{$encoding} ) {
                    warn "WARNING, content encoding stack '$encoding' is not "
                       . "described -- trying to guess\n";
                    $warnings++;
                }
                # Perform a default decoding, try to guess the encoding
                # layer type from the encoding ID
                $content = decode_textfield( $content, $encoding );
            } else {
                for my $layer (reverse @{$encodings->{$encoding}}) {
                    $content = decode_textfield( $content, $layer );
                }
            }
        };
        if( $@ ) {
            warn "WARNING, could not decode contents for file '$path' -- "
               . "$@; will not decode contents";
            $warnings++;
            $content = $values->{_tcod_file_contents}[$i];
        }

        if( $md5sum ) {
            if( md5_hex( $content ) ne $md5sum ) {
                warn "WARNING, MD5 checksums of the original '$path' "
                   . "and decoded files are different\n";
                $warnings++;
            }
        }
        if( $sha1sum ) {
            if( sha1_hex( $content ) ne $sha1sum ) {
                warn "WARNING, SHA1 checksums of the original '$path' "
                   . "and decoded files are different";
                $warnings++;
            }
        }
    }
    return $warnings;
}

sub check_z
{
    my ($dataset) = @_;
    my $warnings = 0;

    return $warnings if !tag_is_empty( $dataset, '_cell_formula_units_Z' );

    eval {
        cif_estimate_z( $dataset );
    };
    if( $@ ) {
        $@ =~ s/^([A-Z]+),\s*//;
        warn "WARNING, $@";
        $warnings++;
    }

    return $warnings;
}
