#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#* Find COD numbers for the .cif files in given directories of file lists.
#*
#* USAGE:
#*    $0 my-cif-dir1/ my-cif-dir2/files*.cif COD-cif-dir/
#* USAGE:
#*    $0 input1.cif input1_alt.cif
#**

use strict;
use warnings;
use File::Basename qw( basename );
use COD::CIF::Data qw( get_cell );
use COD::CIF::Parser qw( parse_cif );
use COD::CIF::Tags::CanonicalNames qw( canonicalize_all_names );
use COD::SOptions qw( getOptions );
use COD::SUsage qw( usage );
use COD::ErrorHandler qw( process_errors
                          process_parser_messages
                          report_message );
use COD::ToolsVersion;

my $die_on_error_level = {
    'ERROR'   => 1,
    'WARNING' => 0,
    'NOTE'    => 0
};

#* OPTIONS:
#*   --help, --usage
#*                     Output a short usage message (this message) and exit.
#*   --version
#*                     Output version information and exit.
#**
@ARGV = getOptions(
    '--help,--usage'    => sub { usage; exit },
    '--version'         => sub { print 'cod-tools version ',
                                 $COD::ToolsVersion::Version, "\n";
                                 exit }
);

my $check_bibliography = 1;

my $max_cell_length_diff = 0.5; # Angstroems
my $max_cell_angle_diff  = 1.2; # degrees

my %has_numeric_value = (
    '_journal_year'   => 1,
    '_journal_volume' => 1,
    '_journal_issue'  => 1,
);

my %skip_tag = (
    '_journal_name_full' => 0,
);

my %COD = ();

if( @ARGV < 2 ) {
    report_message( {
        'program'   => $0,
        'err_level' => 'ERROR',
        'message'   => 'please supply at least two directory names on the '
                     . 'command line -- names of directories with the '
                     . 'analysed CIF files come first and the name of the '
                     . 'directory with COD CIF files comes last'
    }, 1 );
}

my $COD_cif_dir = pop @ARGV;
my @COD_cif_files = `find $COD_cif_dir -name "*.cif" -o -name "*.CIF"`;

do {
    print int @COD_cif_files . "\n";
    print "@COD_cif_files";
} if 0;

for my $file (@COD_cif_files) {
    chomp $file;
    my %structures = ();
    eval {
        my $structures = structures_from_cif_file( $file );
        %structures = %$structures;
    }; # end of eval
    if ($@) {
        process_errors( {
          'program'       => $0,
          'filename'      => $file,
          'message'       => $@,
        }, $die_on_error_level->{'ERROR'} )
    };

    my $basename = basename( $file );
    for my $id (keys %structures) {
        my $formula = $structures{$id}{chemical_formula_sum};

        $formula = '?' unless defined $formula;

        push( @{$COD{$formula}}, $structures{$id} );
    }
}

do {
    use COD::Serialise qw( serialiseRef );
    serialiseRef( \%COD );
} if 0;

#------------------------------------------------------------------------------

my @cif_files = `find @ARGV -name "*.cif" -o -name "*.CIF"`;

for my $file (@cif_files) {
    chomp $file;
    my %structures = ();
    eval {
        my $structures = structures_from_cif_file( $file );
        %structures = %$structures;
    }; # end of eval
    if ($@) {
        process_errors( {
          'program'       => $0,
          'filename'      => $file,
          'message'       => $@,
        }, $die_on_error_level->{'ERROR'} )
    };

    for my $id (keys %structures) {
        my $formula = $structures{$id}{chemical_formula_sum};

        $formula = '?' unless defined $formula;

        my $final_formula = $formula;
        $final_formula =~ s/\s/_/g;

        my $n = 0;
        if( defined $COD{$formula} ) {
            for my $COD_entry (@{$COD{$formula}}) {
                if( entries_are_the_same( $structures{$id}, $COD_entry )) {
                    $n++;
                }
            }
        }
        if( $n > 0 ) {
            for my $COD_entry (@{$COD{$formula}}) {
                if( entries_are_the_same( $structures{$id}, $COD_entry )) {
                    printf
                        "%-35s %15s %3d %s\n",
                        $final_formula,
                        $COD_entry->{filename}, $n, $file;
                }
            }
        } else {
            printf "%-35s %15s %3d %s\n", $final_formula, '?', 0, $file;
        }
    }

}

#------------------------------------------------------------------------------

sub get_cell_local($)
{
    my ( $datablok ) = @_;

    return (
        $datablok->{_cell_length_a},
        $datablok->{_cell_length_b},
        $datablok->{_cell_length_c},
        $datablok->{_cell_angle_alpha},
        $datablok->{_cell_angle_beta},
        $datablok->{_cell_angle_gamma}
    );
}

sub cells_are_the_same($$)
{
    my ($cell1, $cell2) = @_;

    my @cell1 = get_cell_local( $cell1 );
    my @cell2 = get_cell_local( $cell2 );

    my $max_length_diff = 0;
    my $max_angle_diff = 0;

    for my $i (0..2) {
        my $length1 = $cell1[$i];
        my $length2 = $cell2[$i];
        if( defined $length1 and defined $length2 ) {
            my $diff = abs( $length1 - $length2 );
            if( $max_length_diff < $diff ) {
                $max_length_diff = $diff;
            }
        }
    }
    for my $i (3..5) {
        my $angle1 = $cell1[$i];
        my $angle2 = $cell2[$i];
        if( defined $angle1 and defined $angle2 ) {
            my $diff = abs( $angle1 - $angle2 );
            if( $max_angle_diff < $diff ) {
                $max_angle_diff = $diff;
            }
        }
    }

    return
        $max_length_diff < $max_cell_length_diff &&
        $max_angle_diff < $max_cell_angle_diff;
}

sub conditions_are_the_same
{
    my ($entry1, $entry2) = @_;

    for my $parameter ('temperature', 'pressure') {

        my %tags = map {($_,$_)} ( keys %{$entry1->{$parameter}},
                                   keys %{$entry2->{$parameter}} );
        for my $tag (keys %tags) {
            if( exists $entry1->{$parameter}{$tag} &&
                exists $entry2->{$parameter}{$tag} &&
                $entry1->{$parameter}{$tag} ne $entry2->{$parameter}{$tag} ) {
                return 0;
            }
        }
    }
    return 1;
}

sub bibliographies_are_the_same($$)
{
    my ($biblio1, $biblio2) = @_;

    my %tags = map {($_,$_)} ( keys %{$biblio1}, keys %{$biblio2} );

    for my $tag ( keys %tags ) {
        next if( $skip_tag{$tag} );
        if( defined $biblio1->{$tag} && defined $biblio2->{$tag} ) {
            if( $has_numeric_value{$tag} ) {
                if( $biblio1->{$tag} != $biblio2->{$tag} ) {
                    return 0;
                }
            } else {
                if( $biblio1->{$tag} ne $biblio2->{$tag} ) {
                    return 0;
                }
            }
        }
    }
    return 1;
}

sub data_sections_are_the_same($$)
{
    my ($entry1, $entry2) = @_;

    return
        $entry1->{filename} eq $entry2->{filename} &&
        $entry1->{id} eq $entry2->{id};
}

sub entries_are_the_same
{
    my ($entry1, $entry2) = @_;

    ## print ">>> $entry1->{id}, $entry2->{id}, ",
    ## defined $entry1->{suboptimal} ? $entry1->{suboptimal} : "" , " ", 
    ## defined $entry2->{suboptimal} ? $entry2->{suboptimal} : "", "\n";

    if( $check_bibliography ) {
        return
            ! data_sections_are_the_same( $entry1, $entry2 ) &&
            cells_are_the_same( $entry1->{cell}, $entry2->{cell} ) &&
            conditions_are_the_same( $entry1, $entry2 ) &&
            (!defined $entry1->{suboptimal} || $entry1->{suboptimal} ne 'yes') &&
            (!defined $entry2->{suboptimal} || $entry2->{suboptimal} ne 'yes') &&
            bibliographies_are_the_same( $entry1->{bibliography},
                                         $entry2->{bibliography} );
    } else {
        return
            ! data_sections_are_the_same( $entry1, $entry2 ) &&
            conditions_are_the_same( $entry1, $entry2 ) &&
            (!defined $entry1->{suboptimal} || $entry1->{suboptimal} ne 'yes') &&
            (!defined $entry2->{suboptimal} || $entry2->{suboptimal} ne 'yes') &&
            cells_are_the_same( $entry1->{cell}, $entry2->{cell} );
    }
}

sub structures_from_cif_file
{
    my( $filename ) = @_;

    my $options = { 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    process_parser_messages( $messages, $die_on_error_level );

    return {} if $err_count > 0;

    canonicalize_all_names( $data );

    my %structures;
    for my $datablock (@$data) {
        my $values = $datablock->{values};
        my @cell   = get_cell( $values, { silent => 1 } );

        my $formula = $values->{_chemical_formula_sum}[0];
        $formula =~ s/\s+/ /g;
        $formula =~ s/^\s+|\s+$//g;
        my $new_formula = join ' ', sort {$a cmp $b} split ' ', $formula;

        my $structure = {
            id => $datablock->{name},
            filename => basename( $filename ),
            chemical_formula_sum => $new_formula,
            _cell_length_a => $cell[0],
            _cell_length_b => $cell[1],
            _cell_length_c => $cell[2],
            _cell_angle_alpha => $cell[3],
            _cell_angle_beta  => $cell[4],
            _cell_angle_gamma => $cell[5],
       };
       for my $tag (@{$datablock->{tags}}) {
           if( $tag =~ /(temperature|pressure)/ ) {
               $structure->{$1}{$tag} = $values->{$tag}[0];
           }
           if( $tag =~ /^_journal/ && $tag ne '_journal_name_full' ) {
               $structure->{bibliography}{$tag} = $values->{$tag}[0];
           }
           if( $tag eq '_cod_suboptimal_structure' ||
               $tag eq '_[local]_cod_suboptimal_structure' ) {
               $structure->{suboptimal} = $values->{$tag}[0];
           }
       }
       $structures{$datablock->{name}} = $structure;
    }

    return \%structures;
}
