#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
# Merge data values in identical datablocks of multiple CIFs. Unique
# tags are combined into a single datablock of the output CIF; tags
# with equivalent values are silently merged into one. When a value
# differs for the same tag and the same datablock in two files, a
# warning (error) is issued.
#**

use strict;
use warnings;
use COD::CIF::Parser qw( parse_cif );
use COD::CIF::Tags::CanonicalNames qw( canonicalize_all_names );
use COD::CIF::Tags::Print qw( print_cif );
use COD::SOptions qw( getOptions );
use COD::SUsage qw( usage options );
use COD::UserMessage qw( warning error prefix_dataname );

my $use_parser = 'c';
my $override_tags;
my $override_all = 0;
my $merge_tags;

#* USAGE:
#*     $0 --options input1.cif input*.cif
#*
#* OPTIONS:
#*    --override-all
#*        Override all data items in the recipient CIF.
#*
#*    --dont-override-all
#*        Do not override all data items in the recipient CIF (default).
#*
#*    --override-tags  _tag1,_tag2
#*        Replace values for tags listed as an argument (_tag1 and _tag2 in
#*        this example) instead of keeping old values.
#*
#*    --merge-tags  _tag1,_tag2
#*        Merge values for tags listed as an argument (_tag1 and _tag2 in
#*        this example).
#*
#*   --use-perl-parser
#*        Use Perl parser to parse CIF files.
#*
#*   --use-c-parser
#*         Use C parser to parse CIF files (default).
#*
#*    --help, --usage
#*        Print a short usage message (this message) and exit.
#**
@ARGV = getOptions(
    "--merge-tags"         => \$merge_tags,
    "--override-tags"      => \$override_tags,
    "--override-all"       => sub { $override_all = 1 },
    "--dont-override-all"  => sub { $override_all = 0 },
    "--use-perl-parser"    => sub { $use_parser = "perl" },
    "--use-c-parser"       => sub { $use_parser = "c" },
    "--options"            => sub { options; exit },
    "--help,--usage"       => sub { usage; exit }
);

my ( %override_tags, %merge_tags );

if( $override_tags ) {
    %override_tags =
        map {( lc($_), $_ )} split( ",", $override_tags );
}

if( $merge_tags ) {
    %merge_tags =
        map {( lc($_), $_ )} split( ",", $merge_tags );
}

@ARGV = ( "-" ) unless @ARGV;

my %merged_datablocks;
my @merged_datablock_names;

for my $filename (@ARGV) {
    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );
    if ( $err_count > 0 ) {
        print STDERR $_ foreach ( @$messages );
        error( $0, $filename, undef, "$err_count error(s) "
             . "encountered while parsing the file", undef );
        exit 1;
    }

    canonicalize_all_names( $data );

    if( !@$data || !defined $data->[0] || !defined $data->[0]{name} ) {
        warning( $0, $filename, undef, "file seems to be empty", undef );
        next;
    }

    for my $datablock (@$data) {
        my $dataname = prefix_dataname($datablock->{name});
        if( !exists $merged_datablocks{$dataname} ) {
            push( @merged_datablock_names, $dataname );
            $merged_datablocks{$dataname} = $datablock;
        } else {
            my $new_datablock = $datablock;
            my $old_datablock = $merged_datablocks{$dataname};
            for my $tag (@{$new_datablock->{tags}}) {
                if( !exists $old_datablock->{values}{$tag} ) {
                    ## print ">>> old datablock does not have tag $tag\n";
                    if( exists $new_datablock->{inloop}{$tag} ) {
                        ## print ">>> tag '$tag' is in a loop...\n";
                        ## warn "Merging loops (tag $tag) is not supported " .
                        ##     "in this version";
                        my $new_loop_id = $new_datablock->{inloop}{$tag};
                        ## print ">>> ... it is loop $new_loop_id.\n";
                        my $old_loop_id;
                        for my $loop_tag (
                            @{$new_datablock->{loops}[$new_loop_id]} ) {
                            ## print ">>> checking '$loop_tag'...\n";
                            if( exists $old_datablock->{values}{$loop_tag} &&
                                exists $old_datablock->{inloop}{$loop_tag} ) {
                                $old_loop_id = $old_datablock->{inloop}{$loop_tag};
                                die unless defined $old_loop_id; # assert...
                                ## print ">>> found it in $old_loop_id\n";
                                if( int( @{$old_datablock->
                                            {values}{$loop_tag}} ) !=
                                    int( @{$new_datablock->{values}{$tag}} )) {
                                    error( $0, $filename, $dataname,
                                        "loop tag '$loop_tag' has different "
                                      . "number of values than the tag '$tag' "
                                      . "in '${filename}, but '$tag' must end "
                                      . "up in the same loop", undef );
                                    die;
                                }
                                last;
                            }
                        }
                        if( defined $old_loop_id ) {
                            push( @{$old_datablock->{loops}[$old_loop_id]},
                                  $tag );
                            $old_datablock->{inloop}{$tag} = $old_loop_id;
                            ## print ">>> pushing '$tag' to old loop $old_loop_id\n";
                            ## print ">>> it already has tags @{$old_datablock->{loops}[$old_loop_id]}\n";
                        } else {
                            push( @{$old_datablock->{loops}}, [ $tag ] );
                            $old_datablock->{inloop}{$tag} =
                                $#{$old_datablock->{loops}};
                            ## print ">>> starting new loop $#{$old_datablock->{loops}} for tag '$tag'\n";
                        }
                    }
                    ## print "\n";

                    push( @{$old_datablock->{tags}}, $tag );

                    $old_datablock->{values}{$tag} =
                        $new_datablock->{values}{$tag};

                    $old_datablock->{precisions}{$tag} =
                        $new_datablock->{precisions}{$tag};

                    $old_datablock->{types}{$tag} =
                        $new_datablock->{types}{$tag};
                } else {
                    if( $merge_tags{lc($tag)} ) {
                        for( my $i = 0;
                             $i <= $#{$old_datablock->{values}{$tag}};
                             $i ++ ) {
                            $old_datablock->{values}{$tag}[$i] .= "\n" .
                                $new_datablock->{values}{$tag}[$i];
                        }
                    } elsif( defined $override_tags{lc($tag)} ||
                             $override_all ) {
                        for( my $i = 0;
                             $i <= $#{$old_datablock->{values}{$tag}};
                             $i ++ ) {
                            $old_datablock->{values}{$tag}[$i] =
                                $new_datablock->{values}{$tag}[$i];
                        }
                    } elsif( !values_are_equal( $old_datablock->{values}{$tag},
                                           $new_datablock->{values}{$tag} )) {
                        warning( $0, $filename, $dataname, "values for "
                               . "tag '$tag' in '$datablock->{name}' differ",
                                  undef );
                    }
                }
            }
        }
    }
}

## use COD::Serialise;
## serialiseRef( \%merged_datablocks );

for my $dataname (@merged_datablock_names) {
    print_cif( $merged_datablocks{$dataname},
               { keep_tag_order => 1, preserve_loop_order => 1 } );
}

sub values_are_equal
{
    my ($old_values, $new_values) = @_;

    if( int(@$old_values) != int(@$new_values) ) {
        return 0;
    }

    for( my $i = 0; $i <= $#{$new_values}; $i ++ ) {
        if( $new_values->[$i] ne $old_values->[$i] ) {
            return 0;
        }
    }

    return 1;
}
