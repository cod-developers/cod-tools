#! /bin/sh
#!perl -w # --*- Perl -*--
eval 'exec perl -x $0 ${1+"$@"}'
    if 0;
#------------------------------------------------------------------------------
#$Author$
#$Date$ 
#$Revision$
#$URL$
#------------------------------------------------------------------------------
#*
#  Performs Niggli cell reduction of CIF files.
#**

use strict;
use warnings;
use COD::Algebra::Vector qw(vector_matrix_mul);
use COD::CIF::Parser qw(parse_cif);
use COD::CIF::Data qw(get_cell);
use COD::CIF::Tags::CanonicalNames;
use COD::CIF::Tags::Print;
use COD::Cell::Niggli::KG76 qw(reduce);
use COD::Fractional;
use COD::Spacegroups::Symop::Algebra qw(symop_transpose symop_mul);
use COD::SOptions;
use COD::SUsage qw(usage options);
use COD::UserMessage;

sub cholesky($);

my $use_parser = 'c';
$COD::Cell::Niggli::KG76::debug = 0;

my $Pi = 4 * atan2(1,1);

#* USAGE:
#*     $0 --options input1.cif input*.cif
#*
#* OPTIONS:
#*     --use-perl-parser
#*        Use Perl parser for CIF parsing.
#*
#*     --use-c-parser
#*        Use Perl & C parser for CIF parsing.
#*
#*     --debug, --no-debug
#*        Turn on/off the debug prints of reduction algorithm. Default off.
#*
#*     --help, --usage
#*        Print short usage message (this message) and exit.
#**
@ARGV = getOptions(
    "--debug"    => sub{ $COD::Cell::Niggli::KG76::debug = 1 },
    "--no-debug" => sub{ $COD::Cell::Niggli::KG76::debug = 0 },

    "--use-perl-parser" => sub { $use_parser = "perl" },
    "--use-c-parser"    => sub { $use_parser = "c" },
    "--options"         => sub { options; exit },
    "--help,--usage"    => sub { usage; exit }
);

@ARGV = ( "-" ) unless @ARGV;

for my $filename (@ARGV) {

    my $options = { 'parser' => $use_parser, 'no_print' => 1 };
    my ( $data, $err_count, $messages ) = parse_cif( $filename, $options );

    if ( $err_count > 0 ) {
        print STDERR $_ foreach ( @$messages );
        error( $0, $filename, undef, "$err_count error(s) "
             . "encountered while parsing the file", undef );
        next;
    }
    print STDERR $_ foreach ( @$messages );

    canonicalize_all_names( $data );

    for my $datablock (@$data) {
        my $values = $datablock->{values};
        my @cell = get_cell( $values, $filename, $datablock->{name} );
        my $f2o = symop_ortho_from_fract( @cell );
        my @niggli = reduce( @cell );
        my $o2f = symop_fract_from_ortho( @niggli );
        my $CoB = pop( @niggli );

        $values->{_cell_length_a}[0] = $niggli[0];
        $values->{_cell_length_b}[0] = $niggli[1];
        $values->{_cell_length_c}[0] = $niggli[2];
        $values->{_cell_angle_alpha}[0] = $niggli[3];
        $values->{_cell_angle_beta}[0]  = $niggli[4];
        $values->{_cell_angle_gamma}[0] = $niggli[5];

        my( $a, $b, $c ) = @cell;
        my( $ca, $cb, $cg ) = map { cos( $Pi * $_ / 180 ) }
                                  @cell[3..5];

        for my $i (0..$#{$values->{_atom_site_label}}) {
            my( $fx, $fy, $fz ) = map { s/(\(\d+\))?$//; $_ }
                                  map { $values->{$_}[$i] }
                                    qw( _atom_site_fract_x
                                        _atom_site_fract_y
                                        _atom_site_fract_z );

            ( $values->{_atom_site_fract_x}[$i],
              $values->{_atom_site_fract_y}[$i],
              $values->{_atom_site_fract_z}[$i] ) =
                vector_matrix_mul( [ $fx, $fy, $fz ], $CoB );
        }

        print_cif( $datablock,
           {
                preserve_loop_order => 1,
                keep_tag_order => 1
           }
        );
    }
}

sub mat3_inv
{
    my( $m ) = @_;
    my $c = 1 / symop_det($m);
    return [[ $c * ( $m->[1][1] * $m->[2][2] - $m->[1][2] * $m->[2][1] ),
             -$c * ( $m->[0][1] * $m->[2][2] - $m->[0][2] * $m->[2][1] ),
              $c * ( $m->[0][1] * $m->[1][2] - $m->[0][2] * $m->[1][1] )],
            [-$c * ( $m->[1][0] * $m->[2][2] - $m->[1][2] * $m->[2][0] ),
              $c * ( $m->[0][0] * $m->[2][2] - $m->[0][2] * $m->[2][0] ),
             -$c * ( $m->[0][0] * $m->[1][2] - $m->[0][2] * $m->[1][0] )],
            [ $c * ( $m->[1][0] * $m->[2][1] - $m->[1][1] * $m->[2][0] ),
             -$c * ( $m->[0][0] * $m->[2][1] - $m->[0][1] * $m->[2][0] ),
              $c * ( $m->[0][0] * $m->[1][1] - $m->[0][1] * $m->[1][0] )]];
}

sub cholesky($)
{
    my( $m ) = @_;
    return [[0,0,0],[0,0,0],[0,0,0]] if $m->[0][0] == 0;

    my $a = sqrt($m->[0][0]);
    my $b = 0;
    my $c = 0;
    my $d = $m->[1][0] / $a;
    my $g = $m->[2][0] / $a;

    my $e = sqrt($m->[1][1] - $d**2);
    my $f = 0;
    my $h = ($m->[2][1] - $d*$g) / $e;

    my $i = sqrt($m->[2][2] - $g**2 - $h**2);
    return [[$a,$b,$c],[$d,$e,$f],[$g,$h,$i]];
}
